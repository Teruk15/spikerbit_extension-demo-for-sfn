{"entries":[{"timestamp":1725891104300,"editorVersion":"7.0.40","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":1014,"start2":1014,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":1150,"start2":1150,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":1230,"start2":1230,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":1327,"start2":1327,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"></"]],"start1":1533,"start2":1533,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":1618,"start2":1618,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":1726,"start2":1726,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":1837,"start2":1837,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":1972,"start2":1972,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":2052,"start2":2052,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":2151,"start2":2151,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":2227,"start2":2227,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":2334,"start2":2334,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":2404,"start2":2404,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":2473,"start2":2473,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":2578,"start2":2578,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"></"]],"start1":2675,"start2":2675,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":2750,"start2":2750,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":2830,"start2":2830,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":2965,"start2":2965,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"></"]],"start1":3116,"start2":3116,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":3186,"start2":3186,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":3298,"start2":3298,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":3389,"start2":3389,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":3520,"start2":3520,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":3664,"start2":3664,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><v"]],"start1":3784,"start2":3784,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":3846,"start2":3846,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\" x="]],"start1":3958,"start2":3958,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":4106,"start2":4106,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":4192,"start2":4192,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":4274,"start2":4274,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":4363,"start2":4363,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"></"]],"start1":4450,"start2":4450,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":4525,"start2":4525,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":4605,"start2":4605,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"><f"]],"start1":4758,"start2":4758,"length1":35,"length2":14},{"diffs":[[0,"bled"],[-1,"-reasons=\"MANUALLY_DISABLED"],[1,"=\"true"],[0,"\"></"]],"start1":4889,"start2":4889,"length1":35,"length2":14}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1725891105935,"editorVersion":"7.0.40","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"        "],[-1," //"],[0," basic.p"]],"start1":263,"start2":263,"length1":19,"length2":16}]}]},{"timestamp":1725891883946,"editorVersion":"7.0.40","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"er.push("],[-1,"analo"],[1,"0"],[0,");\n     "]],"start1":248,"start2":248,"length1":21,"length2":17}]}]},{"timestamp":1725893896559,"editorVersion":"7.0.40","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"push(ana"],[1,"lo"],[0,");\n     "]],"start1":251,"start2":251,"length1":16,"length2":18}]}]},{"timestamp":1725893897369,"editorVersion":"7.0.40","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"ush("],[-1,"pins.analogReadPin(AnalogPin.P0)"],[1,"ana"],[0,");\n "]],"start1":252,"start2":252,"length1":40,"length2":11},{"diffs":[[0,"        "],[1," //"],[0," basic.p"]],"start1":265,"start2":265,"length1":16,"length2":19},{"diffs":[[0,"c.pause("],[-1,"2"],[1,"1"],[0,"); // Ne"]],"start1":281,"start2":281,"length1":17,"length2":17}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"variable id=\"Fke=%BI3oq47G6U{e$6P\">sample_rate</variable><variable id=\"a`Vjw}{(7r51K7*i!Ew9\">time_interval</variable><variable id=\"SaR-W{{t*DLq$zfH1kR^\">running_time</variable><variable id=\"7eSLJp2;Sg%x`wH111in\">start_time</variable><variable id=\"eR76fk0k{{Q}#-rS+-m+\">begin_time</variable><variable id=\")Pvo]W+hcM!Pg9{uYV{5\">elapsed_time</variable><variable id=\"NK$54-HQfc(iN)O6G^YZ\">num</variable><variable id=\"s!1WLt6=qii!jw3yXTh{\">bool</variable><"],[0,"/variabl"]],"start1":59,"start2":59,"length1":16,"length2":467},{"diffs":[[0," x=\""],[-1,"0"],[1,"-159"],[0,"\" y=\""],[-1,"0"],[1,"-1378"],[0,"\"><s"]],"start1":555,"start2":555,"length1":15,"length2":22},{"diffs":[[0,"pe=\""],[-1,"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><block type=\"neurobit_return_size\"></block></value></block></next"],[1,"basic_show_icon\"><field name=\"i\">IconNames.Heart</field><next><block type=\"basic_show_icon\"><field name=\"i\">IconNames.SmallHeart</field><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_return_size\"></block></value></block></next></block></next></block></statement></block><block type=\"variables_set\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"423\" y=\"-350\"><field name=\"VAR\" id=\"s!1WLt6=qii!jw3yXTh{\">bool</field><value name=\"VALUE\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"logic_boolean\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"BOOL\">TRUE</field></block></value><next><block type=\"variables_set\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"VAR\" id=\"7eSLJp2;Sg%x`wH111in\">start_time</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"device_get_running_time_micros\" disabled-reasons=\"MANUALLY_DISABLED\"></block></value></block></next></block><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"544\" y=\"-160\"><field name=\"i\">IconNames.Heart</field><next><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"i\">IconNames.SmallHeart</field></block></next></block><block type=\"variables_set\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"255\" y=\"-39\"><field name=\"VAR\" id=\"s!1WLt6=qii!jw3yXTh{\">bool</field><value name=\"VALUE\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"logic_boolean\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"BOOL\">FALSE</field></block></value></block><block type=\"device_while\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"0\" y=\"0\"><value name=\"COND\"><shadow type=\"logic_boolean\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"BOOL\">TRUE</field></shadow></value></block><block type=\"control_running_time\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"462\" y=\"39\"></block><block type=\"continue_keyword\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"432\" y=\"87\"></block><block type=\"math_arithmetic\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"753\" y=\"192\"><field name=\"OP\">MINUS</field><value name=\"A\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"device_get_running_time_micros\" disabled-reasons=\"MANUALLY_DISABLED\"></block></value><value name=\"B\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"VAR\" id=\"7eSLJp2;Sg%x`wH111in\">start_time</field></block></value></block><block type=\"device_show_number\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"330\" y=\"393\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_return_size\" disabled-reasons=\"MANUALLY_DISABLED\"></block></value></block><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"629\" y=\"406\"><field name=\"i\">IconNames.SmallHeart</field><next><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"i\">IconNames.Heart</field><next><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"i\">IconNames.SmallHeart</field></block></next></block></next></block><block type=\"device_show_number\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"125\" y=\"443\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"VAR\" id=\"NK$54-HQfc(iN)O6G^YZ\">num</field></block></value><next><block type=\"device_pause\" disabled-reasons=\"MANUALLY_DISABLED\"><value name=\"pause\"><shadow type=\"timePicker\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"ms\">1000</field></shadow></value></block></next></block><block type=\"device_while\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"381\" y=\"455\"><value name=\"COND\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"OP\">LT</field><value name=\"A\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"OP\">MINUS</field><value name=\"A\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"control_running_time\" disabled-reasons=\"MANUALLY_DISABLED\"></block></value><value name=\"B\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"VAR\" id=\"7eSLJp2;Sg%x`wH111in\">start_time</field></block></value></block></value><value name=\"B\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">1000</field></shadow></value></block></value><statement name=\"DO\"><block type=\"continue_keyword\" disabled-reasons=\"MANUALLY_DISABLED\""],[0,"></b"]],"start1":610,"start2":610,"length1":239,"length2":5092}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"sic."],[-1,"pause(1000"],[1,"showIcon(IconNames.Heart)\nbasic.showIcon(IconNames.SmallHeart"],[0,")\nba"]],"start1":2,"start2":2,"length1":18,"length2":69}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1725894072844,"editorVersion":"7.0.40","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1726089500681,"editorVersion":"7.0.40","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"//"],[-1," Enums to be used in extension\nenum Signal {\n    EEG,\n    EMG,\n    ECG,\n    EOG\n}\n\nenum Cue {\n    none,\n    visual,\n    audio\n}\n\nenum LookingAt {\n    none,\n    up,\n    left,\n    right,\n    down,\n    blink\n}\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n\n    /**\n     * Return pin to record EEG\n     */\n\n    //% group=\"Signal\"\n    //% weight=50 \n    //% block=\"EEG\"\n    export function eeg(): number {\n        return pins.analogReadPin(AnalogPin.P0);\n    }\n\n\n    /**\n     * Return pin to record EMG\n     */\n\n    //% group=\"Signal\"\n    //% weight=49 \n    //% block=\"EMG\"\n    export function emg(): number {\n        // Check switch here\n        return pins.analogReadPin(AnalogPin.P0);\n    }\n\n\n    /**\n     * Return pin to record ECG\n     */\n\n    //% group=\"Signal\"\n    //% weight=48\n    //% block=\"ECG\"\n    export function ecg(): number {\n        return pins.analogReadPin(AnalogPin.P1);\n    }\n\n    /**\n     * Return pin to record EOG\n     */\n\n    //% group=\"Signal\"\n    //% weight=47\n    //% block=\"EOG\"\n    export function eog(): number {\n        return pins.analogReadPin(AnalogPin.P0);\n    }\n\n    /**\n     * Return the maximum threshold from some time intervals(ms).\n     * As an optional argument, you can change the percentage of threshold\n     * to be returned. The defaulut is 100(%).\n     * @param ms = duration(ms) to run the get and caluculate max theshold.\n     * @param percent (optional) = number as percentage of threshold to be returned. The default is 100%.\n     */\n\n    //% group=\"EMG\"\n    //% weight=46\n    //% block=\"get threshold from $ms ms || and return with $percent percent\"\n    //% expandableArgumentMode=\"enable\"\n    //% ms.shadow=timePicker\n    //% percent.defl=100\n    export function getThreshold(ms: number, percent?: number) {\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n\n        while (control.millis() - startTimer < ms) {\n            val = emg();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n        }\n\n        return max_val * (percent / 100);\n    }\n\n\n    /**\n     * Return the number of spikes that happened during some duration(ms).\n     * You can also change the duration but the default is 3000 (i.e. 3 seconds).\n     * If you grip tight for minimum 500ms (then release), \n     * it will return as -1. \n     * @param ms = duration(ms) to run the spike recording.\n     */\n\n    //% group=\"EMG\"\n    //% weight=45\n    //% block=\"count spikes for $ms ms\"\n    //% ms.shadow=timePicker\n    //% ms.defl=3000\n    export function countSpikes(ms: number) {\n        const down_sample_fs = 200;\n        const period = 1000000 / down_sample_fs;\n        let elapsed_time = 0;\n        let elapsed_time2 = 0;\n\n        const buffer_size = 20;\n        let buffer: number[] = [];\n\n        // Smoothing function for signal\n        function movingAverage(data: number[], windowSize: number): number {\n            let sum = 0.0;\n            let smoothedData = 0;\n            //overflow -> floating point\n            for (let j = 0; j < windowSize; j++) {\n                sum += data[j];\n            }\n            smoothedData = sum / windowSize;\n            return smoothedData;\n        }\n\n        const threshold = 150;\n        const interval = 500;\n        let signal = 0;\n        let smooth_signal = 0;\n        let counter = 0;\n        let checking = false;\n        let check_time = -interval;\n        let check_grip = false;\n\n        const startTimer = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Begin Timer\n        while (control.millis() - startTimer < ms) {\n            signal = emg();\n\n            // Fill the buffer before the main process\n            if (buffer.length < buffer_size) {\n                buffer.push(signal);\n            }\n\n            // Once the buffer fills up, shift\n            if (buffer.length == buffer_size) {\n                buffer.shift();\n                buffer.push(signal);\n\n                // Smooth out the signal\n                smooth_signal = movingAverage(buffer, buffer.length);\n\n                // Check the signal above threshold\n                let sample_time2 = input.runningTimeMicros();\n                while (smooth_signal > threshold) {\n                    signal = emg();\n\n                    buffer.shift();\n                    buffer.push(signal);\n\n                    smooth_signal = movingAverage(buffer, buffer.length);\n\n                    if (!checking) {\n                        // Record the time when the spike is detected\n                        // for only once at the beggining during the rising\n                        check_time = control.millis();\n                        checking = true;\n                    }\n\n                    // Checking for grip\n                    check_grip = true;\n\n                    elapsed_time2 = input.runningTimeMicros() - sample_time2;\n\n                    if (elapsed_time2 < period) {\n                        control.waitMicros(period - elapsed_time2);\n                    }\n\n                    sample_time2 = input.runningTimeMicros();\n                }\n\n                // Once signl drops down below the threshold, allow \n                // check (for spike) to happen\n                checking = false;\n\n                // Check if the spike is within the interval window\n                // to reduce false positives\n                if (control.millis() - check_time < interval) {\n                    check_grip = false;\n                    counter++; // Increment counter for detected spikes\n                    check_time = -interval; // Reset check time\n                }\n\n                // If the signal goes over one second, assume due to\n                // the grip\n                if (check_grip) {\n                    counter = -1;\n                }\n\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();\n        }\n\n        return counter; // Return the spike count\n    }\n\n\n    /**\n     * Give the reaction time from certain cue. User have options to\n     * choose either from visual (Heart Icon) or audio (1/2 beat) cue\n     * with given threshold. \n     * @param cue (optional) = options for user to choose type of cue (visually or auditory). The default is none.\n     * @param threshold (optional) = user have option to select their desired threshold. The default is 200.\n     */\n\n    //% group=\"EMG\"\n    //% weight=44\n    //% block=\"measure reaction time ||add cue $cue add threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=200\n    //% inlineInputMode=inline\n    export function reactionTime(cue?: Cue, threshold?: number) {\n        const cue_time = 100; // [ms]\n        const ms = 1500; // Give user 1.5 seconds to make reaction\n        let signal = 0;\n        let result = ms;\n        let once = true;\n\n        //At beggining, give user a cue if needed\n        switch (cue) {\n            case Cue.none: {\n                break;\n            }\n            case Cue.visual: {\n                basic.showIcon(IconNames.Heart, cue_time);\n                basic.clearScreen();\n                break;\n            }\n            case Cue.audio: {\n                pins.setAudioPin(AnalogPin.P16);\n                music.play(music.tonePlayable(262, cue_time),\n                    music.PlaybackMode.InBackground);\n                break;\n            }\n        }\n\n        const startTime = control.millis();\n\n        // Begin measuring the reaction time\n        while (control.millis() - startTime < ms) {\n            signal = emg();\n            // (only once) if the signal go above the threshold,\n            // save the reaction time. \n            if (signal > threshold && once) {\n                result = control.millis() - startTime;\n                once = false;\n            }\n        }\n\n        // If user fails to react, return as undefined (question mark)\n        if (result == ms) {\n            return undefined;\n        }\n        else {\n            return result;\n        }\n    }\n\n\n    /**\n     * Return the average heart beat (bpm) in 5 seconds(default).\n     * You can also change the time for recording from \n     * optional argument.\n     * @param ms (optional) = duration(ms) to run the hearbeat recording. The default is 5000 (i.e. 5 seconds).\n     */\n\n    //% group=\"ECG\"\n    //% weight=43\n    //% block=\"measure heartbeat (bpm) || for $ms ms\"\n    //% ms.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% ms.defl=5000\n    export function heartBeat(ms: number) {\n        const down_sample_fs = 150 //Hz;\n        const period = 1000000 / down_sample_fs;\n        let elapsed_time = 0\n\n        const range = 300;\n        const buffer_size = 6;\n        let buffer: number[] = [];\n        // let buffer_index = 0;\n        let beat_num = 0;\n        let unit = 0;\n        let sum_unit = 0;\n        let wait = 0;\n        let last_beat = 0;\n\n\n        // Fill the buffer first\n        for (let i = 0; i < buffer_size; i++) {\n            buffer.push(ecg());\n        }\n\n        const startTime = control.millis();\n        let prev_beat = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Keep running until time runs out\n        while (control.millis() - startTime < ms) {\n            if (wait <= 0) {\n\n                // Buffer minimum, maximum calculation\n                let buffer_min = buffer[0];\n                let buffer_max = buffer[0];\n\n                for (let i = 1; i < buffer_size; i++) {\n                    if (buffer_min > buffer[i]) {\n                        buffer_min = buffer[i];\n                    }\n\n                    if (buffer_max < buffer[i]) {\n                        buffer_max = buffer[i];\n                    }\n                }\n\n                // If the range of buffer is greator than certain range,\n                // do heartbeat caluculation\n                if (buffer_max - buffer_min > range) {\n                    basic.showIcon(IconNames.Heart, 150);\n                    basic.clearScreen();\n                    last_beat = control.millis() - prev_beat;\n                    prev_beat = control.millis();\n                    let largeBox = Math.floor(last_beat / 200);\n                    let smallBox = Math.floor((last_beat - largeBox * 200) / 40);\n                    unit = 1 * largeBox + 0.2 * smallBox;\n                    sum_unit += unit;\n                    beat_num++;\n                    // Wait for buffer_size * 3. \n                    // This is possible because distance between\n                    // human heart beat is no smaller than time for\n                    // buffer_size * 3 samples\n                    wait = buffer_size * 3;\n                }\n            }\n\n\n            // May need to use shift\n            buffer.shift();\n            buffer.push(ecg());\n            // buffer[buffer_index] = val;\n            // buffer_index = (buffer_index + 1) % buffer_size;\n            wait--;\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time)\n            }\n\n            sample_time = input.runningTimeMicros()\n        }\n\n        // Check to avoid division by zero\n        return beat_num > 0 ? 300 / (sum_unit / beat_num) : undefined;\n    }\n\n\n    let currently_up = false;\n    let currently_down = false;\n    let center_UD = false;\n    let cooldown_counter = 0;\n    let blink_buffer: number[] = [];\n    let updown_buffer: number[] = [];\n\n    /**\n     * Return enums (up/down/blink) if user move their eyes in\n     * vertical direction.\n     */\n\n    //% group=\"EOG\"\n    //% weight=42\n    //% block=\"direction (VEOG)\"\n    export function gazeV(): number {\n        const time = 500; // [ms]\n\n        const down_sample_fs = 50; // [Hz]\n        const period = 1000000 / down_sample_fs; // [μs/hz]\n        let elapsed_time = 0;\n\n        let result = LookingAt.none;\n\n        const baseline = 450;\n\n        const buffer_size = 10;\n        const wait_size = Math.floor(down_sample_fs / 3); // 1/3 of second\n        let avgBuffer = 0;\n\n        let slope = 0;\n        const cooldown_period = wait_size + buffer_size;\n\n        // Function to return the averge slope of buffer\n        function calculateSlope(data: number[]): number {\n            const n = data.length;\n            let xSum = 0;\n            let ySum = 0;\n            let xySum = 0;\n            let xSquaredSum = 0;\n\n            for (let x = 0; x < n; x++) {\n                xSum += x;\n                ySum += data[x];\n                xySum += x * data[x];\n                xSquaredSum += x * x;\n            }\n\n            return (n * xySum - xSum * ySum) / (n * xSquaredSum - xSum * xSum);\n        }\n\n        const start_time = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Keep running until time runs out\n        while (control.millis() - start_time < time) {\n            let signal = eog();\n\n            // Shift the buffer so blink analysis happens eariler than\n            // up or down analysis\n            if (blink_buffer.length < wait_size) {\n                blink_buffer.push(signal);\n            } else {\n                if (updown_buffer.length < buffer_size) {\n                    updown_buffer.push(blink_buffer.shift());\n                } else {\n                    updown_buffer.shift();\n                    updown_buffer.push(blink_buffer.shift());\n                }\n\n                blink_buffer.push(signal);\n            }\n\n            if (updown_buffer.length == buffer_size) {\n                slope = calculateSlope(blink_buffer.slice(0, buffer_size));\n                avgBuffer = updown_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n                // Blinking\n                if (slope < -75) {\n                    // Begin cool down\n                    cooldown_counter = 0;\n                    result = LookingAt.blink;\n                }\n\n                // If cooldown is happening\n                if (cooldown_counter >= cooldown_period) {\n                    // Looking Up\n                    if (avgBuffer > baseline * 1.40) {\n                        if (currently_down) {\n                            center_UD = true;\n                        } else {\n                            result = LookingAt.up;\n                            center_UD = false;\n                            currently_up = true;\n                        }\n                        // Looking Down \n                    } else if (avgBuffer < baseline * 0.60) {\n                        if (currently_up) {\n                            center_UD = true;\n                        } else {\n                            result = LookingAt.down;\n                            center_UD = false;\n                            currently_down = true;\n                        }\n                    } else {\n                        if (center_UD) {\n                            currently_up = false;\n                            currently_down = false;\n                        }\n                    }\n                } else {\n                    cooldown_counter++;\n                }\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();\n        }\n\n        return result;\n\n    }\n\n\n    let currently_left = false;\n    let currently_right = false;\n    let center_LR = false;\n    let leftright_buffer: number[] = [];\n\n    /**\n     * Return enums (left/right) if user move their eyes in\n     * horizontal direction.\n     */\n\n    //% group=\"EOG\"\n    //% weight=41\n    //% block=\"direction (HEOG)\"\n    export function gazeH(): number {\n        const time = 500; // [ms]\n\n        const down_sample_fs = 50 // [Hz]\n        const period = 1000000 / down_sample_fs // [μs/hz]\n        let elapsed_time = 0;\n\n        let result = LookingAt.none;\n\n        const baseline = 450;\n\n        const buffer_size = 10;\n        let avgBuffer = 0;\n\n        const start_time = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Keep running until time runs out\n        while (control.millis() - start_time < time) {\n            let signal = eog();\n\n            // If the buffer is not full yet, keep adding\n            if (leftright_buffer.length < buffer_size) {\n                leftright_buffer.push(signal);\n            }\n\n            // If the buffer is full, begin main process\n            if (leftright_buffer.length == buffer_size) {\n                leftright_buffer.shift();\n                leftright_buffer.push(signal);\n\n                // Calculate average of buffer\n                avgBuffer = leftright_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n                // Looking Left\n                if (avgBuffer > baseline * 1.25) {\n                    if (currently_right) {\n                        center_LR = true;\n                    }\n                    else {\n                        center_LR = false;\n                        currently_left = true;\n                        result = LookingAt.left;\n                    }\n                }\n                // Looking Right\n                else if (avgBuffer < baseline * 0.75) {\n                    if (currently_left) {\n                        center_LR = true;\n                    }\n                    else {\n                        center_LR = false;\n                        currently_right = true;\n                        result = LookingAt.right;\n                    }\n                }\n                else {\n                    if (center_LR) {\n                        currently_left = false;\n                        currently_right = false;\n                    }\n                }\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();\n        }\n\n        return result;\n\n    }\n\n\n    /**\n     * Return true if user blinks within some time, false otherwise.\n     * Defining time is optional argument (the default is one second). \n     * @param ms (optional) = duration(ms) to check blink. The default is 1000 (i.e 1 seconds).\n     */\n\n    //% group=\"EOG\"\n    //% weight=40\n    //% block=\"blinked|| within $ms ms\"\n    //% ms.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% ms.defl=1000\n    export function blinks(ms?: number): boolean {\n        const down_sample_fs = 50 //[Hz]\n        const period = 1000000 / down_sample_fs //[μs/hz]\n        let elapsed_time = 0;\n\n        const buffer_size = 2;\n        let buffer = [];\n\n        const threshold = 40;\n        const blink_time = 300; //[ms]\n\n        let blink_check_timer = 0;\n        let start_val = 0;\n        let currently_checking = false;\n\n        let exit = false;\n\n        const start_time = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Keep calculating until \n        // 1). time runs out\n        // 2). user blinked\n        while (control.millis() - start_time < ms && !exit) {\n            let signal = eog();\n\n            // If the buffer is not full yet, keep adding\n            if (buffer.length < buffer_size) {\n                buffer.push(signal);\n            }\n\n            // If the buffer is full, begin main process\n            if (buffer.length == buffer_size) {\n                buffer.shift();\n                buffer.push(signal);\n\n                // Do the following only when first point and second point \n                // differs by more than threshold\n                if (Math.abs(buffer[0] - buffer[1]) > threshold) {\n                    if (!currently_checking && buffer[1] > buffer[0]) {\n                        blink_check_timer = control.millis();\n                        start_val = buffer[0];\n                        currently_checking = true;\n                    }\n\n                    if (control.millis() - blink_check_timer < blink_time) {\n                        if (buffer[0] < start_val) {\n                            currently_checking = false;\n                            exit = true;\n                        }\n                    }\n                    else {\n                        currently_checking = false;\n                    }\n                }\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();\n        }\n\n        return exit;\n\n    }\n\n\n    /**\n     * Looking Up (use with VEOG direction)\n     */\n\n    //% group=\"EOG\"\n    //% weight=39\n    //% block=\"up\"\n    export function up(): number {\n        return LookingAt.up;\n    }\n\n\n    /**\n     * Looking Down (use with VEOG direction)\n     */\n\n    //% group=\"EOG\"\n    //% weight=38\n    //% block=\"down\"\n    export function down(): number {\n        return LookingAt.down;\n    }\n\n\n    /**\n     * Looking Left (use with HEOG direction)\n     */\n\n    //% group=\"EOG\"\n    //% weight=37\n    //% block=\"left\"\n    export function left(): number {\n        return LookingAt.left;\n    }\n\n\n    /**\n     * Looking Right (use with HEOG direction)\n     */\n\n    //% group=\"EOG\"\n    //% weight=36\n    //% block=\"right\"\n    export function right(): number {\n        return LookingAt.right;\n    }\n\n\n    /**\n     * Blink (use with VEOG direction)\n    */\n\n    //% group=\"EOG\"\n    //% weight=35\n    //% block=\"blink\"\n    export function blink(): number {\n        return LookingAt.blink;\n    }\n\n\n    /**\n     * Choose the signal to print in Serial. \n     * You can also specify the specific time to run the printing. \n     * The default loops.\n     * @param signal = choose electrophysiology\n     * @param duration (optional) = duration(ms) to output the signal. If user does not provide one, then loops\n     */\n\n    //% group=\"Other\"\n    //% weight=30\n    //% block=\"print $signal || for $duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(signal: Signal, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                switch (signal) {\n                    case Signal.EEG: {\n                        serial.writeValue(\"EEG\", eeg());\n                        break;\n                    }\n                    case Signal.EMG: {\n                        serial.writeValue(\"EMG\", emg());\n                        break;\n                    }\n                    case Signal.ECG: {\n                        serial.writeValue(\"ECG\", ecg());\n                        break;\n                    }\n                    case Signal.EOG: {\n                        serial.writeValue(\"EOG\", eog());\n                        break;\n                    }\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                switch (signal) {\n                    case Signal.EEG: {\n                        serial.writeValue(\"EEG\", eeg());\n                        break;\n                    }\n                    case Signal.EMG: {\n                        serial.writeValue(\"EMG\", emg());\n                        break;\n                    }\n                    case Signal.ECG: {\n                        serial.writeValue(\"ECG\", ecg());\n                        break;\n                    }\n                    case Signal.EOG: {\n                        serial.writeValue(\"EOG\", eog());\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Set the angle for servo.\n     * @param angle = the angle for servo (in degree)\n     */\n\n    //% group=\"Other\"\n    //% weight=29\n    //% block=\"set servo to $angle degrees\"\n    export function servo_control(angle: number) {\n        pins.servoWritePin(AnalogPin.P8, angle);\n    }\n\n\n    /**\n     * Pause the program from running until user defined time(ms) pass.\n     * If the user provided second argument, pause the program for\n     * randomized time between the first input to second input \n     *(both inclusinve).\n     * @param start = time to pause program. \n     * @param end (optional) = use start and end to as range to pick the random time. The default is 0.\n     */\n\n    //% group=\"Other\"\n    //% weight=28\n    //% block=\"Wait for $start (ms) || $end (ms)\"\n    //% start.shadow=timePicker\n    //% end.shadow=timePicker\n    //% wait.defl=0;\n    export function wait(start: number, end?: number) {\n        let waiting_time = 0;\n\n        // If user provides the second argument, choose random time,\n        // to wait, else set the the first argument.\n        if (end > 0 && end > start) {\n            waiting_time = randint(start, end);\n        }\n        else {\n            waiting_time = start;\n        }\n\n        // Run while loop for some duration\n        const start_time = control.millis();\n        while (control.millis() - start_time < waiting_time) {\n            continue;\n        }\n    }\n\n}\n"],[1,"Developed by Marcio \"Max\" Amorim and Chethan Magnan\n//Filter from Stan Mircic\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    let buffer: number[] = [];\n    control.inBackground(() => {\n        while (true) {\n            buffer.push(pins.analogReadPin(AnalogPin.P0));\n            basic.pause(2); // Need this, otherwise overflow\n        }\n    })\n\n    //% weight=100 block=\"return buffer size\"\n    export function return_size(): number {\n        return buffer.length;\n    }\n\n    // //% weight=50 blockId=\"neurobit_EMG_Filter\" block=\"EMG Filtered\"\n    // export function renvelope(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=49 blockId=\"neurobit_ECG_Filter\" block=\"ECG Filter\"\n    // //display.off()\n    // export function reecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=48 blockId=\"neurobit_EOG\" block=\"EOG\"\n    // //display.off()\n    // export function eog(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=47 blockId=\"neurobit_EMG\" block=\"Raw EMG\"\n    // //display.off()\n    // export function emg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=32 blockId=\"neurobit_ECG\" block=\"Raw ECG\"\n    // //display.off()\n    // export function ecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% subcategory=\"Filters\"\n    // //% blockId=\"lowPassFilter\" block=\"Low Pass Filter of %signal with alpah %alpha range (0-1]\"\n    // //display.off()\n    // export function LowPassFilter(signal: number, alpha: number): number {\n    //     let filteredSignal = 0;\n    //     if (prior == 0) {\n    //         prior = signal;\n    //     }\n    //     filteredSignal = alpha * prior + (1.0 - alpha) * signal;\n    //     prior = filteredSignal;\n    //     return filteredSignal;\n    // }\n\n    // let highPassPriorInput = 0;\n    // let highPassPriorOutput = 0;\n    // let lowPassPriorOutput = 0;\n\n    // // sample rate of 1000 Hz\n    // const sampleRate = 1000;\n\n    // // High-pass filter coefficients (1 Hz cutoff frequency)\n    // const highPassAlpha = 2 * Math.PI * 1 / sampleRate;\n\n    // // Low-pass filter coefficients (100 Hz cutoff frequency)\n    // const lowPassAlpha = 2 * Math.PI * 100 / sampleRate;\n\n    // //% subcategory=\"Filters\"\n    // //% blockId=\"bandPassFilter\" block=\"Band Pass Filter of %signal\"\n    // //display.off()\n    // export function BandPassFilter(signal: number): number {\n    //     // High-pass filter\n    //     let highPassFiltered = highPassAlpha * (highPassPriorOutput + signal - highPassPriorInput);\n    //     highPassPriorInput = signal;\n    //     highPassPriorOutput = highPassFiltered;\n\n    //     // Low-pass filter\n    //     let lowPassFiltered = lowPassAlpha * highPassFiltered + (1 - lowPassAlpha) * lowPassPriorOutput;\n    //     lowPassPriorOutput = lowPassFiltered;\n\n    //     return lowPassFiltered;\n    // }\n}"]],"start1":0,"start2":0,"length1":25727,"length2":2983}]}]},{"timestamp":1726089508323,"editorVersion":"7.0.40","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"it {"],[-1,"\n    /**\n     * Global variable initialization\n     */\n    let apply_envelope = false;"],[0,"\n\n  "]],"start1":270,"start2":270,"length1":94,"length2":8},{"diffs":[[0," }\n\n"],[-1,"    /**\n     * Apply envelope to signal by initializing this block at the top of the code,\n     */\n\n    //% group=\"Other\"\n    //% weight=29\n    //% block=\"Apply envelope to signal\"\n    export function envelope() {\n        apply_envelope = true;\n    }\n\n"],[0,"\n   "]],"start1":24301,"start2":24301,"length1":260,"length2":8},{"diffs":[[0,"weight=2"],[-1,"8"],[1,"9"],[0,"\n    //%"]],"start1":24439,"start2":24439,"length1":17,"length2":17},{"diffs":[[0,"weight=2"],[-1,"7"],[1,"8"],[0,"\n    //%"]],"start1":25026,"start2":25026,"length1":17,"length2":17}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"basic.pause(1000)\nbasic.showNumber(neurobit.return_size())"],[0,"\n"]],"start1":0,"start2":0,"length1":1,"length2":59}]}]},{"timestamp":1726089801859,"editorVersion":"7.0.40","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," Global "],[1,"variable "],[0,"initiali"]],"start1":289,"start2":289,"length1":16,"length2":25},{"diffs":[[0,"lse;"],[-1,"\n    let envelope_buffer: number[] = [];\n    function convolution(new_signal: number) {\n        //Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        if (envelope_buffer.length < window_size) {\n            // Only push the buffer\n            envelope_buffer.push(new_signal);\n\n            return 0;\n        }\n        else {\n            // Update the buffer\n            envelope_buffer.shift()\n            envelope_buffer.push(new_signal)\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            let result = 0.0;\n\n            for (let i = 0; i < window_size; ++i) {\n                result += envelope_buffer[i];\n            }\n\n            return result * kernel;\n        }\n    }"],[0,"\n\n  "]],"start1":356,"start2":356,"length1":837,"length2":8}]}]},{"timestamp":1726090371452,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"    "],[-1,"int ol"],[0,"enve"]],"start1":836,"start2":836,"length1":14,"length2":8}]}]},{"timestamp":1726612422784,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"    "],[-1,"le"],[1,"in"],[0,"t ol"],[-1,"des"],[0,"enve"]],"start1":836,"start2":836,"length1":17,"length2":14}]}]},{"timestamp":1726612426735,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"t {\n"],[-1,"    /**\n     * Background Process\n     */\n\n\n"],[0,"    "]],"start1":271,"start2":271,"length1":52,"length2":8},{"diffs":[[0,"[];\n"],[-1,"    let envelope_sum = 0;\n"],[0,"    "]],"start1":388,"start2":388,"length1":34,"length2":8},{"diffs":[[0,"al);"],[-1,"\n            envelope_sum += new_signal;"],[0,"\n\n  "]],"start1":742,"start2":742,"length1":48,"length2":8},{"diffs":[[0," let old"],[-1,"_signal = "],[1,"es"],[0,"envelope"]],"start1":839,"start2":839,"length1":26,"length2":18},{"diffs":[[0,"e_buffer.shift()"],[-1,";"],[0,"\n            env"]],"start1":856,"start2":856,"length1":33,"length2":32},{"diffs":[[0,"push(new_signal)"],[-1,";"],[0,"\n\n            //"]],"start1":901,"start2":901,"length1":33,"length2":32},{"diffs":[[0,"    "],[-1,"envelope_sum = envelope_sum - old_signal + new_signal;"],[1,"let result = 0.0;\n\n            for (let i = 0; i < window_size; ++i) {\n                result += envelope_buffer[i];\n            }"],[0,"\n\n  "]],"start1":1002,"start2":1002,"length1":62,"length2":138},{"diffs":[[0,"urn "],[-1,"envelope_sum"],[1,"result"],[0," * k"]],"start1":1153,"start2":1153,"length1":20,"length2":14},{"diffs":[[0,"\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":25767,"start2":25767,"length1":22,"length2":16},{"diffs":[[0,"s) pass.\n   "],[-1," //"],[0,"  * If the u"]],"start1":25839,"start2":25839,"length1":27,"length2":24},{"diffs":[[0,"gram for\n   "],[-1," //"],[0,"  * randomiz"]],"start1":25906,"start2":25906,"length1":27,"length2":24},{"diffs":[[0,"put \n   "],[-1," //"],[0,"  *(both"]],"start1":25974,"start2":25974,"length1":19,"length2":16},{"diffs":[[0,"usinve).\n   "],[-1," //"],[0,"  * @param s"]],"start1":25995,"start2":25995,"length1":27,"length2":24},{"diffs":[[0,"am. \n   "],[-1," //"],[0,"  * @par"]],"start1":26045,"start2":26045,"length1":19,"length2":16},{"diffs":[[0,"s 0.\n   "],[-1," //"],[0,"  */\n\n  "]],"start1":26149,"start2":26149,"length1":19,"length2":16},{"diffs":[[0,"     */\n\n   "],[-1," //"],[0," //% group=\""]],"start1":26154,"start2":26154,"length1":27,"length2":24},{"diffs":[[0,"=\"Other\"\n   "],[-1," //"],[0," //% weight="]],"start1":26176,"start2":26176,"length1":27,"length2":24},{"diffs":[[0,"eight=27\n   "],[-1," //"],[0," //% block=\""]],"start1":26194,"start2":26194,"length1":27,"length2":24},{"diffs":[[0,"nd (ms)\"\n   "],[-1," //"],[0," //% start.s"]],"start1":26244,"start2":26244,"length1":27,"length2":24},{"diffs":[[0,"mePicker\n   "],[-1," //"],[0," //% end.sha"]],"start1":26276,"start2":26276,"length1":27,"length2":24},{"diffs":[[0,"cker\n   "],[-1," //"],[0," //% wai"]],"start1":26310,"start2":26310,"length1":19,"length2":16},{"diffs":[[0,"l=0;\n   "],[-1," //"],[0," export "]],"start1":26331,"start2":26331,"length1":19,"length2":16},{"diffs":[[0,"umber) {\n   "],[-1," //"],[0,"     let wai"]],"start1":26383,"start2":26383,"length1":27,"length2":24},{"diffs":[[0,"me = 0;\n\n   "],[-1," //"],[0,"     // If u"]],"start1":26414,"start2":26414,"length1":27,"length2":24},{"diffs":[[0,"om time,\n   "],[-1," //"],[0,"     // to w"]],"start1":26483,"start2":26483,"length1":27,"length2":24},{"diffs":[[0,"rgument.\n   "],[-1," //"],[0,"     if (end"]],"start1":26536,"start2":26536,"length1":27,"length2":24},{"diffs":[[0,"start) {\n   "],[-1," //"],[0,"         wai"]],"start1":26574,"start2":26574,"length1":27,"length2":24},{"diffs":[[0,"t, end);\n   "],[-1," //"],[0,"     }\n    /"]],"start1":26622,"start2":26622,"length1":27,"length2":24},{"diffs":[[0,"       }\n   "],[-1," //"],[0,"     else {\n"]],"start1":26632,"start2":26632,"length1":27,"length2":24},{"diffs":[[0,"e {\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"waiting_"]],"start1":26652,"start2":26652,"length1":27,"length2":24},{"diffs":[[0,"= start;\n   "],[-1," //"],[0,"     }\n\n    "]],"start1":26681,"start2":26681,"length1":27,"length2":24},{"diffs":[[0," }\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"// Run w"]],"start1":26697,"start2":26697,"length1":23,"length2":20},{"diffs":[[0,"duration\n   "],[-1," //"],[0,"     const s"]],"start1":26736,"start2":26736,"length1":27,"length2":24},{"diffs":[[0,"illis();\n   "],[-1," //"],[0,"     while ("]],"start1":26781,"start2":26781,"length1":27,"length2":24},{"diffs":[[0,"_time) {\n   "],[-1," //"],[0,"         con"]],"start1":26844,"start2":26844,"length1":27,"length2":24},{"diffs":[[0,"nue;\n   "],[-1," //"],[0,"     }\n "]],"start1":26870,"start2":26870,"length1":19,"length2":16},{"diffs":[[0,"   }\n   "],[-1," //"],[0," }\n\n}\n"]],"start1":26880,"start2":26880,"length1":17,"length2":14}]}]},{"timestamp":1726612879790,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," */\n"],[-1,"    control.inBackground(function () {\n"],[0,"\n\n  "]],"start1":313,"start2":313,"length1":47,"length2":8}]}]},{"timestamp":1726617155046,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,") {\n"],[-1,"        \n    }\n"],[0,"\n\n  "]],"start1":352,"start2":352,"length1":23,"length2":8}]}]},{"timestamp":1726617156063,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"  * "],[-1,"Global initialization\n     */\n    let neurobit_buffer: number[] = [];\n"],[1,"Background Process\n     */\n    control.inBackground(function () {\n        \n    }\n\n\n    /**\n     * Global initialization\n     */"],[0,"\n   "]],"start1":286,"start2":286,"length1":78,"length2":135},{"diffs":[[0," }\n\n"],[-1,"    /**\n     * Background Process\n     */\n    control.inBackground(function () {\n        let signal = 0;\n        while (true) {\n            signal = pi\n        }\n    })\n\n"],[0,"    "]],"start1":1291,"start2":1291,"length1":178,"length2":8}]}]},{"timestamp":1726617754685,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"    "],[-1,"const fs = 4; //[ms]\n        const time_to_sample"],[1,"let signal"],[0," = "],[-1,"1"],[0,"0;"],[-1," //[s]\n        const neurobit_buffer_size = 1000 / fs * time_to_sample;\n        while (true) {\n            if (neurobit_buffer.length < neurobit_buffer_size) {\n                neurobit_buffer.push(pins.analogReadPin(AnalogPin.P0));\n            }\n"],[1,"\n        while (true) {\n            signal = pi"],[0,"\n   "]],"start1":1323,"start2":1323,"length1":309,"length2":70}]}]},{"timestamp":1726618017868,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," [];"],[-1,"\n    let we"],[0,"\n\n  "]],"start1":355,"start2":355,"length1":19,"length2":8}]}]},{"timestamp":1726619528537,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"et w"],[-1,"rite_index = 0;\n    let read_index = "],[1,"e"],[0,"\n\n  "]],"start1":365,"start2":365,"length1":45,"length2":9}]}]},{"timestamp":1726619536266,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"let "],[-1,"neurobit_buffer_index = 0;"],[1,"write_index = 0;\n    let read_index = "],[0,"\n\n  "]],"start1":364,"start2":364,"length1":34,"length2":46},{"diffs":[[0,"ample = "],[-1,"5"],[1,"10"],[0,"; //[s]\n"]],"start1":1418,"start2":1418,"length1":17,"length2":18},{"diffs":[[0,"    "],[-1,"neurobit_buffer[neurobit_buffer_index] = pins.analogReadPin(AnalogPin.P0);\n            neurobit_buffer_index++;\n            if (neurobit_buffer_index =="],[1,"if (neurobit_buffer.length <"],[0," neu"]],"start1":1532,"start2":1532,"length1":160,"length2":36},{"diffs":[[0,"ffer"],[-1,"_index = 0;\n            }\n            basic.pause(0);"],[1,".push(pins.analogReadPin(AnalogPin.P0));\n            }\n"],[0,"\n   "]],"start1":1616,"start2":1616,"length1":61,"length2":63}]}]},{"timestamp":1726620134993,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"})\n\n"],[-1,"    /**\n     * Return last measurement\n     */\n\n    //% group=\"Signal\"\n    //% weight=102\n    //% block=\"Return last measurement\"\n    export function last_measurement():number {\n        return neurobit_buffer[neurobit_buffer_index];\n    }\n\n\n    /**\n     * Apply envelope to signal by initializing this block at the top of the code,\n     */\n\n    //% group=\"Signal\"\n    //% weight=101\n    //% block=\"Apply envelope to signal\"\n    export function envelope() {\n        apply_envelope = true;\n    }\n\n\n"],[0,"    "]],"start1":1799,"start2":1799,"length1":504,"length2":8},{"diffs":[[0,"G\", "],[-1,"last_measurement"],[1,"emg"],[0,"());"]],"start1":24569,"start2":24569,"length1":24,"length2":11},{"diffs":[[0," }\n\n    "],[1,"/**\n     * Apply envelope to signal by initializing this block at the top of the code,\n     */\n\n    //% group=\"Other\"\n    //% weight=29\n    //% block=\"Apply envelope to signal\"\n    export function envelope() {\n        apply_envelope = true;\n    }\n\n"],[0,"\n    /**"]],"start1":25828,"start2":25828,"length1":16,"length2":264}]}]},{"timestamp":1726620689591,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"(\"EMG\", "],[-1,"last_measurement"],[1,"emg"],[0,"());\n   "]],"start1":25925,"start2":25925,"length1":32,"length2":19}]}]},{"timestamp":1726620800584,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[1,"s"],[0,"://"],[-1,"www.w3.org/1999/xhtml\">\n<block id=\"xRRgvHNlG#rZ^u`HECiY\" type=\"pxt-on-start\">\n"],[1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><block type=\"neurobit_return_size\"></block></value></block></next></block></statement>"],[0,"</block>"],[-1,"\n"],[0,"</xm"]],"start1":12,"start2":12,"length1":98,"length2":408}]}]},{"timestamp":1726691999507,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1726691999661,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"34\" y=\"-2\"><statement name=\"HANDLER\"><block type=\"device_set_digital_pin\"><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P8</field></shadow></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" label=\"Value\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_set_digital_pin\"><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P9</field></shadow></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" label=\"Value\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_while\"><value name=\"COND\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value><statement name=\"DO"],[1,"www.w3.org/1999/xhtml"],[0,"\">"],[1,"\n"],[0,"<block "],[-1,"type=\"serial_writevalue\"><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">signal</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"device_get_analog_pin\"><value name=\"name\"><shadow type=\"analog_read_write_pin_shadow\"><field name=\"pin\">AnalogReadWritePin.P1</field></shadow></value></block></value></block></statement></block></next></block></next></block></statement></block>"],[1,"id=\"xRRgvHNlG#rZ^u`HECiY\" type=\"pxt-on-start\">\n</block>\n"],[0,"</xm"]],"start1":12,"start2":12,"length1":1378,"length2":98}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1726692344237,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"eight=10"],[-1,"4"],[1,"2"],[0,"\n    //%"]],"start1":1883,"start2":1883,"length1":17,"length2":17}]}]},{"timestamp":1726693423714,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"eight=10"],[-1,"3"],[1,"1"],[0,"\n    //%"]],"start1":2176,"start2":2176,"length1":17,"length2":17}]}]},{"timestamp":1726693425581,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"* Re"],[-1,"cord EMG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=105\n    //% block=\"Record EMG in background\"\n    export function set_emg() {\n        pins.digitalWritePin(DigitalPin.P8, 1);\n        pins.digitalWritePin(DigitalPin.P9, 1);\n    }\n\n    /**\n     * Record EKG in background"],[1,"turn last measurement"],[0,"\n   "]],"start1":1816,"start2":1816,"length1":297,"length2":29},{"diffs":[[0,"ion "],[-1,"set_ekg() {\n        pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 1)"],[1,"last_measurement():number {\n        return neurobit_buffer[neurobit_buffer_index]"],[0,";\n  "]],"start1":1949,"start2":1949,"length1":114,"length2":89},{"diffs":[[0,"_index];\n    }\n\n"],[1,"\n"],[0,"    /**\n     * R"]],"start1":2027,"start2":2027,"length1":32,"length2":33},{"diffs":[[0,"  * "],[-1,"Record EEG in background"],[1,"Apply envelope to signal by initializing this block at the top of the code,"],[0,"\n   "]],"start1":2055,"start2":2055,"length1":32,"length2":83},{"diffs":[[0," block=\""],[-1,"Return last measurement"],[1,"Apply envelope to signal"],[0,"\"\n    ex"]],"start1":2193,"start2":2193,"length1":39,"length2":40},{"diffs":[[0,"ion "],[-1,"set_eeg"],[1,"envelope"],[0,"() {"]],"start1":2243,"start2":2243,"length1":15,"length2":16},{"diffs":[[0,"    "],[-1,"pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 0)"],[1,"apply_envelope = true"],[0,";\n  "]],"start1":2264,"start2":2264,"length1":94,"length2":29},{"diffs":[[0," Return "],[-1,"last measurement"],[1,"pin to record EEG"],[0,"\n     */"]],"start1":2313,"start2":2313,"length1":32,"length2":33},{"diffs":[[0,"ght="],[-1,"102"],[1,"50 "],[0,"\n   "]],"start1":2382,"start2":2382,"length1":11,"length2":11},{"diffs":[[0," block=\""],[-1,"Return last measurement"],[1,"EEG"],[0,"\"\n    ex"]],"start1":2397,"start2":2397,"length1":39,"length2":19},{"diffs":[[0,"unction "],[-1,"last_measurement"],[1,"eeg"],[0,"():"],[1," "],[0,"number {"]],"start1":2422,"start2":2422,"length1":35,"length2":23},{"diffs":[[0,"urn "],[-1,"neurobit_buffer[neurobit_buffer_index];\n    }\n\n\n    /**\n     * Apply envelope to signal by initializ"],[1,"pins.analogReadPin(AnalogPin.P0);\n    }\n\n\n    /**\n     * Return p"],[0,"in"],[-1,"g"],[0," t"],[-1,"his block at the top of the code,"],[1,"o record EMG"],[0,"\n   "]],"start1":2457,"start2":2457,"length1":146,"length2":89},{"diffs":[[0,"ght="],[-1,"101"],[1,"49 "],[0,"\n   "]],"start1":2586,"start2":2586,"length1":11,"length2":11},{"diffs":[[0,"ck=\""],[-1,"Apply envelope to signal\"\n    export function envelope() {\n        apply_envelope = true;\n    }\n\n\n\n    export function eeg(): number {"],[1,"EMG\"\n    export function emg(): number {\n        // Check switch here"],[0,"\n   "]],"start1":2605,"start2":2605,"length1":142,"length2":77},{"diffs":[[0," }\n\n"],[1,"\n"],[0,"    "],[-1,"export function emg(): number {\n        // Check switch here\n        return pins.analogReadPin(AnalogPin.P0);\n    }\n\n    export function ecg(): number {\n        return pins.analogReadPin(AnalogPin.P1);\n    }\n"],[1,"/**\n     * Return pin to record ECG\n     */\n\n    //% group=\"Signal\"\n    //% weight=48\n    //% block=\"ECG\"\n    export function ecg(): number {\n        return pins.analogReadPin(AnalogPin.P1);\n    }\n\n    /**\n     * Return pin to record EOG\n     */\n\n    //% group=\"Signal\"\n    //% weight=47\n    //% block=\"EOG\""],[0,"\n   "]],"start1":2731,"start2":2731,"length1":220,"length2":320}]}]},{"timestamp":1726693967973,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"0;\n\n"],[-1,"    let signal_label = \"EEG\"; //Default EEG \n\n"],[0,"    "]],"start1":392,"start2":392,"length1":54,"length2":8},{"diffs":[[0,"      const "],[-1,"rang"],[1,"time_to_sampl"],[0,"e = 5; //[s]"]],"start1":1385,"start2":1385,"length1":28,"length2":37},{"diffs":[[0," / fs * "],[-1,"rang"],[1,"time_to_sampl"],[0,"e;\n     "]],"start1":1464,"start2":1464,"length1":20,"length2":29},{"diffs":[[0,"(AnalogPin.P"],[-1,"1"],[1,"0"],[0,");\n         "]],"start1":1582,"start2":1582,"length1":25,"length2":25},{"diffs":[[0,"1);\n"],[-1,"        signal_label = \"EMG\";\n"],[0,"    "]],"start1":2059,"start2":2059,"length1":38,"length2":8},{"diffs":[[0,"lock=\"Re"],[-1,"cord EKG in background"],[1,"turn last measurement"],[0,"\"\n    ex"]],"start1":2170,"start2":2170,"length1":38,"length2":37},{"diffs":[[0,"1);\n"],[-1,"        signal_label = \"EKG\";\n"],[0,"    "]],"start1":2325,"start2":2325,"length1":38,"length2":8},{"diffs":[[0,"=\"Re"],[-1,"cord ECG in background"],[1,"turn last measurement"],[0,"\"\n  "]],"start1":2440,"start2":2440,"length1":30,"length2":29},{"diffs":[[0,"0);\n"],[-1,"        signal_label = \"EEG\";\n"],[0,"    "]],"start1":2591,"start2":2591,"length1":38,"length2":8},{"diffs":[[0,"emg(): number {\n"],[1,"        // Check switch here\n"],[0,"        return p"]],"start1":3212,"start2":3212,"length1":32,"length2":61},{"diffs":[[0,"n print("],[1,"signal: Signal, "],[0,"duration"]],"start1":24979,"start2":24979,"length1":16,"length2":32},{"diffs":[[0,"   s"],[-1,"erial.writeValue(signal_label, last_measurement());\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                serial.writeValue(signal_label, last_measurement());"],[1,"witch (signal) {\n                    case Signal.EEG: {\n                        serial.writeValue(\"EEG\", eeg());\n                        break;\n                    }\n                    case Signal.EMG: {\n                        serial.writeValue(\"EMG\", last_measurement());\n                        break;\n                    }\n                    case Signal.ECG: {\n                        serial.writeValue(\"ECG\", ecg());\n                        break;\n                    }\n                    case Signal.EOG: {\n                        serial.writeValue(\"EOG\", eog());\n                        break;\n                    }\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                switch (signal) {\n                    case Signal.EEG: {\n                        serial.writeValue(\"EEG\", eeg());\n                        break;\n                    }\n                    case Signal.EMG: {\n                        serial.writeValue(\"EMG\", last_measurement());\n                        break;\n                    }\n                    case Signal.ECG: {\n                        serial.writeValue(\"ECG\", ecg());\n                        break;\n                    }\n                    case Signal.EOG: {\n                        serial.writeValue(\"EOG\", eog());\n                        break;\n                    }\n                }"],[0,"\n   "]],"start1":25168,"start2":25168,"length1":331,"length2":1515}]}]},{"timestamp":1726694534172,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"0;\n\n"],[-1,"    const PIN = AnalogPin.P1;\n\n    /**\n     * Background Process\n     */\n    control.inBackground(function () {\n        const fs = 4; //[ms]\n        const range = 5; //[s]\n        const neurobit_buffer_size = 1000 / fs * range;\n        while (true) {\n            neurobit_buffer[neurobit_buffer_index] = pins.analogReadPin(PIN);\n            neurobit_buffer_index++;\n            if (neurobit_buffer_index == neurobit_buffer_size) {\n                neurobit_buffer_index = 0;\n            }\n            basic.pause(0);\n        }\n    })\n\n"],[0,"    "]],"start1":392,"start2":392,"length1":542,"length2":8},{"diffs":[[0,"lt EEG \n"],[1,""],[0,"\n    let"]],"start1":433,"start2":433,"length1":16,"length2":16},{"diffs":[[0,"       }\n    }\n\n"],[1,"    /**\n     * Background Process\n     */\n    control.inBackground(function () {\n        const fs = 4; //[ms]\n        const range = 5; //[s]\n        const neurobit_buffer_size = 1000 / fs * range;\n        while (true) {\n            neurobit_buffer[neurobit_buffer_index] = pins.analogReadPin(AnalogPin.P1);\n            neurobit_buffer_index++;\n            if (neurobit_buffer_index == neurobit_buffer_size) {\n                neurobit_buffer_index = 0;\n            }\n            basic.pause(0);\n        }\n    })\n\n"],[0,"    /**\n     * R"]],"start1":1303,"start2":1303,"length1":32,"length2":544},{"diffs":[[0," //% block=\""],[-1,"r"],[1,"R"],[0,"ecord EMG in"]],"start1":1925,"start2":1925,"length1":25,"length2":25},{"diffs":[[0," //% block=\""],[-1,"r"],[1,"R"],[0,"ecord EKG in"]],"start1":2222,"start2":2222,"length1":25,"length2":25},{"diffs":[[0," block=\""],[-1,"r"],[1,"R"],[0,"ecord EC"]],"start1":2523,"start2":2523,"length1":17,"length2":17},{"diffs":[[0," block=\""],[-1,"r"],[1,"R"],[0,"eturn la"]],"start1":2820,"start2":2820,"length1":17,"length2":17},{"diffs":[[0," block=\""],[-1,"a"],[1,"A"],[0,"pply env"]],"start1":3113,"start2":3113,"length1":17,"length2":17},{"diffs":[[0,"=\"print "],[1,"$"],[0,"signal |"]],"start1":24916,"start2":24916,"length1":16,"length2":17},{"diffs":[[0,"logPin.P"],[-1,"0"],[1,"8"],[0,", angle)"]],"start1":25875,"start2":25875,"length1":17,"length2":17}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"0"],[1,"34"],[0,"\" y=\""],[-1,"0"],[1,"-2"],[0,"\"><s"]],"start1":104,"start2":104,"length1":15,"length2":17},{"diffs":[[0,"pe=\""],[-1,"neurobit_set_emg\"><next><block type=\"neurobit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">0</field></shadow></value"],[1,"device_set_digital_pin\"><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P8</field></shadow></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" label=\"Value\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_set_digital_pin\"><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P9</field></shadow></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" label=\"Value\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_while\"><value name=\"COND\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value><statement name=\"DO\"><block type=\"serial_writevalue\"><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">signal</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"device_get_analog_pin\"><value name=\"name\"><shadow type=\"analog_read_write_pin_shadow\"><field name=\"pin\">AnalogReadWritePin.P1</field></shadow></value></block></value></block></statement></block></next"],[0,"></b"]],"start1":154,"start2":154,"length1":243,"length2":1192}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"neurobit.set_emg()\nneurobit.print()"],[0,"\n"]],"start1":0,"start2":0,"length1":36,"length2":1}]}]},{"timestamp":1726695137829,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"in.P1;\n\n"],[1,"    /**\n     * Background Process\n     */\n    control.inBackground(function () {\n        const fs = 4; //[ms]\n        const range = 5; //[s]\n        const neurobit_buffer_size = 1000 / fs * range;\n        while (true) {\n            neurobit_buffer[neurobit_buffer_index] = pins.analogReadPin(PIN);\n            neurobit_buffer_index++;\n            if (neurobit_buffer_index == neurobit_buffer_size) {\n                neurobit_buffer_index = 0;\n            }\n            basic.pause(0);\n        }\n    })\n\n"],[0,"    let "]],"start1":419,"start2":419,"length1":16,"length2":519},{"diffs":[[0,"lt EEG \n"],[-1,""],[0,"\n    let"]],"start1":967,"start2":967,"length1":16,"length2":16},{"diffs":[[0," }\n\n"],[-1,"    /**\n     * Background Process\n     */\n    control.inBackground(function () {\n        const fs = 4; //[ms]\n        const range = 5; //[s]\n        const neurobit_buffer_size = 1000 / fs * range;\n        while (true) {\n            neurobit_buffer[neurobit_buffer_index] = pins.analogReadPin(PIN);\n            neurobit_buffer_index++;\n            if (neurobit_buffer_index == neurobit_buffer_size) {\n                neurobit_buffer_index = 0;\n            }\n            basic.pause(0);\n        }\n    })\n\n"],[0,"    "]],"start1":1849,"start2":1849,"length1":511,"length2":8},{"diffs":[[0,"easurement\"\n"],[1,""],[0,"    export f"]],"start1":2863,"start2":2863,"length1":24,"length2":24},{"diffs":[[0,"asurement():"],[-1," "],[0,"number {\n   "]],"start1":2902,"start2":2902,"length1":25,"length2":24},{"diffs":[[0,"       }\n    }\n\n"],[1,"    "],[0,"\n    /**\n     * "]],"start1":25607,"start2":25607,"length1":32,"length2":36}]}]},{"timestamp":1726695355107,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"tension\n"],[-1,"// "],[0,"enum Sig"]],"start1":25,"start2":25,"length1":19,"length2":16},{"diffs":[[0,"ignal {\n"],[-1,"// "],[0,"    EEG,"]],"start1":39,"start2":39,"length1":19,"length2":16},{"diffs":[[0,"EG,\n"],[-1,"//"],[0,"    "],[-1," "],[0,"EMG,\n"],[-1,"// "],[0,"    "]],"start1":52,"start2":52,"length1":23,"length2":17},{"diffs":[[0,"CG,\n"],[-1,"// "],[0,"    EOG\n"],[-1,"// }\n\n// "],[1,"}\n\n"],[0,"enum"]],"start1":70,"start2":70,"length1":28,"length2":19},{"diffs":[[0,"m Cue {\n"],[-1,"// "],[0,"    none"]],"start1":88,"start2":88,"length1":19,"length2":16},{"diffs":[[0,"ne,\n"],[-1,"//"],[0,"    "],[-1," "],[0,"visual,\n"],[-1,"//"],[0,"    "],[-1," "],[0,"audio\n"],[-1,"// }\n\n// "],[1,"}\n\n"],[0,"enum"]],"start1":102,"start2":102,"length1":45,"length2":33},{"diffs":[[0,"ingAt {\n"],[-1,"// "],[0,"    none"]],"start1":140,"start2":140,"length1":19,"length2":16},{"diffs":[[0,"ne,\n"],[-1,"// "],[0,"    up,\n"],[-1,"// "],[0,"    "]],"start1":154,"start2":154,"length1":22,"length2":16},{"diffs":[[0,"ft,\n"],[-1,"//"],[0,"    "],[-1," "],[0,"right,\n"],[-1,"//"],[0,"    "],[-1," "],[0,"down,\n"],[-1,"// "],[0,"    "]],"start1":172,"start2":172,"length1":38,"length2":29},{"diffs":[[0,"  blink\n"],[-1,"// "],[0,"}\n\n//% c"]],"start1":199,"start2":199,"length1":19,"length2":16},{"diffs":[[0,"= 0;\n   "],[-1," //"],[0," functio"]],"start1":566,"start2":566,"length1":19,"length2":16},{"diffs":[[0,"umber) {\n   "],[-1," //"],[0,"     //Initi"]],"start1":609,"start2":609,"length1":27,"length2":24},{"diffs":[[0,"ization\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"const window"]],"start1":635,"start2":635,"length1":31,"length2":28},{"diffs":[[0,"f signal\n   "],[-1," //"],[0,"     const k"]],"start1":717,"start2":717,"length1":27,"length2":24},{"diffs":[[0,"kernel?\n\n   "],[-1," //"],[0,"     if (env"]],"start1":783,"start2":783,"length1":27,"length2":24},{"diffs":[[0,"ndow_size) {\n   "],[-1," //"],[0,"         // Only"]],"start1":831,"start2":831,"length1":35,"length2":32},{"diffs":[[0,"h the buffer\n   "],[-1," //"],[0,"         envelop"]],"start1":867,"start2":867,"length1":35,"length2":32},{"diffs":[[0,"new_signal);\n   "],[-1," //"],[0,"         envelop"]],"start1":913,"start2":913,"length1":35,"length2":32},{"diffs":[[0,"new_signal;\n\n   "],[-1," //"],[0,"         return "]],"start1":954,"start2":954,"length1":35,"length2":32},{"diffs":[[0,"turn 0;\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"}\n   "],[-1," //"],[0,"     else {\n"]],"start1":981,"start2":981,"length1":39,"length2":33},{"diffs":[[0,"      else {\n   "],[-1," //"],[0,"         // Upda"]],"start1":1001,"start2":1001,"length1":35,"length2":32},{"diffs":[[0,"e the buffer\n   "],[-1," //"],[0,"         let old"]],"start1":1034,"start2":1034,"length1":35,"length2":32},{"diffs":[[0,"fer.shift();\n   "],[-1," //"],[0,"         envelop"]],"start1":1088,"start2":1088,"length1":35,"length2":32},{"diffs":[[0,"ew_signal);\n\n   "],[-1," //"],[0,"         // Perf"]],"start1":1135,"start2":1135,"length1":35,"length2":32},{"diffs":[[0,"kernel\")\n   "],[-1," //"],[0,"         env"]],"start1":1214,"start2":1214,"length1":27,"length2":24},{"diffs":[[0,"ignal;\n\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"return envel"]],"start1":1283,"start2":1283,"length1":35,"length2":32},{"diffs":[[0," kernel;\n   "],[-1," //"],[0,"     }\n    /"]],"start1":1324,"start2":1324,"length1":27,"length2":24},{"diffs":[[0,"       }\n   "],[-1," //"],[0," }\n\n    /**\n"]],"start1":1334,"start2":1334,"length1":27,"length2":24},{"diffs":[[0,"        "],[-1,"//"],[0,"return n"]],"start1":2924,"start2":2924,"length1":18,"length2":16},{"diffs":[[0,"x];\n"],[-1,"        return neurobit_buffer_index;\n"],[0,"    "]],"start1":2975,"start2":2975,"length1":46,"length2":8},{"diffs":[[0,"}\n\n\n"],[1,"\n"],[0,"   "],[-1," /**\n     * Choose the signal to print in Serial. \n     * You can also specify the specific time to run the printing. \n     * The default loops.\n     * @param signal = choose electrophysiology\n     * @param duration (optional) = duration(ms) to output the signal. If user does not provide one, then loops\n     */\n\n    //% group=\"Other\"\n    //% weight=30\n    //% block=\"print signal || for $duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                serial.writeValue(signal_label, last_measurement());\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                serial.writeValue(signal_label, last_measurement());\n            }\n        }\n    }\n\n\n\n\n    //"],[0," exp"]],"start1":3238,"start2":3238,"length1":1072,"length2":12},{"diffs":[[0,"(): number {\n   "],[-1," //"],[0,"     return pins"]],"start1":3266,"start2":3266,"length1":35,"length2":32},{"diffs":[[0,"Pin.P0);\n   "],[-1," //"],[0," }\n\n   "],[-1," //"],[0," export func"]],"start1":3319,"start2":3319,"length1":37,"length2":31},{"diffs":[[0,"(): number {\n   "],[-1," //"],[0,"     return pins"]],"start1":3358,"start2":3358,"length1":35,"length2":32},{"diffs":[[0,"Pin.P0);\n   "],[-1," //"],[0," }\n\n   "],[-1," //"],[0," export func"]],"start1":3411,"start2":3411,"length1":37,"length2":31},{"diffs":[[0,"(): number {\n   "],[-1," //"],[0,"     return pins"]],"start1":3450,"start2":3450,"length1":35,"length2":32},{"diffs":[[0,"P1);\n   "],[-1," //"],[0," }\n\n   "],[-1," //"],[0," export "]],"start1":3507,"start2":3507,"length1":29,"length2":23},{"diffs":[[0,"(): number {\n   "],[-1," //"],[0,"     return pins"]],"start1":3542,"start2":3542,"length1":35,"length2":32},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":3603,"start2":3603,"length1":32,"length2":23},{"diffs":[[0,"als(ms).\n   "],[-1," //"],[0,"  * As an op"]],"start1":3676,"start2":3676,"length1":27,"length2":24},{"diffs":[[0,"hreshold\n   "],[-1," //"],[0,"  * to be re"]],"start1":3751,"start2":3751,"length1":27,"length2":24},{"diffs":[[0," 100(%).\n   "],[-1," //"],[0,"  * @param m"]],"start1":3798,"start2":3798,"length1":27,"length2":24},{"diffs":[[0,"heshold.\n   "],[-1," //"],[0,"  * @param p"]],"start1":3874,"start2":3874,"length1":27,"length2":24},{"diffs":[[0,"is 100%.\n   "],[-1," //"],[0,"  */\n\n    //"]],"start1":3980,"start2":3980,"length1":27,"length2":24},{"diffs":[[0,"0%.\n     */\n\n   "],[-1," //"],[0," //% group=\"EMG\""]],"start1":3985,"start2":3985,"length1":35,"length2":32},{"diffs":[[0," group=\"EMG\"\n   "],[-1," //"],[0," //% weight=46\n "]],"start1":4005,"start2":4005,"length1":35,"length2":32},{"diffs":[[0,"eight=46\n   "],[-1," //"],[0," //% block=\""]],"start1":4027,"start2":4027,"length1":27,"length2":24},{"diffs":[[0,"percent\"\n   "],[-1," //"],[0," //% expanda"]],"start1":4105,"start2":4105,"length1":27,"length2":24},{"diffs":[[0,"ode=\"enable\"\n   "],[-1," //"],[0," //% ms.shadow=t"]],"start1":4141,"start2":4141,"length1":35,"length2":32},{"diffs":[[0,"mePicker\n   "],[-1," //"],[0," //% percent"]],"start1":4174,"start2":4174,"length1":27,"length2":24},{"diffs":[[0,"defl=100\n   "],[-1," //"],[0," export func"]],"start1":4199,"start2":4199,"length1":27,"length2":24},{"diffs":[[0,"?: number) {\n   "],[-1," //"],[0,"     const start"]],"start1":4260,"start2":4260,"length1":35,"length2":32},{"diffs":[[0,"ol.millis();\n   "],[-1," //"],[0,"     let val = 0"]],"start1":4305,"start2":4305,"length1":35,"length2":32},{"diffs":[[0,"let val = 0;\n   "],[-1," //"],[0,"     let max_val"]],"start1":4326,"start2":4326,"length1":35,"length2":32},{"diffs":[[0,"al = 0;\n\n   "],[-1," //"],[0,"     while ("]],"start1":4356,"start2":4356,"length1":27,"length2":24},{"diffs":[[0,"imer < ms) {\n   "],[-1," //"],[0,"         val = e"]],"start1":4405,"start2":4405,"length1":35,"length2":32},{"diffs":[[0,"al = emg();\n\n   "],[-1," //"],[0,"         if (max"]],"start1":4431,"start2":4431,"length1":35,"length2":32},{"diffs":[[0,"val < val) {\n   "],[-1," //"],[0,"             max"]],"start1":4464,"start2":4464,"length1":35,"length2":32},{"diffs":[[0,"x_val = val;\n   "],[-1," //"],[0,"         }\n    /"]],"start1":4495,"start2":4495,"length1":35,"length2":32},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"     }\n\n    //  "]],"start1":4509,"start2":4509,"length1":35,"length2":32},{"diffs":[[0,"}\n        }\n\n   "],[-1," //"],[0,"     return max_"]],"start1":4520,"start2":4520,"length1":35,"length2":32},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":4574,"start2":4574,"length1":33,"length2":24},{"diffs":[[0,"ion(ms).\n   "],[-1," //"],[0,"  * You can "]],"start1":4657,"start2":4657,"length1":27,"length2":24},{"diffs":[[0,"econds).\n   "],[-1," //"],[0,"  * If you g"]],"start1":4739,"start2":4739,"length1":27,"length2":24},{"diffs":[[0,"lease), \n   "],[-1," //"],[0,"  * it will "]],"start1":4799,"start2":4799,"length1":27,"length2":24},{"diffs":[[0," as -1. \n   "],[-1," //"],[0,"  * @param m"]],"start1":4829,"start2":4829,"length1":27,"length2":24},{"diffs":[[0,"cording.\n   "],[-1," //"],[0,"  */\n\n    //"]],"start1":4889,"start2":4889,"length1":27,"length2":24},{"diffs":[[0,"ng.\n     */\n\n   "],[-1," //"],[0," //% group=\"EMG\""]],"start1":4894,"start2":4894,"length1":35,"length2":32},{"diffs":[[0," group=\"EMG\"\n   "],[-1," //"],[0," //% weight=45\n "]],"start1":4914,"start2":4914,"length1":35,"length2":32},{"diffs":[[0,"eight=45\n   "],[-1," //"],[0," //% block=\""]],"start1":4936,"start2":4936,"length1":27,"length2":24},{"diffs":[[0," for $ms ms\"\n   "],[-1," //"],[0," //% ms.shadow=t"]],"start1":4972,"start2":4972,"length1":35,"length2":32},{"diffs":[[0,"mePicker\n   "],[-1," //"],[0," //% ms.defl"]],"start1":5005,"start2":5005,"length1":27,"length2":24},{"diffs":[[0,"efl=3000\n   "],[-1," //"],[0," export func"]],"start1":5026,"start2":5026,"length1":27,"length2":24},{"diffs":[[0,"s: number) {\n   "],[-1," //"],[0,"     const down_"]],"start1":5068,"start2":5068,"length1":35,"length2":32},{"diffs":[[0,"s = 200;\n   "],[-1," //"],[0,"     const p"]],"start1":5108,"start2":5108,"length1":27,"length2":24},{"diffs":[[0,"_sample_fs;\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"let elapsed_time"]],"start1":5154,"start2":5154,"length1":39,"length2":36},{"diffs":[[0,"ed_time = 0;\n   "],[-1," //"],[0,"     let elapsed"]],"start1":5183,"start2":5183,"length1":35,"length2":32},{"diffs":[[0,"_time2 = 0;\n\n   "],[-1," //"],[0,"     const buffe"]],"start1":5215,"start2":5215,"length1":35,"length2":32},{"diffs":[[0,"ze = 20;\n   "],[-1," //"],[0,"     let buf"]],"start1":5251,"start2":5251,"length1":27,"length2":24},{"diffs":[[0,"] = [];\n\n   "],[-1," //"],[0,"     // Smoo"]],"start1":5287,"start2":5287,"length1":27,"length2":24},{"diffs":[[0," signal\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"function mov"]],"start1":5329,"start2":5329,"length1":31,"length2":28},{"diffs":[[0,"r): number {\n   "],[-1," //"],[0,"         let sum"]],"start1":5401,"start2":5401,"length1":35,"length2":32},{"diffs":[[0,"m = 0.0;\n   "],[-1," //"],[0,"         let"]],"start1":5432,"start2":5432,"length1":27,"length2":24},{"diffs":[[0,"hedData = 0;\n   "],[-1," //"],[0,"         //overf"]],"start1":5462,"start2":5462,"length1":35,"length2":32},{"diffs":[[0,"ng point\n   "],[-1," //"],[0,"         for"]],"start1":5507,"start2":5507,"length1":27,"length2":24},{"diffs":[[0,"ize; j++) {\n    "],[-1,"//"],[0,"             sum"]],"start1":5555,"start2":5555,"length1":34,"length2":32},{"diffs":[[0,"        "],[-1," "],[0,"sum += d"]],"start1":5575,"start2":5575,"length1":17,"length2":16},{"diffs":[[0,"data[j];\n   "],[-1," //"],[0,"         }\n "]],"start1":5590,"start2":5590,"length1":27,"length2":24},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"         smoothe"]],"start1":5600,"start2":5600,"length1":35,"length2":32},{"diffs":[[0," windowSize;\n   "],[-1," //"],[0,"         return "]],"start1":5645,"start2":5645,"length1":35,"length2":32},{"diffs":[[0,"hedData;\n   "],[-1," //"],[0,"     }\n\n    "]],"start1":5682,"start2":5682,"length1":27,"length2":24},{"diffs":[[0,"     }\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"const thresh"]],"start1":5694,"start2":5694,"length1":31,"length2":28},{"diffs":[[0,"d = 150;\n   "],[-1," //"],[0,"     const i"]],"start1":5724,"start2":5724,"length1":27,"length2":24},{"diffs":[[0,"l = 500;\n   "],[-1," //"],[0,"     let sig"]],"start1":5754,"start2":5754,"length1":27,"length2":24},{"diffs":[[0," signal = 0;\n   "],[-1," //"],[0,"     let smooth_"]],"start1":5774,"start2":5774,"length1":35,"length2":32},{"diffs":[[0,"_signal = 0;\n   "],[-1," //"],[0,"     let counter"]],"start1":5805,"start2":5805,"length1":35,"length2":32},{"diffs":[[0,"er = 0;\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"let checking"]],"start1":5835,"start2":5835,"length1":31,"length2":28},{"diffs":[[0,"= false;\n   "],[-1," //"],[0,"     let che"]],"start1":5864,"start2":5864,"length1":27,"length2":24},{"diffs":[[0,"nterval;\n   "],[-1," //"],[0,"     let che"]],"start1":5900,"start2":5900,"length1":27,"length2":24},{"diffs":[[0,"ip = false;\n\n   "],[-1," //"],[0,"     const start"]],"start1":5929,"start2":5929,"length1":35,"length2":32},{"diffs":[[0,"ol.millis();\n   "],[-1," //"],[0,"     let sample_"]],"start1":5974,"start2":5974,"length1":35,"length2":32},{"diffs":[[0,"eMicros();\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"// Begin Timer\n "]],"start1":6029,"start2":6029,"length1":39,"length2":36},{"diffs":[[0,"in Timer\n   "],[-1," //"],[0,"     while ("]],"start1":6055,"start2":6055,"length1":27,"length2":24},{"diffs":[[0,"imer < ms) {\n   "],[-1," //"],[0,"         signal "]],"start1":6104,"start2":6104,"length1":35,"length2":32},{"diffs":[[0,"al = emg();\n\n   "],[-1," //"],[0,"         // Fill"]],"start1":6133,"start2":6133,"length1":35,"length2":32},{"diffs":[[0,"main process\n   "],[-1," //"],[0,"         if (buf"]],"start1":6188,"start2":6188,"length1":35,"length2":32},{"diffs":[[0,"ffer_size) {\n   "],[-1," //"],[0,"             buf"]],"start1":6235,"start2":6235,"length1":35,"length2":32},{"diffs":[[0,"ush(signal);\n   "],[-1," //"],[0,"         }\n\n    "]],"start1":6272,"start2":6272,"length1":35,"length2":32},{"diffs":[[0," }\n\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"// Once "]],"start1":6296,"start2":6296,"length1":27,"length2":24},{"diffs":[[0,"ls up, shift\n   "],[-1," //"],[0,"         if (buf"]],"start1":6334,"start2":6334,"length1":35,"length2":32},{"diffs":[[0,"ffer_size) {\n   "],[-1," //"],[0,"             buf"]],"start1":6382,"start2":6382,"length1":35,"length2":32},{"diffs":[[0,"fer.shift();\n   "],[-1," //"],[0,"             buf"]],"start1":6414,"start2":6414,"length1":35,"length2":32},{"diffs":[[0,"h(signal);\n\n    "],[-1,"//"],[0,"             // "]],"start1":6453,"start2":6453,"length1":34,"length2":32},{"diffs":[[0,"            "],[-1," "],[0,"// Smooth ou"]],"start1":6469,"start2":6469,"length1":25,"length2":24},{"diffs":[[0," signal\n    "],[-1,"//"],[0,"            "]],"start1":6498,"start2":6498,"length1":26,"length2":24},{"diffs":[[0,"                "],[-1," "],[0,"smooth_signal = "]],"start1":6506,"start2":6506,"length1":33,"length2":32},{"diffs":[[0,"er.length);\n\n   "],[-1," //"],[0,"             // "]],"start1":6564,"start2":6564,"length1":35,"length2":32},{"diffs":[[0,"ve threshold\n   "],[-1," //"],[0,"             let"]],"start1":6616,"start2":6616,"length1":35,"length2":32},{"diffs":[[0,"imeMicros();\n   "],[-1," //"],[0,"             whi"]],"start1":6678,"start2":6678,"length1":35,"length2":32},{"diffs":[[0,"threshold) {\n   "],[-1," //"],[0,"                "]],"start1":6730,"start2":6730,"length1":35,"length2":32},{"diffs":[[0,"l = emg();\n\n    "],[-1,"//"],[0,"                "]],"start1":6768,"start2":6768,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"buffer.shift();\n"]],"start1":6784,"start2":6784,"length1":33,"length2":32},{"diffs":[[0,"fer.shift();\n   "],[-1," //"],[0,"                "]],"start1":6803,"start2":6803,"length1":35,"length2":32},{"diffs":[[0,"sh(signal);\n\n   "],[-1," //"],[0,"                "]],"start1":6845,"start2":6845,"length1":35,"length2":32},{"diffs":[[0,"ength);\n\n   "],[-1," //"],[0,"            "]],"start1":6924,"start2":6924,"length1":27,"length2":24},{"diffs":[[0,"cking) {\n   "],[-1," //"],[0,"            "]],"start1":6961,"start2":6961,"length1":27,"length2":24},{"diffs":[[0,"etected\n    "],[-1,"//"],[0,"            "]],"start1":7032,"start2":7032,"length1":26,"length2":24},{"diffs":[[0,"        "],[-1," "],[0,"// for o"]],"start1":7056,"start2":7056,"length1":17,"length2":16},{"diffs":[[0,"e rising\n   "],[-1," //"],[0,"            "]],"start1":7107,"start2":7107,"length1":27,"length2":24},{"diffs":[[0,"ol.millis();\n   "],[-1," //"],[0,"                "]],"start1":7158,"start2":7158,"length1":35,"length2":32},{"diffs":[[0,"king = true;\n   "],[-1," //"],[0,"                "]],"start1":7199,"start2":7199,"length1":35,"length2":32},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"                "]],"start1":7222,"start2":7222,"length1":35,"length2":32},{"diffs":[[0,"ng for grip\n    "],[-1,"//"],[0,"                "]],"start1":7264,"start2":7264,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"check_grip = tru"]],"start1":7280,"start2":7280,"length1":33,"length2":32},{"diffs":[[0,"= true;\n\n   "],[-1," //"],[0,"            "]],"start1":7307,"start2":7307,"length1":27,"length2":24},{"diffs":[[0,"_time2;\n\n   "],[-1," //"],[0,"            "]],"start1":7386,"start2":7386,"length1":27,"length2":24},{"diffs":[[0," < period) {\n   "],[-1," //"],[0,"                "]],"start1":7432,"start2":7432,"length1":35,"length2":32},{"diffs":[[0,"_time2);\n   "],[-1," //"],[0,"            "]],"start1":7504,"start2":7504,"length1":27,"length2":24},{"diffs":[[0,"         }\n\n    "],[-1,"//"],[0,"                "]],"start1":7524,"start2":7524,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"sample_time2 = i"]],"start1":7540,"start2":7540,"length1":33,"length2":32},{"diffs":[[0,"imeMicros();\n   "],[-1," //"],[0,"             }\n\n"]],"start1":7585,"start2":7585,"length1":35,"length2":32},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"             // "]],"start1":7604,"start2":7604,"length1":35,"length2":32},{"diffs":[[0,", allow \n   "],[-1," //"],[0,"            "]],"start1":7677,"start2":7677,"length1":27,"length2":24},{"diffs":[[0,"o happen\n   "],[-1," //"],[0,"            "]],"start1":7724,"start2":7724,"length1":27,"length2":24},{"diffs":[[0,"g = false;\n\n    "],[-1,"//"],[0,"             // "]],"start1":7756,"start2":7756,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"// Check if the "]],"start1":7768,"start2":7768,"length1":33,"length2":32},{"diffs":[[0,"l window\n   "],[-1," //"],[0,"            "]],"start1":7827,"start2":7827,"length1":27,"length2":24},{"diffs":[[0,"ositives\n   "],[-1," //"],[0,"            "]],"start1":7872,"start2":7872,"length1":27,"length2":24},{"diffs":[[0," interval) {\n   "],[-1," //"],[0,"                "]],"start1":7932,"start2":7932,"length1":35,"length2":32},{"diffs":[[0,"rip = false;\n   "],[-1," //"],[0,"                "]],"start1":7972,"start2":7972,"length1":35,"length2":32},{"diffs":[[0," spikes\n    "],[-1,"//"],[0,"            "]],"start1":8049,"start2":8049,"length1":26,"length2":24},{"diffs":[[0,"                "],[-1," "],[0,"check_time = -in"]],"start1":8061,"start2":8061,"length1":33,"length2":32},{"diffs":[[0,"eck time\n   "],[-1," //"],[0,"            "]],"start1":8112,"start2":8112,"length1":27,"length2":24},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"             // "]],"start1":8127,"start2":8127,"length1":35,"length2":32},{"diffs":[[0,"e due to\n   "],[-1," //"],[0,"            "]],"start1":8200,"start2":8200,"length1":27,"length2":24},{"diffs":[[0,"the grip\n   "],[-1," //"],[0,"            "]],"start1":8228,"start2":8228,"length1":27,"length2":24},{"diffs":[[0,"heck_grip) {\n   "],[-1," //"],[0,"                "]],"start1":8258,"start2":8258,"length1":35,"length2":32},{"diffs":[[0,"er = -1;\n   "],[-1," //"],[0,"            "]],"start1":8296,"start2":8296,"length1":27,"length2":24},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         }\n\n    "]],"start1":8311,"start2":8311,"length1":35,"length2":32},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         // Samp"]],"start1":8326,"start2":8326,"length1":35,"length2":32},{"diffs":[[0,"caluculation\n   "],[-1," //"],[0,"         elapsed"]],"start1":8368,"start2":8368,"length1":35,"length2":32},{"diffs":[[0,"ample_time;\n\n   "],[-1," //"],[0,"         if (ela"]],"start1":8437,"start2":8437,"length1":35,"length2":32},{"diffs":[[0," < period) {\n   "],[-1," //"],[0,"             con"]],"start1":8478,"start2":8478,"length1":35,"length2":32},{"diffs":[[0,"apsed_time);\n   "],[-1," //"],[0,"         }\n\n    "]],"start1":8537,"start2":8537,"length1":35,"length2":32},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         sample_"]],"start1":8552,"start2":8552,"length1":35,"length2":32},{"diffs":[[0,"imeMicros();\n   "],[-1," //"],[0,"     }\n\n    //  "]],"start1":8605,"start2":8605,"length1":35,"length2":32},{"diffs":[[0,";\n        }\n\n   "],[-1," //"],[0,"     return coun"]],"start1":8616,"start2":8616,"length1":35,"length2":32},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":8678,"start2":8678,"length1":33,"length2":24},{"diffs":[[0,"tions to\n   "],[-1," //"],[0,"  * choose e"]],"start1":8755,"start2":8755,"length1":27,"length2":24},{"diffs":[[0,"eat) cue\n   "],[-1," //"],[0,"  * with giv"]],"start1":8825,"start2":8825,"length1":27,"length2":24},{"diffs":[[0,"eshold. \n   "],[-1," //"],[0,"  * @param c"]],"start1":8855,"start2":8855,"length1":27,"length2":24},{"diffs":[[0,"is none.\n   "],[-1," //"],[0,"  * @param t"]],"start1":8970,"start2":8970,"length1":27,"length2":24},{"diffs":[[0," is 200.\n   "],[-1," //"],[0,"  */\n\n    //"]],"start1":9079,"start2":9079,"length1":27,"length2":24},{"diffs":[[0,"00.\n     */\n\n   "],[-1," //"],[0," //% group=\"EMG\""]],"start1":9084,"start2":9084,"length1":35,"length2":32},{"diffs":[[0,"up=\"EMG\"\n   "],[-1," //"],[0," //% weight="]],"start1":9108,"start2":9108,"length1":27,"length2":24},{"diffs":[[0,"eight=44\n   "],[-1," //"],[0," //% block=\""]],"start1":9126,"start2":9126,"length1":27,"length2":24},{"diffs":[[0,"reshold\"\n   "],[-1," //"],[0," //% expanda"]],"start1":9204,"start2":9204,"length1":27,"length2":24},{"diffs":[[0,"\"enable\"\n   "],[-1," //"],[0," //% thresho"]],"start1":9244,"start2":9244,"length1":27,"length2":24},{"diffs":[[0,"defl=200\n   "],[-1," //"],[0," //% inlineI"]],"start1":9271,"start2":9271,"length1":27,"length2":24},{"diffs":[[0,"e=inline\n   "],[-1," //"],[0," export func"]],"start1":9302,"start2":9302,"length1":27,"length2":24},{"diffs":[[0,"?: number) {\n   "],[-1," //"],[0,"     const cue_t"]],"start1":9364,"start2":9364,"length1":35,"length2":32},{"diffs":[[0," // [ms]\n   "],[-1," //"],[0,"     const m"]],"start1":9406,"start2":9406,"length1":27,"length2":24},{"diffs":[[0,"reaction\n   "],[-1," //"],[0,"     let sig"]],"start1":9473,"start2":9473,"length1":27,"length2":24},{"diffs":[[0," signal = 0;\n   "],[-1," //"],[0,"     let result "]],"start1":9493,"start2":9493,"length1":35,"length2":32},{"diffs":[[0,"lt = ms;\n   "],[-1," //"],[0,"     let onc"]],"start1":9522,"start2":9522,"length1":27,"length2":24},{"diffs":[[0,"= true;\n\n   "],[-1," //"],[0,"     //At be"]],"start1":9548,"start2":9548,"length1":27,"length2":24},{"diffs":[[0,"f needed\n   "],[-1," //"],[0,"     switch "]],"start1":9598,"start2":9598,"length1":27,"length2":24},{"diffs":[[0,"itch (cue) {\n   "],[-1," //"],[0,"         case Cu"]],"start1":9617,"start2":9617,"length1":35,"length2":32},{"diffs":[[0,".none: {\n   "],[-1," //"],[0,"            "]],"start1":9650,"start2":9650,"length1":27,"length2":24},{"diffs":[[0,"      break;\n   "],[-1," //"],[0,"         }\n    /"]],"start1":9669,"start2":9669,"length1":35,"length2":32},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"         case Cu"]],"start1":9683,"start2":9683,"length1":35,"length2":32},{"diffs":[[0,"e.visual: {\n    "],[-1,"//"],[0,"             bas"]],"start1":9715,"start2":9715,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"basic.showIcon(I"]],"start1":9727,"start2":9727,"length1":33,"length2":32},{"diffs":[[0,", cue_time);\n   "],[-1," //"],[0,"             bas"]],"start1":9773,"start2":9773,"length1":35,"length2":32},{"diffs":[[0,"earScreen();\n   "],[-1," //"],[0,"             bre"]],"start1":9810,"start2":9810,"length1":35,"length2":32},{"diffs":[[0,"      break;\n   "],[-1," //"],[0,"         }\n    /"]],"start1":9833,"start2":9833,"length1":35,"length2":32},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"         case Cu"]],"start1":9847,"start2":9847,"length1":35,"length2":32},{"diffs":[[0,"udio: {\n    "],[-1,"//"],[0,"            "]],"start1":9882,"start2":9882,"length1":26,"length2":24},{"diffs":[[0,"            "],[-1," "],[0,"pins.setAudi"]],"start1":9894,"start2":9894,"length1":25,"length2":24},{"diffs":[[0,"in.P16);\n   "],[-1," //"],[0,"            "]],"start1":9930,"start2":9930,"length1":27,"length2":24},{"diffs":[[0,"e_time),\n   "],[-1," //"],[0,"            "]],"start1":9992,"start2":9992,"length1":27,"length2":24},{"diffs":[[0,"ground);\n   "],[-1," //"],[0,"            "]],"start1":10046,"start2":10046,"length1":27,"length2":24},{"diffs":[[0,"  break;\n   "],[-1," //"],[0,"         }\n "]],"start1":10069,"start2":10069,"length1":27,"length2":24},{"diffs":[[0,"  }\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"}\n\n   "],[-1," //"],[0,"     con"]],"start1":10088,"start2":10088,"length1":32,"length2":26},{"diffs":[[0,"l.millis();\n\n   "],[-1," //"],[0,"     // Begin me"]],"start1":10135,"start2":10135,"length1":35,"length2":32},{"diffs":[[0,"ion time\n   "],[-1," //"],[0,"     while ("]],"start1":10184,"start2":10184,"length1":27,"length2":24},{"diffs":[[0,"Time < ms) {\n   "],[-1," //"],[0,"         signal "]],"start1":10232,"start2":10232,"length1":35,"length2":32},{"diffs":[[0,"();\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"// (only"]],"start1":10269,"start2":10269,"length1":27,"length2":24},{"diffs":[[0,"reshold,\n   "],[-1," //"],[0,"         // "]],"start1":10329,"start2":10329,"length1":27,"length2":24},{"diffs":[[0,"n time. \n   "],[-1," //"],[0,"         if "]],"start1":10369,"start2":10369,"length1":27,"length2":24},{"diffs":[[0,"d && once) {\n   "],[-1," //"],[0,"             res"]],"start1":10411,"start2":10411,"length1":35,"length2":32},{"diffs":[[0,"artTime;\n   "],[-1," //"],[0,"            "]],"start1":10470,"start2":10470,"length1":27,"length2":24},{"diffs":[[0,"    "],[-1,"//"],[0,"        "],[-1," "],[0,"}\n   "],[-1," //"],[0,"    "]],"start1":10509,"start2":10509,"length1":27,"length2":21},{"diffs":[[0,"}\n        }\n\n   "],[-1," //"],[0,"     // If user "]],"start1":10521,"start2":10521,"length1":35,"length2":32},{"diffs":[[0,"on mark)\n   "],[-1," //"],[0,"     if (res"]],"start1":10596,"start2":10596,"length1":27,"length2":24},{"diffs":[[0,"ult == ms) {\n   "],[-1," //"],[0,"         return "]],"start1":10620,"start2":10620,"length1":35,"length2":32},{"diffs":[[0,"efined;\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"}\n   "],[-1," //"],[0,"     else {\n"]],"start1":10655,"start2":10655,"length1":39,"length2":33},{"diffs":[[0,"      else {\n   "],[-1," //"],[0,"         return "]],"start1":10675,"start2":10675,"length1":35,"length2":32},{"diffs":[[0," result;\n   "],[-1," //"],[0,"     }\n    /"]],"start1":10706,"start2":10706,"length1":27,"length2":24},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":10724,"start2":10724,"length1":33,"length2":24},{"diffs":[[0,"efault).\n   "],[-1," //"],[0,"  * You can "]],"start1":10798,"start2":10798,"length1":27,"length2":24},{"diffs":[[0,"ng from \n   "],[-1," //"],[0,"  * optional"]],"start1":10854,"start2":10854,"length1":27,"length2":24},{"diffs":[[0,"rgument.\n   "],[-1," //"],[0,"  * @param m"]],"start1":10880,"start2":10880,"length1":27,"length2":24},{"diffs":[[0," 5 seconds).\n   "],[-1," //"],[0,"  */\n\n    // //%"]],"start1":10988,"start2":10988,"length1":35,"length2":32},{"diffs":[[0,"s).\n     */\n\n   "],[-1," //"],[0," //% group=\"ECG\""]],"start1":10997,"start2":10997,"length1":35,"length2":32},{"diffs":[[0,"up=\"ECG\"\n   "],[-1," //"],[0," //% weight="]],"start1":11021,"start2":11021,"length1":27,"length2":24},{"diffs":[[0,"eight=43\n   "],[-1," //"],[0," //% block=\""]],"start1":11039,"start2":11039,"length1":27,"length2":24},{"diffs":[[0," for $ms ms\"\n   "],[-1," //"],[0," //% ms.shadow=t"]],"start1":11089,"start2":11089,"length1":35,"length2":32},{"diffs":[[0,"w=timePicker\n   "],[-1," //"],[0," //% expandableA"]],"start1":11118,"start2":11118,"length1":35,"length2":32},{"diffs":[[0,"ode=\"enable\"\n   "],[-1," //"],[0," //% ms.defl=500"]],"start1":11158,"start2":11158,"length1":35,"length2":32},{"diffs":[[0,"efl=5000\n   "],[-1," //"],[0," export func"]],"start1":11183,"start2":11183,"length1":27,"length2":24},{"diffs":[[0,"umber) {\n   "],[-1," //"],[0,"     const d"]],"start1":11227,"start2":11227,"length1":27,"length2":24},{"diffs":[[0,"50 //Hz;\n   "],[-1," //"],[0,"     const p"]],"start1":11268,"start2":11268,"length1":27,"length2":24},{"diffs":[[0,"mple_fs;\n   "],[-1," //"],[0,"     let ela"]],"start1":11317,"start2":11317,"length1":27,"length2":24},{"diffs":[[0,"me = 0\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"const range "]],"start1":11348,"start2":11348,"length1":31,"length2":28},{"diffs":[[0," = 300;\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"const buffer"]],"start1":11375,"start2":11375,"length1":31,"length2":28},{"diffs":[[0,"ize = 6;\n   "],[-1," //"],[0,"     let buf"]],"start1":11405,"start2":11405,"length1":27,"length2":24},{"diffs":[[0,"[] = [];\n   "],[-1," //"],[0,"     // let "]],"start1":11440,"start2":11440,"length1":27,"length2":24},{"diffs":[[0,"r_index = 0;\n   "],[-1," //"],[0,"     let beat_nu"]],"start1":11469,"start2":11469,"length1":35,"length2":32},{"diffs":[[0,"um = 0;\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"let unit = 0"]],"start1":11500,"start2":11500,"length1":31,"length2":28},{"diffs":[[0,"it = 0;\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"let sum_unit"]],"start1":11522,"start2":11522,"length1":31,"length2":28},{"diffs":[[0,"um_unit = 0;\n   "],[-1," //"],[0,"     let wait = "]],"start1":11543,"start2":11543,"length1":35,"length2":32},{"diffs":[[0,"et wait = 0;\n   "],[-1," //"],[0,"     let last_be"]],"start1":11565,"start2":11565,"length1":35,"length2":32},{"diffs":[[0,"t = 0;\n\n\n   "],[-1," //"],[0,"     // Fill"]],"start1":11598,"start2":11598,"length1":27,"length2":24},{"diffs":[[0,"er first\n   "],[-1," //"],[0,"     for (le"]],"start1":11631,"start2":11631,"length1":27,"length2":24},{"diffs":[[0," i++) {\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"buffer.push("]],"start1":11680,"start2":11680,"length1":35,"length2":32},{"diffs":[[0,"(ecg());\n   "],[-1," //"],[0,"     }\n\n    "]],"start1":11711,"start2":11711,"length1":27,"length2":24},{"diffs":[[0,";\n        }\n\n   "],[-1," //"],[0,"     const start"]],"start1":11718,"start2":11718,"length1":35,"length2":32},{"diffs":[[0,"ol.millis();\n   "],[-1," //"],[0,"     let prev_be"]],"start1":11762,"start2":11762,"length1":35,"length2":32},{"diffs":[[0,"ol.millis();\n   "],[-1," //"],[0,"     let sample_"]],"start1":11804,"start2":11804,"length1":35,"length2":32},{"diffs":[[0,"eMicros();\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"// Keep running "]],"start1":11859,"start2":11859,"length1":39,"length2":36},{"diffs":[[0,"ime runs out\n   "],[-1," //"],[0,"     while (cont"]],"start1":11902,"start2":11902,"length1":35,"length2":32},{"diffs":[[0," < ms) {\n   "],[-1," //"],[0,"         if "]],"start1":11958,"start2":11958,"length1":27,"length2":24},{"diffs":[[0,"<= 0) {\n\n   "],[-1," //"],[0,"            "]],"start1":11988,"start2":11988,"length1":27,"length2":24},{"diffs":[[0," calculation\n   "],[-1," //"],[0,"             let"]],"start1":12039,"start2":12039,"length1":35,"length2":32},{"diffs":[[0," buffer[0];\n    "],[-1,"//"],[0,"             let"]],"start1":12084,"start2":12084,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"let buffer_max ="]],"start1":12096,"start2":12096,"length1":33,"length2":32},{"diffs":[[0,"fer[0];\n\n   "],[-1," //"],[0,"            "]],"start1":12132,"start2":12132,"length1":27,"length2":24},{"diffs":[[0,"size; i++) {\n   "],[-1," //"],[0,"                "]],"start1":12184,"start2":12184,"length1":35,"length2":32},{"diffs":[[0,"buffer[i]) {\n   "],[-1," //"],[0,"                "]],"start1":12234,"start2":12234,"length1":35,"length2":32},{"diffs":[[0,"= buffer[i];\n   "],[-1," //"],[0,"                "]],"start1":12282,"start2":12282,"length1":35,"length2":32},{"diffs":[[0,"         }\n\n    "],[-1,"//"],[0,"                "]],"start1":12306,"start2":12306,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"if (buffer_max <"]],"start1":12322,"start2":12322,"length1":33,"length2":32},{"diffs":[[0,"buffer[i]) {\n   "],[-1," //"],[0,"                "]],"start1":12355,"start2":12355,"length1":35,"length2":32},{"diffs":[[0,"ffer[i];\n   "],[-1," //"],[0,"            "]],"start1":12407,"start2":12407,"length1":27,"length2":24},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"             }\n\n"]],"start1":12425,"start2":12425,"length1":35,"length2":32},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"             // "]],"start1":12444,"start2":12444,"length1":35,"length2":32},{"diffs":[[0," range,\n    "],[-1,"//"],[0,"            "]],"start1":12522,"start2":12522,"length1":26,"length2":24},{"diffs":[[0,"            "],[-1," "],[0,"// do heartb"]],"start1":12534,"start2":12534,"length1":25,"length2":24},{"diffs":[[0,"caluculation\n   "],[-1," //"],[0,"             if "]],"start1":12562,"start2":12562,"length1":35,"length2":32},{"diffs":[[0,"n > range) {\n   "],[-1," //"],[0,"                "]],"start1":12617,"start2":12617,"length1":35,"length2":32},{"diffs":[[0,"t, 150);\n   "],[-1," //"],[0,"            "]],"start1":12679,"start2":12679,"length1":27,"length2":24},{"diffs":[[0,"creen();\n   "],[-1," //"],[0,"            "]],"start1":12720,"start2":12720,"length1":27,"length2":24},{"diffs":[[0,"ev_beat;\n   "],[-1," //"],[0,"            "]],"start1":12782,"start2":12782,"length1":27,"length2":24},{"diffs":[[0,"ol.millis();\n   "],[-1," //"],[0,"                "]],"start1":12828,"start2":12828,"length1":35,"length2":32},{"diffs":[[0," / 200);\n   "],[-1," //"],[0,"            "]],"start1":12896,"start2":12896,"length1":27,"length2":24},{"diffs":[[0,") / 40);\n   "],[-1," //"],[0,"            "]],"start1":12978,"start2":12978,"length1":27,"length2":24},{"diffs":[[0,"mallBox;\n   "],[-1," //"],[0,"            "]],"start1":13036,"start2":13036,"length1":27,"length2":24},{"diffs":[[0,"+= unit;\n   "],[-1," //"],[0,"            "]],"start1":13074,"start2":13074,"length1":27,"length2":24},{"diffs":[[0,"t_num++;\n   "],[-1," //"],[0,"            "]],"start1":13106,"start2":13106,"length1":27,"length2":24},{"diffs":[[0,"ze * 3. \n   "],[-1," //"],[0,"            "]],"start1":13156,"start2":13156,"length1":27,"length2":24},{"diffs":[[0," between\n   "],[-1," //"],[0,"            "]],"start1":13221,"start2":13221,"length1":27,"length2":24},{"diffs":[[0,"time for\n   "],[-1," //"],[0,"            "]],"start1":13289,"start2":13289,"length1":27,"length2":24},{"diffs":[[0," samples\n   "],[-1," //"],[0,"            "]],"start1":13336,"start2":13336,"length1":27,"length2":24},{"diffs":[[0,"ize * 3;\n   "],[-1," //"],[0,"            "]],"start1":13380,"start2":13380,"length1":27,"length2":24},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"         }\n\n\n   "]],"start1":13394,"start2":13394,"length1":35,"length2":32},{"diffs":[[0,"     }\n\n\n   "],[-1," //"],[0,"         // "]],"start1":13414,"start2":13414,"length1":27,"length2":24},{"diffs":[[0,"se shift\n   "],[-1," //"],[0,"         buf"]],"start1":13451,"start2":13451,"length1":27,"length2":24},{"diffs":[[0,"fer.shift();\n   "],[-1," //"],[0,"         buffer."]],"start1":13475,"start2":13475,"length1":35,"length2":32},{"diffs":[[0,"push(ecg());\n   "],[-1," //"],[0,"         // buff"]],"start1":13507,"start2":13507,"length1":35,"length2":32},{"diffs":[[0,"] = val;\n   "],[-1," //"],[0,"         // "]],"start1":13554,"start2":13554,"length1":27,"length2":24},{"diffs":[[0,"er_size;\n   "],[-1," //"],[0,"         wai"]],"start1":13618,"start2":13618,"length1":27,"length2":24},{"diffs":[[0,"wait--;\n\n   "],[-1," //"],[0,"         // "]],"start1":13639,"start2":13639,"length1":27,"length2":24},{"diffs":[[0,"caluculation\n   "],[-1," //"],[0,"         elapsed"]],"start1":13677,"start2":13677,"length1":35,"length2":32},{"diffs":[[0,"ample_time;\n\n   "],[-1," //"],[0,"         if (ela"]],"start1":13746,"start2":13746,"length1":35,"length2":32},{"diffs":[[0," < period) {\n   "],[-1," //"],[0,"             con"]],"start1":13787,"start2":13787,"length1":35,"length2":32},{"diffs":[[0,"ed_time)\n   "],[-1," //"],[0,"         }\n\n"]],"start1":13849,"start2":13849,"length1":27,"length2":24},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         sample_"]],"start1":13860,"start2":13860,"length1":35,"length2":32},{"diffs":[[0,"Micros()\n   "],[-1," //"],[0,"     }\n\n    "]],"start1":13916,"start2":13916,"length1":27,"length2":24},{"diffs":[[0,")\n        }\n\n   "],[-1," //"],[0,"     // Check to"]],"start1":13923,"start2":13923,"length1":35,"length2":32},{"diffs":[[0," by zero\n   "],[-1," //"],[0,"     return "]],"start1":13970,"start2":13970,"length1":27,"length2":24},{"diffs":[[0,"defined;\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," let current"]],"start1":14041,"start2":14041,"length1":38,"length2":32},{"diffs":[[0,"_up = false;\n   "],[-1," //"],[0," let currently_d"]],"start1":14075,"start2":14075,"length1":35,"length2":32},{"diffs":[[0,"own = false;\n   "],[-1," //"],[0," let center_UD ="]],"start1":14107,"start2":14107,"length1":35,"length2":32},{"diffs":[[0,"= false;\n   "],[-1," //"],[0," let cooldow"]],"start1":14138,"start2":14138,"length1":27,"length2":24},{"diffs":[[0,"ter = 0;\n   "],[-1," //"],[0," let blink_b"]],"start1":14168,"start2":14168,"length1":27,"length2":24},{"diffs":[[0,"[] = [];\n   "],[-1," //"],[0," let updown_"]],"start1":14205,"start2":14205,"length1":27,"length2":24},{"diffs":[[0,"] = [];\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * Return e"]],"start1":14244,"start2":14244,"length1":38,"length2":32},{"diffs":[[0," eyes in\n   "],[-1," //"],[0,"  * vertical"]],"start1":14315,"start2":14315,"length1":27,"length2":24},{"diffs":[[0,"l direction.\n   "],[-1," //"],[0,"  */\n\n    // //%"]],"start1":14338,"start2":14338,"length1":35,"length2":32},{"diffs":[[0,"on.\n     */\n\n   "],[-1," //"],[0," //% group=\"EOG\""]],"start1":14347,"start2":14347,"length1":35,"length2":32},{"diffs":[[0," group=\"EOG\"\n   "],[-1," //"],[0," //% weight=42\n "]],"start1":14367,"start2":14367,"length1":35,"length2":32},{"diffs":[[0,"eight=42\n   "],[-1," //"],[0," //% block=\""]],"start1":14389,"start2":14389,"length1":27,"length2":24},{"diffs":[[0,"tion (VEOG)\"\n   "],[-1," //"],[0," export function"]],"start1":14418,"start2":14418,"length1":35,"length2":32},{"diffs":[[0,"(): number {\n   "],[-1," //"],[0,"     const time "]],"start1":14456,"start2":14456,"length1":35,"length2":32},{"diffs":[[0,"00; // [ms]\n\n   "],[-1," //"],[0,"     const down_"]],"start1":14491,"start2":14491,"length1":35,"length2":32},{"diffs":[[0," 50; // [Hz]\n   "],[-1," //"],[0,"     const perio"]],"start1":14534,"start2":14534,"length1":35,"length2":32},{"diffs":[[0,"; // [μs/hz]\n   "],[-1," //"],[0,"     let elapsed"]],"start1":14594,"start2":14594,"length1":35,"length2":32},{"diffs":[[0,"_time = 0;\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"let result = Loo"]],"start1":14626,"start2":14626,"length1":39,"length2":36},{"diffs":[[0,"ingAt.none;\n\n   "],[-1," //"],[0,"     const basel"]],"start1":14663,"start2":14663,"length1":35,"length2":32},{"diffs":[[0,"line = 450;\n\n   "],[-1," //"],[0,"     const buffe"]],"start1":14694,"start2":14694,"length1":35,"length2":32},{"diffs":[[0,"ze = 10;\n   "],[-1," //"],[0,"     const w"]],"start1":14730,"start2":14730,"length1":27,"length2":24},{"diffs":[[0,"f second\n   "],[-1," //"],[0,"     let avg"]],"start1":14805,"start2":14805,"length1":27,"length2":24},{"diffs":[[0,"r = 0;\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"let slope = "]],"start1":14834,"start2":14834,"length1":31,"length2":28},{"diffs":[[0,"ope = 0;\n   "],[-1," //"],[0,"     const c"]],"start1":14856,"start2":14856,"length1":27,"length2":24},{"diffs":[[0,"r_size;\n\n   "],[-1," //"],[0,"     // Func"]],"start1":14914,"start2":14914,"length1":27,"length2":24},{"diffs":[[0,"f buffer\n   "],[-1," //"],[0,"     functio"]],"start1":14971,"start2":14971,"length1":27,"length2":24},{"diffs":[[0,"number {\n   "],[-1," //"],[0,"         con"]],"start1":15029,"start2":15029,"length1":27,"length2":24},{"diffs":[[0,"length;\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"let xSum = 0"]],"start1":15065,"start2":15065,"length1":35,"length2":32},{"diffs":[[0,"et xSum = 0;\n   "],[-1," //"],[0,"         let ySu"]],"start1":15086,"start2":15086,"length1":35,"length2":32},{"diffs":[[0,"et ySum = 0;\n   "],[-1," //"],[0,"         let xyS"]],"start1":15112,"start2":15112,"length1":35,"length2":32},{"diffs":[[0,"t xySum = 0;\n   "],[-1," //"],[0,"         let xSq"]],"start1":15139,"start2":15139,"length1":35,"length2":32},{"diffs":[[0,"um = 0;\n\n   "],[-1," //"],[0,"         for"]],"start1":15177,"start2":15177,"length1":27,"length2":24},{"diffs":[[0,"< n; x++) {\n    "],[-1,"//"],[0,"             xSu"]],"start1":15216,"start2":15216,"length1":34,"length2":32},{"diffs":[[0,"        "],[-1," "],[0,"xSum += "]],"start1":15236,"start2":15236,"length1":17,"length2":16},{"diffs":[[0,"um += x;\n   "],[-1," //"],[0,"            "]],"start1":15246,"start2":15246,"length1":27,"length2":24},{"diffs":[[0," += data[x];\n   "],[-1," //"],[0,"             xyS"]],"start1":15275,"start2":15275,"length1":35,"length2":32},{"diffs":[[0,"data[x];\n   "],[-1," //"],[0,"            "]],"start1":15317,"start2":15317,"length1":27,"length2":24},{"diffs":[[0,"= x * x;\n   "],[-1," //"],[0,"         }\n\n"]],"start1":15355,"start2":15355,"length1":27,"length2":24},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         return "]],"start1":15366,"start2":15366,"length1":35,"length2":32},{"diffs":[[0,"* xSum);\n   "],[-1," //"],[0,"     }\n\n    "]],"start1":15450,"start2":15450,"length1":27,"length2":24},{"diffs":[[0,"      }\n\n   "],[-1," //"],[0,"     const s"]],"start1":15461,"start2":15461,"length1":27,"length2":24},{"diffs":[[0,"ol.millis();\n   "],[-1," //"],[0,"     let sample_"]],"start1":15502,"start2":15502,"length1":35,"length2":32},{"diffs":[[0,"meMicros();\n\n   "],[-1," //"],[0,"     // Keep run"]],"start1":15556,"start2":15556,"length1":35,"length2":32},{"diffs":[[0,"me runs out\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"while (control.m"]],"start1":15601,"start2":15601,"length1":39,"length2":36},{"diffs":[[0,"me < time) {\n   "],[-1," //"],[0,"         let sig"]],"start1":15655,"start2":15655,"length1":35,"length2":32},{"diffs":[[0,"al = eog();\n\n   "],[-1," //"],[0,"         // Shif"]],"start1":15688,"start2":15688,"length1":35,"length2":32},{"diffs":[[0,"ler than\n   "],[-1," //"],[0,"         // "]],"start1":15763,"start2":15763,"length1":27,"length2":24},{"diffs":[[0,"analysis\n   "],[-1," //"],[0,"         if "]],"start1":15798,"start2":15798,"length1":27,"length2":24},{"diffs":[[0,"ait_size) {\n    "],[-1,"//"],[0,"             bli"]],"start1":15846,"start2":15846,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"blink_buffer.pus"]],"start1":15858,"start2":15858,"length1":33,"length2":32},{"diffs":[[0,"ush(signal);\n   "],[-1," //"],[0,"         } else "]],"start1":15888,"start2":15888,"length1":35,"length2":32},{"diffs":[[0,"    } else {\n   "],[-1," //"],[0,"             if "]],"start1":15909,"start2":15909,"length1":35,"length2":32},{"diffs":[[0,"ffer_size) {\n   "],[-1," //"],[0,"                "]],"start1":15967,"start2":15967,"length1":35,"length2":32},{"diffs":[[0,"er.shift());\n   "],[-1," //"],[0,"             } e"]],"start1":16029,"start2":16029,"length1":35,"length2":32},{"diffs":[[0,"   } else {\n    "],[-1,"//"],[0,"                "]],"start1":16055,"start2":16055,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"updown_buffer.sh"]],"start1":16071,"start2":16071,"length1":33,"length2":32},{"diffs":[[0,"fer.shift();\n   "],[-1," //"],[0,"                "]],"start1":16097,"start2":16097,"length1":35,"length2":32},{"diffs":[[0,"hift());\n   "],[-1," //"],[0,"            "]],"start1":16163,"start2":16163,"length1":27,"length2":24},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"             bli"]],"start1":16178,"start2":16178,"length1":35,"length2":32},{"diffs":[[0,"ush(signal);\n   "],[-1," //"],[0,"         }\n\n    "]],"start1":16221,"start2":16221,"length1":35,"length2":32},{"diffs":[[0,"     }\n\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"if (updown_b"]],"start1":16241,"start2":16241,"length1":35,"length2":32},{"diffs":[[0,"ffer_size) {\n   "],[-1," //"],[0,"             slo"]],"start1":16291,"start2":16291,"length1":35,"length2":32},{"diffs":[[0,"_size));\n   "],[-1," //"],[0,"            "]],"start1":16371,"start2":16371,"length1":27,"length2":24},{"diffs":[[0,"uffer_size;\n\n   "],[-1," //"],[0,"             // "]],"start1":16452,"start2":16452,"length1":35,"length2":32},{"diffs":[[0,"Blinking\n   "],[-1," //"],[0,"            "]],"start1":16484,"start2":16484,"length1":27,"length2":24},{"diffs":[[0,"pe < -75) {\n    "],[-1,"//"],[0,"                "]],"start1":16516,"start2":16516,"length1":34,"length2":32},{"diffs":[[0,"            "],[-1," "],[0,"// Begin coo"]],"start1":16536,"start2":16536,"length1":25,"length2":24},{"diffs":[[0,"ool down\n   "],[-1," //"],[0,"            "]],"start1":16558,"start2":16558,"length1":27,"length2":24},{"diffs":[[0,"ter = 0;\n   "],[-1," //"],[0,"            "]],"start1":16600,"start2":16600,"length1":27,"length2":24},{"diffs":[[0,"t.blink;\n   "],[-1," //"],[0,"            "]],"start1":16646,"start2":16646,"length1":27,"length2":24},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"             // "]],"start1":16661,"start2":16661,"length1":35,"length2":32},{"diffs":[[0,"s happening\n    "],[-1,"//"],[0,"             if "]],"start1":16706,"start2":16706,"length1":34,"length2":32},{"diffs":[[0,"            "],[-1," "],[0,"if (cooldown"]],"start1":16722,"start2":16722,"length1":25,"length2":24},{"diffs":[[0,"wn_period) {\n   "],[-1," //"],[0,"                "]],"start1":16764,"start2":16764,"length1":35,"length2":32},{"diffs":[[0,"oking Up\n   "],[-1," //"],[0,"            "]],"start1":16802,"start2":16802,"length1":27,"length2":24},{"diffs":[[0,"ne * 1.40) {\n   "],[-1," //"],[0,"                "]],"start1":16853,"start2":16853,"length1":35,"length2":32},{"diffs":[[0,"_down) {\n   "],[-1," //"],[0,"            "]],"start1":16903,"start2":16903,"length1":27,"length2":24},{"diffs":[[0,"_UD = true;\n    "],[-1,"//"],[0,"                "]],"start1":16946,"start2":16946,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"} else {\n    // "]],"start1":16966,"start2":16966,"length1":33,"length2":32},{"diffs":[[0,"    } else {\n   "],[-1," //"],[0,"                "]],"start1":16978,"start2":16978,"length1":35,"length2":32},{"diffs":[[0,"ngAt.up;\n   "],[-1," //"],[0,"            "]],"start1":17033,"start2":17033,"length1":27,"length2":24},{"diffs":[[0,"_UD = false;\n   "],[-1," //"],[0,"                "]],"start1":17076,"start2":17076,"length1":35,"length2":32},{"diffs":[[0,"y_up = true;\n   "],[-1," //"],[0,"                "]],"start1":17125,"start2":17125,"length1":35,"length2":32},{"diffs":[[0,"          }\n    "],[-1,"//"],[0,"                "]],"start1":17152,"start2":17152,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"// Looking Down "]],"start1":17172,"start2":17172,"length1":33,"length2":32},{"diffs":[[0,"ng Down \n   "],[-1," //"],[0,"            "]],"start1":17196,"start2":17196,"length1":27,"length2":24},{"diffs":[[0," 0.60) {\n   "],[-1," //"],[0,"            "]],"start1":17258,"start2":17258,"length1":27,"length2":24},{"diffs":[[0,"ly_up) {\n   "],[-1," //"],[0,"            "]],"start1":17302,"start2":17302,"length1":27,"length2":24},{"diffs":[[0,"r_UD = true;\n   "],[-1," //"],[0,"                "]],"start1":17344,"start2":17344,"length1":35,"length2":32},{"diffs":[[0,"   } else {\n    "],[-1,"//"],[0,"                "]],"start1":17378,"start2":17378,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"result = Looking"]],"start1":17402,"start2":17402,"length1":33,"length2":32},{"diffs":[[0,"At.down;\n   "],[-1," //"],[0,"            "]],"start1":17434,"start2":17434,"length1":27,"length2":24},{"diffs":[[0,"_UD = false;\n   "],[-1," //"],[0,"                "]],"start1":17477,"start2":17477,"length1":35,"length2":32},{"diffs":[[0,"down = true;\n   "],[-1," //"],[0,"                "]],"start1":17528,"start2":17528,"length1":35,"length2":32},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"                "]],"start1":17554,"start2":17554,"length1":35,"length2":32},{"diffs":[[0,"    } else {\n   "],[-1," //"],[0,"                "]],"start1":17583,"start2":17583,"length1":35,"length2":32},{"diffs":[[0,"er_UD) {\n   "],[-1," //"],[0,"            "]],"start1":17628,"start2":17628,"length1":27,"length2":24},{"diffs":[[0,"up = false;\n    "],[-1,"//"],[0,"                "]],"start1":17675,"start2":17675,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"currently_down ="]],"start1":17699,"start2":17699,"length1":33,"length2":32},{"diffs":[[0,"own = false;\n   "],[-1," //"],[0,"                "]],"start1":17726,"start2":17726,"length1":35,"length2":32},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"                "]],"start1":17752,"start2":17752,"length1":35,"length2":32},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"             } e"]],"start1":17774,"start2":17774,"length1":35,"length2":32},{"diffs":[[0,"    } else {\n   "],[-1," //"],[0,"                "]],"start1":17799,"start2":17799,"length1":35,"length2":32},{"diffs":[[0,"nter++;\n    "],[-1,"//"],[0,"            "]],"start1":17844,"start2":17844,"length1":26,"length2":24},{"diffs":[[0,"            "],[-1," "],[0,"}\n   "],[-1," //"],[0,"         }\n\n"]],"start1":17856,"start2":17856,"length1":33,"length2":29},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         // Samp"]],"start1":17872,"start2":17872,"length1":35,"length2":32},{"diffs":[[0,"caluculation\n   "],[-1," //"],[0,"         elapsed"]],"start1":17914,"start2":17914,"length1":35,"length2":32},{"diffs":[[0,"ample_time;\n\n   "],[-1," //"],[0,"         if (ela"]],"start1":17983,"start2":17983,"length1":35,"length2":32},{"diffs":[[0,"< period) {\n    "],[-1,"//"],[0,"             con"]],"start1":18025,"start2":18025,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"control.waitMicr"]],"start1":18037,"start2":18037,"length1":33,"length2":32},{"diffs":[[0,"apsed_time);\n   "],[-1," //"],[0,"         }\n\n    "]],"start1":18083,"start2":18083,"length1":35,"length2":32},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         sample_"]],"start1":18098,"start2":18098,"length1":35,"length2":32},{"diffs":[[0,"imeMicros();\n   "],[-1," //"],[0,"     }\n\n    //  "]],"start1":18151,"start2":18151,"length1":35,"length2":32},{"diffs":[[0,";\n        }\n\n   "],[-1," //"],[0,"     return resu"]],"start1":18162,"start2":18162,"length1":35,"length2":32},{"diffs":[[0,"lt;\n\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," let cur"]],"start1":18194,"start2":18194,"length1":30,"length2":24},{"diffs":[[0,"= false;\n   "],[-1," //"],[0," let current"]],"start1":18230,"start2":18230,"length1":27,"length2":24},{"diffs":[[0,"= false;\n   "],[-1," //"],[0," let center_"]],"start1":18263,"start2":18263,"length1":27,"length2":24},{"diffs":[[0,"lse;\n   "],[-1," //"],[0," let lef"]],"start1":18294,"start2":18294,"length1":19,"length2":16},{"diffs":[[0,"] = [];\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * Return e"]],"start1":18332,"start2":18332,"length1":38,"length2":32},{"diffs":[[0," eyes in\n   "],[-1," //"],[0,"  * horizont"]],"start1":18400,"start2":18400,"length1":27,"length2":24},{"diffs":[[0,"rection.\n   "],[-1," //"],[0,"  */\n\n    //"]],"start1":18429,"start2":18429,"length1":27,"length2":24},{"diffs":[[0,"on.\n     */\n\n   "],[-1," //"],[0," //% group=\"EOG\""]],"start1":18434,"start2":18434,"length1":35,"length2":32},{"diffs":[[0," group=\"EOG\"\n   "],[-1," //"],[0," //% weight=41\n "]],"start1":18454,"start2":18454,"length1":35,"length2":32},{"diffs":[[0,"eight=41\n   "],[-1," //"],[0," //% block=\""]],"start1":18476,"start2":18476,"length1":27,"length2":24},{"diffs":[[0," (HEOG)\"\n   "],[-1," //"],[0," export func"]],"start1":18509,"start2":18509,"length1":27,"length2":24},{"diffs":[[0,"number {\n   "],[-1," //"],[0,"     const t"]],"start1":18547,"start2":18547,"length1":27,"length2":24},{"diffs":[[0,"// [ms]\n\n   "],[-1," //"],[0,"     const d"]],"start1":18582,"start2":18582,"length1":27,"length2":24},{"diffs":[[0," 50 // [Hz]\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"const period = 1"]],"start1":18621,"start2":18621,"length1":39,"length2":36},{"diffs":[[0,"s // [μs/hz]\n   "],[-1," //"],[0,"     let elapsed"]],"start1":18679,"start2":18679,"length1":35,"length2":32},{"diffs":[[0,"me = 0;\n\n   "],[-1," //"],[0,"     let res"]],"start1":18714,"start2":18714,"length1":27,"length2":24},{"diffs":[[0,"t.none;\n\n   "],[-1," //"],[0,"     const b"]],"start1":18752,"start2":18752,"length1":27,"length2":24},{"diffs":[[0,"ine = 450;\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"const buffer_siz"]],"start1":18780,"start2":18780,"length1":39,"length2":36},{"diffs":[[0,"e = 10;\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"let avgBuffe"]],"start1":18816,"start2":18816,"length1":31,"length2":28},{"diffs":[[0,"Buffer = 0;\n\n   "],[-1," //"],[0,"     const start"]],"start1":18839,"start2":18839,"length1":35,"length2":32},{"diffs":[[0,"ol.millis();\n   "],[-1," //"],[0,"     let sample_"]],"start1":18884,"start2":18884,"length1":35,"length2":32},{"diffs":[[0,"meMicros();\n\n   "],[-1," //"],[0,"     // Keep run"]],"start1":18938,"start2":18938,"length1":35,"length2":32},{"diffs":[[0,"runs out\n   "],[-1," //"],[0,"     while ("]],"start1":18986,"start2":18986,"length1":27,"length2":24},{"diffs":[[0,"me < time) {\n   "],[-1," //"],[0,"         let sig"]],"start1":19037,"start2":19037,"length1":35,"length2":32},{"diffs":[[0,"al = eog();\n\n   "],[-1," //"],[0,"         // If t"]],"start1":19070,"start2":19070,"length1":35,"length2":32},{"diffs":[[0," keep adding\n   "],[-1," //"],[0,"         if (lef"]],"start1":19128,"start2":19128,"length1":35,"length2":32},{"diffs":[[0,"ffer_size) {\n   "],[-1," //"],[0,"             lef"]],"start1":19185,"start2":19185,"length1":35,"length2":32},{"diffs":[[0,"ush(signal);\n   "],[-1," //"],[0,"         }\n\n    "]],"start1":19232,"start2":19232,"length1":35,"length2":32},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         // If t"]],"start1":19247,"start2":19247,"length1":35,"length2":32},{"diffs":[[0,"process\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"if (leftrigh"]],"start1":19309,"start2":19309,"length1":35,"length2":32},{"diffs":[[0,"ffer_size) {\n   "],[-1," //"],[0,"             lef"]],"start1":19362,"start2":19362,"length1":35,"length2":32},{"diffs":[[0,"fer.shift();\n   "],[-1," //"],[0,"             lef"]],"start1":19404,"start2":19404,"length1":35,"length2":32},{"diffs":[[0,"sh(signal);\n\n   "],[-1," //"],[0,"             // "]],"start1":19452,"start2":19452,"length1":35,"length2":32},{"diffs":[[0,"f buffer\n   "],[-1," //"],[0,"            "]],"start1":19503,"start2":19503,"length1":27,"length2":24},{"diffs":[[0,"r_size;\n\n   "],[-1," //"],[0,"            "]],"start1":19591,"start2":19591,"length1":27,"length2":24},{"diffs":[[0,"ing Left\n   "],[-1," //"],[0,"            "]],"start1":19623,"start2":19623,"length1":27,"length2":24},{"diffs":[[0,"ne * 1.25) {\n   "],[-1," //"],[0,"                "]],"start1":19670,"start2":19670,"length1":35,"length2":32},{"diffs":[[0,"tly_right) {\n   "],[-1," //"],[0,"                "]],"start1":19713,"start2":19713,"length1":35,"length2":32},{"diffs":[[0,"r_LR = true;\n   "],[-1," //"],[0,"                "]],"start1":19755,"start2":19755,"length1":35,"length2":32},{"diffs":[[0,"          }\n    "],[-1,"//"],[0,"                "]],"start1":19778,"start2":19778,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"else {\n    //   "]],"start1":19794,"start2":19794,"length1":33,"length2":32},{"diffs":[[0,"      else {\n   "],[-1," //"],[0,"                "]],"start1":19804,"start2":19804,"length1":35,"length2":32},{"diffs":[[0,"_LR = false;\n   "],[-1," //"],[0,"                "]],"start1":19847,"start2":19847,"length1":35,"length2":32},{"diffs":[[0,"left = true;\n   "],[-1," //"],[0,"                "]],"start1":19894,"start2":19894,"length1":35,"length2":32},{"diffs":[[0,"At.left;\n   "],[-1," //"],[0,"            "]],"start1":19947,"start2":19947,"length1":27,"length2":24},{"diffs":[[0,"          }\n    "],[-1,"//"],[0,"             }\n "]],"start1":19966,"start2":19966,"length1":34,"length2":32},{"diffs":[[0,"            "],[-1," "],[0,"}\n   "],[-1," //"],[0,"            "]],"start1":19982,"start2":19982,"length1":33,"length2":29},{"diffs":[[0,"ng Right\n   "],[-1," //"],[0,"            "]],"start1":20020,"start2":20020,"length1":27,"length2":24},{"diffs":[[0," 0.75) {\n   "],[-1," //"],[0,"            "]],"start1":20076,"start2":20076,"length1":27,"length2":24},{"diffs":[[0,"ntly_left) {\n   "],[-1," //"],[0,"                "]],"start1":20114,"start2":20114,"length1":35,"length2":32},{"diffs":[[0,"r_LR = true;\n   "],[-1," //"],[0,"                "]],"start1":20156,"start2":20156,"length1":35,"length2":32},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"                "]],"start1":20178,"start2":20178,"length1":35,"length2":32},{"diffs":[[0,"      else {\n   "],[-1," //"],[0,"                "]],"start1":20205,"start2":20205,"length1":35,"length2":32},{"diffs":[[0,"_LR = false;\n   "],[-1," //"],[0,"                "]],"start1":20248,"start2":20248,"length1":35,"length2":32},{"diffs":[[0,"ight = true;\n   "],[-1," //"],[0,"                "]],"start1":20296,"start2":20296,"length1":35,"length2":32},{"diffs":[[0,"t.right;\n   "],[-1," //"],[0,"            "]],"start1":20350,"start2":20350,"length1":27,"length2":24},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"             }\n "]],"start1":20368,"start2":20368,"length1":35,"length2":32},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"             els"]],"start1":20386,"start2":20386,"length1":35,"length2":32},{"diffs":[[0,"      else {\n   "],[-1," //"],[0,"                "]],"start1":20409,"start2":20409,"length1":35,"length2":32},{"diffs":[[0,"er_LR) {\n   "],[-1," //"],[0,"            "]],"start1":20450,"start2":20450,"length1":27,"length2":24},{"diffs":[[0,"ft = false;\n    "],[-1,"//"],[0,"                "]],"start1":20495,"start2":20495,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"currently_right "]],"start1":20515,"start2":20515,"length1":33,"length2":32},{"diffs":[[0,"ht = false;\n    "],[-1,"//"],[0,"                "]],"start1":20544,"start2":20544,"length1":34,"length2":32},{"diffs":[[0,"            "],[-1," "],[0,"}\n   "],[-1," //"],[0,"            "]],"start1":20564,"start2":20564,"length1":33,"length2":29},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"         }\n\n    "]],"start1":20583,"start2":20583,"length1":35,"length2":32},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         // Samp"]],"start1":20598,"start2":20598,"length1":35,"length2":32},{"diffs":[[0,"caluculation\n   "],[-1," //"],[0,"         elapsed"]],"start1":20640,"start2":20640,"length1":35,"length2":32},{"diffs":[[0,"_time;\n\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"if (elapsed_"]],"start1":20714,"start2":20714,"length1":35,"length2":32},{"diffs":[[0," < period) {\n   "],[-1," //"],[0,"             con"]],"start1":20750,"start2":20750,"length1":35,"length2":32},{"diffs":[[0,"apsed_time);\n   "],[-1," //"],[0,"         }\n\n    "]],"start1":20809,"start2":20809,"length1":35,"length2":32},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         sample_"]],"start1":20824,"start2":20824,"length1":35,"length2":32},{"diffs":[[0,"imeMicros();\n   "],[-1," //"],[0,"     }\n\n    //  "]],"start1":20877,"start2":20877,"length1":35,"length2":32},{"diffs":[[0,"     }\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"return resul"]],"start1":20893,"start2":20893,"length1":31,"length2":28},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":20924,"start2":20924,"length1":33,"length2":24},{"diffs":[[0,"herwise.\n   "],[-1," //"],[0,"  * Defining"]],"start1":21001,"start2":21001,"length1":27,"length2":24},{"diffs":[[0,"econd). \n   "],[-1," //"],[0,"  * @param m"]],"start1":21073,"start2":21073,"length1":27,"length2":24},{"diffs":[[0,"econds).\n   "],[-1," //"],[0,"  */\n\n    //"]],"start1":21169,"start2":21169,"length1":27,"length2":24},{"diffs":[[0,"s).\n     */\n\n   "],[-1," //"],[0," //% group=\"EOG\""]],"start1":21174,"start2":21174,"length1":35,"length2":32},{"diffs":[[0," group=\"EOG\"\n   "],[-1," //"],[0," //% weight=40\n "]],"start1":21194,"start2":21194,"length1":35,"length2":32},{"diffs":[[0,"eight=40\n   "],[-1," //"],[0," //% block=\""]],"start1":21216,"start2":21216,"length1":27,"length2":24},{"diffs":[[0," $ms ms\"\n   "],[-1," //"],[0," //% ms.shad"]],"start1":21256,"start2":21256,"length1":27,"length2":24},{"diffs":[[0,"mePicker\n   "],[-1," //"],[0," //% expanda"]],"start1":21285,"start2":21285,"length1":27,"length2":24},{"diffs":[[0,"\"enable\"\n   "],[-1," //"],[0," //% ms.defl"]],"start1":21325,"start2":21325,"length1":27,"length2":24},{"diffs":[[0,"efl=1000\n   "],[-1," //"],[0," export func"]],"start1":21346,"start2":21346,"length1":27,"length2":24},{"diffs":[[0,"oolean {\n   "],[-1," //"],[0,"     const d"]],"start1":21397,"start2":21397,"length1":27,"length2":24},{"diffs":[[0," //[Hz]\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"const period"]],"start1":21439,"start2":21439,"length1":31,"length2":28},{"diffs":[[0,"/[μs/hz]\n   "],[-1," //"],[0,"     let ela"]],"start1":21496,"start2":21496,"length1":27,"length2":24},{"diffs":[[0,"me = 0;\n\n   "],[-1," //"],[0,"     const b"]],"start1":21527,"start2":21527,"length1":27,"length2":24},{"diffs":[[0,"ize = 2;\n   "],[-1," //"],[0,"     let buf"]],"start1":21558,"start2":21558,"length1":27,"length2":24},{"diffs":[[0,"r = [];\n\n   "],[-1," //"],[0,"     const t"]],"start1":21584,"start2":21584,"length1":27,"length2":24},{"diffs":[[0,"d = 40;\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"const blink_"]],"start1":21615,"start2":21615,"length1":31,"length2":28},{"diffs":[[0," //[ms]\n\n   "],[-1," //"],[0,"     let bli"]],"start1":21654,"start2":21654,"length1":27,"length2":24},{"diffs":[[0,"k_timer = 0;\n   "],[-1," //"],[0,"     let start_v"]],"start1":21685,"start2":21685,"length1":35,"length2":32},{"diffs":[[0,"val = 0;\n   "],[-1," //"],[0,"     let cur"]],"start1":21716,"start2":21716,"length1":27,"length2":24},{"diffs":[[0," false;\n\n   "],[-1," //"],[0,"     let exi"]],"start1":21757,"start2":21757,"length1":27,"length2":24},{"diffs":[[0,"false;\n\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"const start_"]],"start1":21785,"start2":21785,"length1":31,"length2":28},{"diffs":[[0,"illis();\n   "],[-1," //"],[0,"     let sam"]],"start1":21829,"start2":21829,"length1":27,"length2":24},{"diffs":[[0,"cros();\n\n   "],[-1," //"],[0,"     // Keep"]],"start1":21883,"start2":21883,"length1":27,"length2":24},{"diffs":[[0,"g until \n   "],[-1," //"],[0,"     // 1). "]],"start1":21918,"start2":21918,"length1":27,"length2":24},{"diffs":[[0,"runs out\n   "],[-1," //"],[0,"     // 2). "]],"start1":21947,"start2":21947,"length1":27,"length2":24},{"diffs":[[0," blinked\n   "],[-1," //"],[0,"     while ("]],"start1":21975,"start2":21975,"length1":27,"length2":24},{"diffs":[[0," && !exit) {\n   "],[-1," //"],[0,"         let sig"]],"start1":22033,"start2":22033,"length1":35,"length2":32},{"diffs":[[0,"eog();\n\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"// If the bu"]],"start1":22071,"start2":22071,"length1":35,"length2":32},{"diffs":[[0,"p adding\n   "],[-1," //"],[0,"         if "]],"start1":22128,"start2":22128,"length1":27,"length2":24},{"diffs":[[0,"ffer_size) {\n   "],[-1," //"],[0,"             buf"]],"start1":22171,"start2":22171,"length1":35,"length2":32},{"diffs":[[0,"signal);\n   "],[-1," //"],[0,"         }\n\n"]],"start1":22212,"start2":22212,"length1":27,"length2":24},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         // If t"]],"start1":22223,"start2":22223,"length1":35,"length2":32},{"diffs":[[0,"process\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"if (buffer.l"]],"start1":22285,"start2":22285,"length1":35,"length2":32},{"diffs":[[0,"ffer_size) {\n   "],[-1," //"],[0,"             buf"]],"start1":22328,"start2":22328,"length1":35,"length2":32},{"diffs":[[0,"shift();\n   "],[-1," //"],[0,"            "]],"start1":22364,"start2":22364,"length1":27,"length2":24},{"diffs":[[0,"ignal);\n\n   "],[-1," //"],[0,"            "]],"start1":22402,"start2":22402,"length1":27,"length2":24},{"diffs":[[0,"d point \n   "],[-1," //"],[0,"            "]],"start1":22478,"start2":22478,"length1":27,"length2":24},{"diffs":[[0,"reshold\n    "],[-1,"//"],[0,"            "]],"start1":22529,"start2":22529,"length1":26,"length2":24},{"diffs":[[0,"            "],[-1," "],[0,"if (Math.abs"]],"start1":22541,"start2":22541,"length1":25,"length2":24},{"diffs":[[0,"threshold) {\n   "],[-1," //"],[0,"                "]],"start1":22591,"start2":22591,"length1":35,"length2":32},{"diffs":[[0,"er[0]) {\n   "],[-1," //"],[0,"            "]],"start1":22667,"start2":22667,"length1":27,"length2":24},{"diffs":[[0,"illis();\n   "],[-1," //"],[0,"            "]],"start1":22729,"start2":22729,"length1":27,"length2":24},{"diffs":[[0,"fer[0];\n    "],[-1,"//"],[0,"            "]],"start1":22777,"start2":22777,"length1":26,"length2":24},{"diffs":[[0,"                "],[-1," "],[0,"currently_checki"]],"start1":22793,"start2":22793,"length1":33,"length2":32},{"diffs":[[0,"ing = true;\n    "],[-1,"//"],[0,"                "]],"start1":22824,"start2":22824,"length1":34,"length2":32},{"diffs":[[0,"            "],[-1," "],[0,"}\n\n   "],[-1," //"],[0,"            "]],"start1":22844,"start2":22844,"length1":34,"length2":30},{"diffs":[[0,"link_time) {\n   "],[-1," //"],[0,"                "]],"start1":22923,"start2":22923,"length1":35,"length2":32},{"diffs":[[0,"t_val) {\n   "],[-1," //"],[0,"            "]],"start1":22980,"start2":22980,"length1":27,"length2":24},{"diffs":[[0,"ing = false;\n   "],[-1," //"],[0,"                "]],"start1":23032,"start2":23032,"length1":35,"length2":32},{"diffs":[[0,"= true;\n    "],[-1,"//"],[0,"            "]],"start1":23078,"start2":23078,"length1":26,"length2":24},{"diffs":[[0,"            "],[-1," "],[0,"}\n   "],[-1," //"],[0,"            "]],"start1":23098,"start2":23098,"length1":33,"length2":29},{"diffs":[[0,"           }\n   "],[-1," //"],[0,"                "]],"start1":23121,"start2":23121,"length1":35,"length2":32},{"diffs":[[0,"      else {\n   "],[-1," //"],[0,"                "]],"start1":23148,"start2":23148,"length1":35,"length2":32},{"diffs":[[0,"= false;\n   "],[-1," //"],[0,"            "]],"start1":23204,"start2":23204,"length1":27,"length2":24},{"diffs":[[0,"          }\n    "],[-1,"//"],[0,"             }\n "]],"start1":23223,"start2":23223,"length1":34,"length2":32},{"diffs":[[0,"            "],[-1," "],[0,"}\n   "],[-1," //"],[0,"         }\n\n"]],"start1":23239,"start2":23239,"length1":33,"length2":29},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         // Samp"]],"start1":23255,"start2":23255,"length1":35,"length2":32},{"diffs":[[0,"culation\n   "],[-1," //"],[0,"         ela"]],"start1":23301,"start2":23301,"length1":27,"length2":24},{"diffs":[[0,"e_time;\n\n   "],[-1," //"],[0,"         if "]],"start1":23370,"start2":23370,"length1":27,"length2":24},{"diffs":[[0,"< period) {\n    "],[-1,"//"],[0,"             con"]],"start1":23408,"start2":23408,"length1":34,"length2":32},{"diffs":[[0,"                "],[-1," "],[0,"control.waitMicr"]],"start1":23420,"start2":23420,"length1":33,"length2":32},{"diffs":[[0,"d_time);\n   "],[-1," //"],[0,"         }\n\n"]],"start1":23470,"start2":23470,"length1":27,"length2":24},{"diffs":[[0,"      }\n\n   "],[-1," //"],[0,"         sam"]],"start1":23485,"start2":23485,"length1":27,"length2":24},{"diffs":[[0,"icros();\n   "],[-1," //"],[0,"     }\n\n    "]],"start1":23538,"start2":23538,"length1":27,"length2":24},{"diffs":[[0,"      }\n\n   "],[-1," //"],[0,"     return "]],"start1":23549,"start2":23549,"length1":27,"length2":24},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":23579,"start2":23579,"length1":33,"length2":24},{"diffs":[[0,"G direction)\n   "],[-1," //"],[0,"  */\n\n    // //%"]],"start1":23627,"start2":23627,"length1":35,"length2":32},{"diffs":[[0,"on)\n     */\n\n   "],[-1," //"],[0," //% group=\"EOG\""]],"start1":23636,"start2":23636,"length1":35,"length2":32},{"diffs":[[0," group=\"EOG\"\n   "],[-1," //"],[0," //% weight=39\n "]],"start1":23656,"start2":23656,"length1":35,"length2":32},{"diffs":[[0,"eight=39\n   "],[-1," //"],[0," //% block=\""]],"start1":23678,"start2":23678,"length1":27,"length2":24},{"diffs":[[0,"ock=\"up\"\n   "],[-1," //"],[0," export func"]],"start1":23697,"start2":23697,"length1":27,"length2":24},{"diffs":[[0,"(): number {\n   "],[-1," //"],[0,"     return Look"]],"start1":23728,"start2":23728,"length1":35,"length2":32},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":23769,"start2":23769,"length1":33,"length2":24},{"diffs":[[0,"G direction)\n   "],[-1," //"],[0,"  */\n\n    // //%"]],"start1":23819,"start2":23819,"length1":35,"length2":32},{"diffs":[[0,"on)\n     */\n\n   "],[-1," //"],[0," //% group=\"EOG\""]],"start1":23828,"start2":23828,"length1":35,"length2":32},{"diffs":[[0," group=\"EOG\"\n   "],[-1," //"],[0," //% weight=38\n "]],"start1":23848,"start2":23848,"length1":35,"length2":32},{"diffs":[[0,"eight=38\n   "],[-1," //"],[0," //% block=\""]],"start1":23870,"start2":23870,"length1":27,"length2":24},{"diffs":[[0,"k=\"down\"\n   "],[-1," //"],[0," export func"]],"start1":23891,"start2":23891,"length1":27,"length2":24},{"diffs":[[0,"(): number {\n   "],[-1," //"],[0,"     return Look"]],"start1":23924,"start2":23924,"length1":35,"length2":32},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":23967,"start2":23967,"length1":33,"length2":24},{"diffs":[[0,"G direction)\n   "],[-1," //"],[0,"  */\n\n    // //%"]],"start1":24017,"start2":24017,"length1":35,"length2":32},{"diffs":[[0,"on)\n     */\n\n   "],[-1," //"],[0," //% group=\"EOG\""]],"start1":24026,"start2":24026,"length1":35,"length2":32},{"diffs":[[0," group=\"EOG\"\n   "],[-1," //"],[0," //% weight=37\n "]],"start1":24046,"start2":24046,"length1":35,"length2":32},{"diffs":[[0,"eight=37\n   "],[-1," //"],[0," //% block=\""]],"start1":24068,"start2":24068,"length1":27,"length2":24},{"diffs":[[0,"k=\"left\"\n   "],[-1," //"],[0," export func"]],"start1":24089,"start2":24089,"length1":27,"length2":24},{"diffs":[[0,"): number {\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"return LookingAt"]],"start1":24123,"start2":24123,"length1":39,"length2":36},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":24165,"start2":24165,"length1":33,"length2":24},{"diffs":[[0,"rection)\n   "],[-1," //"],[0,"  */\n\n    //"]],"start1":24220,"start2":24220,"length1":27,"length2":24},{"diffs":[[0,"on)\n     */\n\n   "],[-1," //"],[0," //% group=\"EOG\""]],"start1":24225,"start2":24225,"length1":35,"length2":32},{"diffs":[[0," group=\"EOG\"\n   "],[-1," //"],[0," //% weight=36\n "]],"start1":24245,"start2":24245,"length1":35,"length2":32},{"diffs":[[0,"eight=36\n   "],[-1," //"],[0," //% block=\""]],"start1":24267,"start2":24267,"length1":27,"length2":24},{"diffs":[[0,"=\"right\"\n   "],[-1," //"],[0," export func"]],"start1":24289,"start2":24289,"length1":27,"length2":24},{"diffs":[[0,"(): number {\n   "],[-1," //"],[0,"     return Look"]],"start1":24323,"start2":24323,"length1":35,"length2":32},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," /**\n   "],[-1," //"],[0,"  * "]],"start1":24367,"start2":24367,"length1":33,"length2":24},{"diffs":[[0,"\n   "],[-1," //"],[0," */\n\n   "],[-1," //"],[0," //%"]],"start1":24422,"start2":24422,"length1":22,"length2":16},{"diffs":[[0,"up=\"EOG\"\n   "],[-1," //"],[0," //% weight="]],"start1":24442,"start2":24442,"length1":27,"length2":24},{"diffs":[[0,"eight=35\n   "],[-1," //"],[0," //% block=\""]],"start1":24460,"start2":24460,"length1":27,"length2":24},{"diffs":[[0,"=\"blink\"\n   "],[-1," //"],[0," export func"]],"start1":24482,"start2":24482,"length1":27,"length2":24},{"diffs":[[0,"number {\n   "],[-1," //"],[0,"     return "]],"start1":24520,"start2":24520,"length1":27,"length2":24},{"diffs":[[0,"    "],[-1,"// }\n\n\n    \n\n    // /**\n    //"],[1,"}\n\n\n    /**\n     * Choose the signal to print in Serial. \n     * You can also specify the specific time to run the printing. \n     * The default loops.\n     * @param signal = choose electrophysiology\n     * @param duration (optional) = duration(ms) to output the signal. If user does not provide one, then loops\n     */\n\n    //% group=\"Other\"\n    //% weight=30\n    //% block=\"print signal || for $duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                serial.writeValue(signal_label, last_measurement());\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                serial.writeValue(signal_label, last_measurement());\n            }\n        }\n    }\n\n\n    /**\n   "],[0,"  * "]],"start1":24561,"start2":24561,"length1":38,"length2":1079},{"diffs":[[0,"r servo.\n   "],[-1," //"],[0,"  * @param a"]],"start1":25656,"start2":25656,"length1":27,"length2":24},{"diffs":[[0," degree)\n   "],[-1," //"],[0,"  */\n\n    //"]],"start1":25710,"start2":25710,"length1":27,"length2":24},{"diffs":[[0,"ee)\n     */\n\n   "],[-1," //"],[0," //% group=\"Othe"]],"start1":25715,"start2":25715,"length1":35,"length2":32},{"diffs":[[0,"roup=\"Other\"\n   "],[-1," //"],[0," //% weight=28\n "]],"start1":25737,"start2":25737,"length1":35,"length2":32},{"diffs":[[0,"eight=28\n   "],[-1," //"],[0," //% block=\""]],"start1":25759,"start2":25759,"length1":27,"length2":24},{"diffs":[[0,"degrees\"\n   "],[-1," //"],[0," export func"]],"start1":25803,"start2":25803,"length1":27,"length2":24},{"diffs":[[0,"umber) {\n   "],[-1," //"],[0,"     pins.se"]],"start1":25854,"start2":25854,"length1":27,"length2":24},{"diffs":[[0," angle);\n   "],[-1," //"],[0," }\n\n\n    // "]],"start1":25903,"start2":25903,"length1":27,"length2":24}]}]},{"timestamp":1726696036106,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"r_index "],[-1,">"],[1,"=="],[0," neurobi"]],"start1":1829,"start2":1829,"length1":17,"length2":18}]}]},{"timestamp":1726696039136,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"um = 0;\n"],[-1,"    \n"],[0,"    // f"]],"start1":620,"start2":620,"length1":21,"length2":16},{"diffs":[[0,"ange"],[-1," - 1"],[0,";\n  "]],"start1":1655,"start2":1655,"length1":12,"length2":8},{"diffs":[[0,"r {\n        "],[1,"//"],[0,"return neuro"]],"start1":3033,"start2":3033,"length1":24,"length2":26},{"diffs":[[0,"\n       "],[-1," //"],[0," return "]],"start1":3093,"start2":3093,"length1":19,"length2":16}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"pe=\""],[-1,"device_while\"><value name=\"COND\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value><statement name=\"DO\"><block type=\"serial_writevalue\"><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">signal</field></shadow></value"],[1,"neurobit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation"],[0,"><va"]],"start1":189,"start2":189,"length1":259,"length2":114},{"diffs":[[0,"e name=\""],[-1,"value"],[1,"duration"],[0,"\"><shado"]],"start1":305,"start2":305,"length1":21,"length2":24},{"diffs":[[0,"pe=\""],[-1,"math_numb"],[1,"timePick"],[0,"er\">"]],"start1":333,"start2":333,"length1":17,"length2":16},{"diffs":[[0,"me=\""],[-1,"NUM"],[1,"ms"],[0,"\">0<"]],"start1":358,"start2":358,"length1":11,"length2":10},{"diffs":[[0,"ow><"],[-1,"block type=\"neurobit_last_measurement\"></block></value></block></statement"],[1,"/value"],[0,"></b"]],"start1":381,"start2":381,"length1":82,"length2":14}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"g()\n"],[-1,"while (true) {\n    serial.writeValue(\"signal\", neurobit.last_measureme"],[1,"neurobit.pri"],[0,"nt()"],[-1,")\n}"],[0,"\n"]],"start1":15,"start2":15,"length1":82,"length2":21}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1726696443649,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"s = "],[-1,"250"],[1,"4"],[0,"; //["],[-1,"Hz"],[1,"ms"],[0,"]\n  "]],"start1":1565,"start2":1565,"length1":18,"length2":16},{"diffs":[[0,"  const "],[-1,"time_"],[0,"range = "]],"start1":1585,"start2":1585,"length1":21,"length2":16},{"diffs":[[0,"e = "],[-1,"(fs * time_"],[1,"1000 / fs * "],[0,"range"],[-1,")"],[0," - 1;\n"],[-1,"        const time_delay = 10; //[ms] \n"],[0,"    "]],"start1":1643,"start2":1643,"length1":70,"length2":31}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1726696930643,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"= 0;"],[-1,"\n    let neurobit_read_index = 0;"],[0,"\n\n  "]],"start1":447,"start2":447,"length1":41,"length2":8},{"diffs":[[0,"delay = "],[-1,"2"],[1,"1"],[0,"0; //[ms"]],"start1":1696,"start2":1696,"length1":17,"length2":17},{"diffs":[[0,"s] \n"],[-1,"        const index_gap = Math.ceil(fs / (1000 / time_delay));\n"],[0,"    "]],"start1":1712,"start2":1712,"length1":71,"length2":8},{"diffs":[[0,"  }\n"],[-1,"            if (neurobit_buffer_index < index_gap) {\n                neurobit_read_index = neurobit_buffer_size\n            }\n"],[0,"    "]],"start1":1971,"start2":1971,"length1":134,"length2":8}]}]},{"timestamp":1726697476475,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"e_range)"],[1," - 1"],[0,";\n      "]],"start1":1696,"start2":1696,"length1":16,"length2":20},{"diffs":[[0,"_index >"],[-1,"="],[0," neurobi"]],"start1":1981,"start2":1981,"length1":17,"length2":16}]}]},{"timestamp":1726697771093,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"  }\n"],[-1,"            \n"],[0,"    "]],"start1":2064,"start2":2064,"length1":21,"length2":8},{"diffs":[[0,"size"],[-1," - (index_gap - neurobit_buffer_index);\n            }\n            else {\n                neurobit_read_index = neurobit_buffer_index - index_gap;"],[0,"\n   "]],"start1":2175,"start2":2175,"length1":153,"length2":8},{"diffs":[[0,"\n       "],[-1," //"],[0," return "]],"start1":3310,"start2":3310,"length1":19,"length2":16},{"diffs":[[0,"er[neurobit_"],[-1,"read"],[1,"buffer"],[0,"_index];\n   "]],"start1":3339,"start2":3339,"length1":28,"length2":30},{"diffs":[[0,"_index];\n       "],[1," //"],[0," return neurobit"]],"start1":3357,"start2":3357,"length1":32,"length2":35},{"diffs":[[0,"rn neurobit_"],[-1,"read"],[1,"buffer"],[0,"_index;\n    "]],"start1":3381,"start2":3381,"length1":28,"length2":30}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1726698424174,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1726698441307,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"   let neurobit_"],[-1,"write"],[1,"buffer"],[0,"_index = 0;\n    "]],"start1":418,"start2":418,"length1":37,"length2":38},{"diffs":[[0,"er[neurobit_"],[-1,"write"],[1,"buffer"],[0,"_index] = pi"]],"start1":1856,"start2":1856,"length1":29,"length2":30},{"diffs":[[0,"   neurobit_"],[-1,"write"],[1,"buffer"],[0,"_index++;\n  "]],"start1":1918,"start2":1918,"length1":29,"length2":30},{"diffs":[[0,"f (neurobit_"],[-1,"write"],[1,"buffer"],[0,"_index >= ne"]],"start1":1959,"start2":1959,"length1":29,"length2":30},{"diffs":[[0,"   neurobit_"],[-1,"write"],[1,"buffer"],[0,"_index = 0;\n"]],"start1":2024,"start2":2024,"length1":29,"length2":30},{"diffs":[[0,"f (neurobit_"],[-1,"write"],[1,"buffer"],[0,"_index < ind"]],"start1":2094,"start2":2094,"length1":29,"length2":30},{"diffs":[[0," - neurobit_"],[-1,"write"],[1,"buffer"],[0,"_index);\n   "]],"start1":2205,"start2":2205,"length1":29,"length2":30},{"diffs":[[0,"eurobit_"],[-1,"write"],[1,"buffer"],[0,"_index -"]],"start1":2304,"start2":2304,"length1":21,"length2":22},{"diffs":[[0,"er {\n       "],[1," //"],[0," return neur"]],"start1":3464,"start2":3464,"length1":24,"length2":27},{"diffs":[[0,"_index];\n       "],[-1," //"],[0," return neurobit"]],"start1":3516,"start2":3516,"length1":35,"length2":32}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"33"],[1,"0"],[0,"\" y=\""],[-1,"54"],[1,"0"],[0,"\"><s"]],"start1":104,"start2":104,"length1":17,"length2":15},{"diffs":[[0,"pe=\""],[-1,"neurobit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation"],[1,"device_while\"><value name=\"COND\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value><statement name=\"DO\"><block type=\"serial_writevalue\"><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">signal</field></shadow></value"],[0,"><va"]],"start1":189,"start2":189,"length1":114,"length2":259},{"diffs":[[0,"me=\""],[-1,"duration"],[1,"value"],[0,"\"><s"]],"start1":454,"start2":454,"length1":16,"length2":13},{"diffs":[[0,"pe=\""],[-1,"timePick"],[1,"math_numb"],[0,"er\">"]],"start1":475,"start2":475,"length1":16,"length2":17},{"diffs":[[0,"me=\""],[-1,"ms"],[1,"NUM"],[0,"\">0<"]],"start1":501,"start2":501,"length1":10,"length2":11},{"diffs":[[0,"shadow><"],[-1,"/value"],[1,"block type=\"neurobit_last_measurement\"></block></value></block></statement"],[0,"></block"]],"start1":521,"start2":521,"length1":22,"length2":90}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"g()\n"],[-1,"neurobit.pri"],[1,"while (true) {\n    serial.writeValue(\"signal\", neurobit.last_measureme"],[0,"nt()"],[1,")\n}"],[0,"\n"]],"start1":15,"start2":15,"length1":21,"length2":82}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1726698570861,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"0"],[1,"33"],[0,"\" y=\""],[-1,"0"],[1,"54"],[0,"\"><s"]],"start1":104,"start2":104,"length1":15,"length2":17}]}]},{"timestamp":1726769594194,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1726769597844,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"    \n   "],[1," //"],[0," functio"]],"start1":660,"start2":660,"length1":16,"length2":19},{"diffs":[[0,"    "],[-1,"    /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n   "],[1,"//"],[0,"    "]],"start1":715,"start2":715,"length1":140,"length2":10},{"diffs":[[0,"lization\n   "],[1," //"],[0,"     const w"]],"start1":734,"start2":734,"length1":24,"length2":27},{"diffs":[[0,"f signal\n   "],[1," //"],[0,"     const k"]],"start1":820,"start2":820,"length1":24,"length2":27},{"diffs":[[0,"    "],[-1,"    // If buffer length is less than the window size\n   "],[1,"//"],[0,"    "]],"start1":898,"start2":898,"length1":64,"length2":10},{"diffs":[[0,"ndow_size) {\n   "],[1," //"],[0,"         // Only"]],"start1":940,"start2":940,"length1":32,"length2":35},{"diffs":[[0,"h the buffer\n   "],[1," //"],[0,"         envelop"]],"start1":979,"start2":979,"length1":32,"length2":35},{"diffs":[[0,"signal);\n   "],[1," //"],[0,"         env"]],"start1":1032,"start2":1032,"length1":24,"length2":27},{"diffs":[[0,"new_signal;\n\n   "],[1," //"],[0,"         return "]],"start1":1072,"start2":1072,"length1":32,"length2":35},{"diffs":[[0,"eturn 0;\n   "],[1," //"],[0,"     }\n     "]],"start1":1101,"start2":1101,"length1":24,"length2":27},{"diffs":[[0,"/     }\n    "],[1,"//"],[0,"    "],[1," "],[0,"else {\n     "]],"start1":1115,"start2":1115,"length1":28,"length2":31},{"diffs":[[0,"/     else {\n   "],[1," //"],[0,"         // Upda"]],"start1":1128,"start2":1128,"length1":32,"length2":35},{"diffs":[[0,"e buffer\n   "],[1," //"],[0,"         let"]],"start1":1168,"start2":1168,"length1":24,"length2":27},{"diffs":[[0,"shift();\n   "],[1," //"],[0,"         env"]],"start1":1225,"start2":1225,"length1":24,"length2":27},{"diffs":[[0,"ignal);\n\n   "],[1," //"],[0,"         // "]],"start1":1275,"start2":1275,"length1":24,"length2":27},{"diffs":[[0,"kernel\")\n   "],[1," //"],[0,"         env"]],"start1":1353,"start2":1353,"length1":24,"length2":27},{"diffs":[[0,"l;\n\n    "],[1,"//"],[0,"        "],[1," "],[0,"return e"]],"start1":1429,"start2":1429,"length1":24,"length2":27},{"diffs":[[0," kernel;\n   "],[1," //"],[0,"     }\n    }"]],"start1":1469,"start2":1469,"length1":24,"length2":27},{"diffs":[[0,"//     }\n   "],[1," //"],[0," }\n\n    /**\n"]],"start1":1482,"start2":1482,"length1":24,"length2":27},{"diffs":[[0,") {\n"],[-1,"                if (apply_envelope) {\n                    serial.writeValue(signal_label, convolution(last_measurement()));\n                }\n                else {\n    "],[0,"    "]],"start1":4495,"start2":4495,"length1":177,"length2":8},{"diffs":[[0,"ent());\n"],[-1,"                }\n"],[0,"        "]],"start1":4560,"start2":4560,"length1":34,"length2":16},{"diffs":[[0,") {\n"],[-1,"                if (apply_envelope) {\n                    serial.writeValue(signal_label, convolution(last_measurement()));\n                }\n                else {\n    "],[0,"    "]],"start1":4767,"start2":4767,"length1":177,"length2":8},{"diffs":[[0,"ent());\n"],[-1,"                }\n"],[0,"        "]],"start1":4832,"start2":4832,"length1":34,"length2":16}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"39"],[1,"0"],[0,"\" y=\""],[-1,"55"],[1,"0"],[0,"\"><s"]],"start1":104,"start2":104,"length1":17,"length2":15},{"diffs":[[0,"ock "],[-1,"type=\"neurobit_envelope\"><next><block "],[0,"type"]],"start1":146,"start2":146,"length1":46,"length2":8},{"diffs":[[0,"block></"],[-1,"next></block></"],[0,"statemen"]],"start1":409,"start2":409,"length1":31,"length2":16}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"neurobit.envelope()\n"],[0,"neur"]],"start1":0,"start2":0,"length1":24,"length2":4}]}]},{"timestamp":1726770314345,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"\n           "],[-1," //"],[0," return enve"]],"start1":1574,"start2":1574,"length1":27,"length2":24}]}]},{"timestamp":1726770400628,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"el;\n"],[-1,"            return envelope_sum;\n"],[0,"    "]],"start1":1616,"start2":1616,"length1":41,"length2":8}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"0"],[1,"39"],[0,"\" y=\""],[-1,"0"],[1,"55"],[0,"\"><s"]],"start1":104,"start2":104,"length1":15,"length2":17}]}]},{"timestamp":1726770833837,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"ft()"],[-1," as number"],[0,";\n  "]],"start1":1379,"start2":1379,"length1":18,"length2":8},{"diffs":[[0,"        "],[-1," //"],[0," envelop"]],"start1":1510,"start2":1510,"length1":19,"length2":16}]}]},{"timestamp":1726771519391,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"_label, "],[-1,"env"],[1,"convolution(last_measurement())"],[0,");\n     "]],"start1":4763,"start2":4763,"length1":19,"length2":47}]}]},{"timestamp":1726771539555,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"ope_"],[-1,"sum"],[1,"buffer"],[0,": number"],[1,"[]"],[0," = "],[-1,"0"],[1,"[]"],[0,";\n  "]],"start1":607,"start2":607,"length1":23,"length2":29},{"diffs":[[0,"nvelope_"],[-1,"buffer: number[] = []"],[1,"sum = 0"],[0,";\n    \n "]],"start1":643,"start2":643,"length1":37,"length2":23},{"diffs":[[0,"0;\n    \n    "],[-1,"export "],[0,"function con"]],"start1":657,"start2":657,"length1":31,"length2":24},{"diffs":[[0,"kernel?\n"],[-1,"        "],[0,"\n       "]],"start1":1010,"start2":1010,"length1":24,"length2":16},{"diffs":[[0,"el\")\n           "],[1," //"],[0," envelope_sum = "]],"start1":1512,"start2":1512,"length1":32,"length2":35},{"diffs":[[0,"al;\n\n           "],[1," //"],[0," return envelope"]],"start1":1583,"start2":1583,"length1":32,"length2":35},{"diffs":[[0,"nel;\n           "],[-1," //"],[0," return envelope"]],"start1":1628,"start2":1628,"length1":35,"length2":32},{"diffs":[[0,"el, "],[-1,"convolution(last_measurement())"],[1,"env"],[0,");\n "]],"start1":4767,"start2":4767,"length1":39,"length2":11}]}]},{"timestamp":1726772167350,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"39"],[1,"0"],[0,"\" y=\""],[-1,"55"],[1,"0"],[0,"\"><s"]],"start1":104,"start2":104,"length1":17,"length2":15}]}]},{"timestamp":1726772231561,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"nal:"],[-1," number, envelope_sum:"],[0," num"]],"start1":712,"start2":712,"length1":30,"length2":8},{"diffs":[[0,") {\n"],[-1,"                    // Obtain the signal + make baseline to be 0\n                    let signal = last_measurement() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n"],[0,"    "]],"start1":4735,"start2":4735,"length1":236,"length2":8},{"diffs":[[0,"ion("],[-1,"rectified_signal, envelope_sum"],[1,"last_measurement()"],[0,"));\n"]],"start1":4799,"start2":4799,"length1":38,"length2":26},{"diffs":[[0,"nt()"],[-1,", envelope_sum"],[0,"));\n"]],"start1":5276,"start2":5276,"length1":22,"length2":8}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"0"],[1,"39"],[0,"\" y=\""],[-1,"0"],[1,"55"],[0,"\"><s"]],"start1":104,"start2":104,"length1":15,"length2":17},{"diffs":[[0,"tation><"],[1,"value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">0</field></shadow></value><"],[0,"/block><"]],"start1":333,"start2":333,"length1":16,"length2":108}]}]},{"timestamp":1726772789854,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"_signal:"],[1," number, envelope_sum:"],[0," number)"]],"start1":708,"start2":708,"length1":16,"length2":38},{"diffs":[[0,"sum "],[-1,"= envelope_sum "],[0,"+"],[1,"="],[0," new"]],"start1":1276,"start2":1276,"length1":24,"length2":10},{"diffs":[[0,"    "],[-1," return 0;\n        //"],[0," els"]],"start1":1331,"start2":1331,"length1":29,"length2":8},{"diffs":[[0,"        "],[-1,"//"],[0,"    "],[-1," "],[0,"// Updat"]],"start1":1343,"start2":1343,"length1":23,"length2":20},{"diffs":[[0,"ffer\n       "],[-1," //"],[0,"     let old"]],"start1":1371,"start2":1371,"length1":27,"length2":24},{"diffs":[[0,"number;\n        "],[-1,"//"],[0,"    "],[-1," "],[0,"envelope_buffer."]],"start1":1432,"start2":1432,"length1":39,"length2":36},{"diffs":[[0,"ignal);\n\n       "],[-1," //"],[0,"     // Perform "]],"start1":1478,"start2":1478,"length1":35,"length2":32},{"diffs":[[0,"el\")\n       "],[-1," //"],[0,"     envelop"]],"start1":1557,"start2":1557,"length1":27,"length2":24},{"diffs":[[0,"al;\n\n       "],[-1," //"],[0,"     return "]],"start1":1625,"start2":1625,"length1":27,"length2":24},{"diffs":[[0,"\n       "],[-1," //"],[0,"     // "]],"start1":1671,"start2":1671,"length1":19,"length2":16},{"diffs":[[0,"\n       "],[-1," //"],[0," }\n    }"]],"start1":1707,"start2":1707,"length1":19,"length2":16},{"diffs":[[0,"d_signal"],[1,", envelope_sum"],[0,"));\n    "]],"start1":5061,"start2":5061,"length1":16,"length2":30},{"diffs":[[0,"rement()"],[1,", envelope_sum"],[0,"));\n    "]],"start1":5534,"start2":5534,"length1":16,"length2":30}]}]},{"timestamp":1726773370872,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"     return "],[-1,"envelope_sum"],[1,"0"],[0,";\n        //"]],"start1":1323,"start2":1323,"length1":36,"length2":25},{"diffs":[[0,"y));"],[-1,"\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < neurobit_buffer_size; i++) {\n            neurobit_buffer[i] = 0;\n        }\n\n        // \"Actual\" background processing"],[0,"\n   "]],"start1":2063,"start2":2063,"length1":231,"length2":8},{"diffs":[[0,"x++;"],[-1,"\n\n            // Loop back write_index after reach to end"],[0,"\n   "]],"start1":2199,"start2":2199,"length1":65,"length2":8},{"diffs":[[0,"   \n"],[-1,"            // Caluclation for correct read_index\n"],[0,"    "]],"start1":2333,"start2":2333,"length1":58,"length2":8},{"diffs":[[0,"   }"],[-1,"\n\n            // Pause (tick = 4ms)"],[0,"\n   "]],"start1":2600,"start2":2600,"length1":43,"length2":8},{"diffs":[[0,"): number {\n"],[-1,""],[0,"        retu"]],"start1":3710,"start2":3710,"length1":24,"length2":24},{"diffs":[[0,"ead_index];\n"],[1,"        // return neurobit_read_index;\n"],[0,"    }\n\n\n    "]],"start1":3763,"start2":3763,"length1":24,"length2":63}]}]},{"timestamp":1726773969498,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"nel?"],[-1,"\n\n        if (isNaN(new_signal)) {\n            return 0;\n        }"],[0,"\n   "]],"start1":1028,"start2":1028,"length1":74,"length2":8},{"diffs":[[0,"ly push "],[-1,"to "],[0,"the buff"]],"start1":1168,"start2":1168,"length1":19,"length2":16},{"diffs":[[0,"0;\n        }\n   "],[1,"     return envelope_sum;\n        // else {\n        //"],[0,"     // Update t"]],"start1":1307,"start2":1307,"length1":32,"length2":86},{"diffs":[[0,"fer\n        "],[-1,"else {\n       "],[1,"//"],[0,"     let old"]],"start1":1399,"start2":1399,"length1":38,"length2":26},{"diffs":[[0," number;\n       "],[1," //"],[0,"     envelope_bu"]],"start1":1461,"start2":1461,"length1":32,"length2":35},{"diffs":[[0,"ignal);\n\n       "],[1," //"],[0,"     // Perform "]],"start1":1511,"start2":1511,"length1":32,"length2":35},{"diffs":[[0,"ernel\")\n        "],[1,"//"],[0,"    "],[1," "],[0,"envelope_sum = e"]],"start1":1590,"start2":1590,"length1":36,"length2":39},{"diffs":[[0,"signal;\n\n       "],[1," //"],[0,"     return enve"]],"start1":1660,"start2":1660,"length1":32,"length2":35},{"diffs":[[0," kernel;\n       "],[1," //     // return envelope_sum;\n        //"],[0," }\n    }\n\n    /*"]],"start1":1705,"start2":1705,"length1":32,"length2":74}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"27"],[1,"0"],[0,"\" y=\""],[-1,"2"],[0,"0\"><"]],"start1":104,"start2":104,"length1":16,"length2":14},{"diffs":[[0,"HANDLER\"><block "],[1,"type=\"neurobit_envelope\"><next><block "],[0,"type=\"neurobit_s"]],"start1":134,"start2":134,"length1":32,"length2":70},{"diffs":[[0,"block></"],[1,"next></block></"],[0,"statemen"]],"start1":355,"start2":355,"length1":16,"length2":31}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"neurobit.envelope()\n"],[0,"neurobit.set_emg"]],"start1":0,"start2":0,"length1":16,"length2":36}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1726774558814,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"l);\n"],[-1,"                    \n                    // Serial Out the signal"],[0,"\n   "]],"start1":5331,"start2":5331,"length1":73,"length2":8},{"diffs":[[0,"e {\n"],[-1,"                    // Serial Out the signal\n"],[0,"    "]],"start1":5457,"start2":5457,"length1":53,"length2":8},{"diffs":[[0,") {\n"],[-1,"                    // Obtain the signal + make baseline to be 0\n                    let signal = last_measurement() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n"],[0,"    "]],"start1":5789,"start2":5789,"length1":281,"length2":8},{"diffs":[[0,"olution("],[-1,"rectified_signal"],[1,"last_measurement()"],[0,"));\n    "]],"start1":5849,"start2":5849,"length1":32,"length2":34},{"diffs":[[0,"e {\n"],[-1,"                    // Serial Out the signal\n"],[0,"    "]],"start1":5916,"start2":5916,"length1":53,"length2":8}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"35"],[1,"27"],[0,"\" y=\""],[-1,"5"],[1,"2"],[0,"0\"><"]],"start1":104,"start2":104,"length1":16,"length2":16},{"diffs":[[0,"ock "],[-1,"type=\"neurobit_envelope\"><next><block "],[0,"type"]],"start1":148,"start2":148,"length1":46,"length2":8},{"diffs":[[0,"panded=\""],[-1,"1"],[1,"0"],[0,"\" _input"]],"start1":261,"start2":261,"length1":17,"length2":17},{"diffs":[[0,"on><"],[-1,"value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">5000</field></shadow></value></block></next><"],[0,"/blo"]],"start1":299,"start2":299,"length1":118,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"neurobit.envelope()\n"],[0,"neur"]],"start1":0,"start2":0,"length1":24,"length2":4},{"diffs":[[0,"int("],[-1,"5000"],[0,")\n"]],"start1":30,"start2":30,"length1":10,"length2":6}]}]},{"timestamp":1726774662884,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"0"],[1,"35"],[0,"\" y=\""],[1,"5"],[0,"0\"><"]],"start1":104,"start2":104,"length1":14,"length2":16}]}]},{"timestamp":1726845903716,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"t.print("],[1,"5000"],[0,")\n"]],"start1":46,"start2":46,"length1":10,"length2":14}]}]},{"timestamp":1726848739067,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"panded=\""],[-1,"0"],[1,"1"],[0,"\" _input"]],"start1":297,"start2":297,"length1":17,"length2":17}]}]},{"timestamp":1726848739092,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," */\n"],[-1,"    const fs = 250; //[Hz]\n    const time_range = 5; //[s]\n    const neurobit_buffer_size = (fs * time_range);\n"],[0,"    "]],"start1":373,"start2":373,"length1":119,"length2":8},{"diffs":[[0,"nction () {\n"],[1,"        const fs = 250; //[Hz]\n        const time_range = 5; //[s]\n        const neurobit_buffer_size = (fs * time_range);\n"],[0,"        cons"]],"start1":1815,"start2":1815,"length1":24,"length2":147},{"diffs":[[0," }\n\n"],[-1,"    //% group=\"Signal\"\n    //% weight=101\n    //% block=\"return buffer from last $duration ms\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    export function last_buffer(duration: number): number[] {\n        let copy = neurobit_buffer;\n        return copy;\n    }\n\n"],[0,"\n   "]],"start1":4127,"start2":4127,"length1":291,"length2":8},{"diffs":[[0,"eight=10"],[-1,"0"],[1,"1"],[0,"\n    //%"]],"start1":4264,"start2":4264,"length1":17,"length2":17}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1726849295397,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," = 5"],[-1,"000"],[0,"; //["],[-1,"m"],[0,"s]\n "]],"start1":424,"start2":424,"length1":17,"length2":13},{"diffs":[[0,"= (fs * "],[-1,"("],[0,"time_ran"]],"start1":467,"start2":467,"length1":17,"length2":16},{"diffs":[[0,"ange"],[-1," / 1000)"],[0,");\n "]],"start1":481,"start2":481,"length1":16,"length2":8},{"diffs":[[0,"] {\n"],[-1,"        let copy_size = Math.floor(neurobit_buffer_size / (time_range / duration))\n"],[0,"    "]],"start1":4334,"start2":4334,"length1":91,"length2":8}]}]},{"timestamp":1726849480786,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1726850596266,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"elope()\n"],[1,"neurobit.set_emg()\nneurobit.print()\n"]],"start1":12,"start2":12,"length1":8,"length2":44}]}]},{"timestamp":1726850608801,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"HANDLER\"><block "],[1,"type=\"neurobit_envelope\"><next><block "],[0,"type=\"neurobit_s"]],"start1":134,"start2":134,"length1":32,"length2":70},{"diffs":[[0,"block></"],[-1,"statemen"],[1,"nex"],[0,"t></bloc"]],"start1":450,"start2":450,"length1":24,"length2":19},{"diffs":[[0,"ck><"],[-1,"block type=\"neurobit_envelope\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"206\" y=\"349\""],[1,"/statement"],[0,"></b"]],"start1":468,"start2":468,"length1":106,"length2":18}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"bit."],[-1,"set_emg()\nneurobit.print"],[1,"envelope"],[0,"()\n"]],"start1":5,"start2":5,"length1":31,"length2":15}]}]},{"timestamp":1726850611630,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"/block><"],[1,"block type=\"neurobit_envelope\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"206\" y=\"349\"></block><"],[0,"/xml>"]],"start1":431,"start2":431,"length1":13,"length2":121}]}]},{"timestamp":1726851625434,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727121180541,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"1"],[0,"0\" y=\""],[-1,"1"],[0,"0\"><"]],"start1":104,"start2":104,"length1":16,"length2":14},{"diffs":[[0,"tation><"],[1,"value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">5000</field></shadow></value><"],[0,"/block><"]],"start1":293,"start2":293,"length1":16,"length2":111}]}]},{"timestamp":1727121977883,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727121977979,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[1,"1"],[0,"0\" y=\""],[1,"1"],[0,"0\"><"]],"start1":104,"start2":104,"length1":14,"length2":16},{"diffs":[[0,"ock "],[-1,"type=\"neurobit_envelope\"><next><block "],[0,"type"]],"start1":148,"start2":148,"length1":46,"length2":8},{"diffs":[[0,"block></"],[-1,"next></block></"],[0,"statemen"]],"start1":319,"start2":319,"length1":31,"length2":16}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"neurobit.envelope()\n"],[0,"neur"]],"start1":0,"start2":0,"length1":24,"length2":4}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727122387098,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"];\n    \n    "],[1,"export "],[0,"function con"]],"start1":789,"start2":789,"length1":24,"length2":31}]}]},{"timestamp":1727123564865,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"tension\n"],[1,"// "],[0,"enum Sig"]],"start1":25,"start2":25,"length1":16,"length2":19},{"diffs":[[0,"l {\n"],[1,"// "],[0,"    E"],[-1,"M"],[1,"E"],[0,"G,\n"],[1,"// "],[0,"    E"],[-1,"E"],[1,"M"],[0,"G,\n"],[1,"//"],[0,"    "],[1," "],[0,"ECG"],[-1,"\n}\n\nenum SignalShape"],[1,",\n//     EOG\n// }\n\n// enum Cue {\n//     none,\n//     visual,\n//     audio\n// }\n\n// enum LookingAt"],[0," {\n"],[1,"//"],[0,"    "],[-1,"RAW,\n    ENVELOPE\n}\n\n"],[1," none,\n//     up,\n//     left,\n//     right,\n//     down,\n//     blink\n// }"],[0,"\n\n//"]],"start1":46,"start2":46,"length1":81,"length2":223},{"diffs":[[0,"robit {\n"],[1,"    /**\n     * Global initialization\n     */\n"],[0,"    cons"]],"start1":324,"start2":324,"length1":16,"length2":61},{"diffs":[[0,"  const "],[-1,"FS"],[1,"fs"],[0," = 250; "]],"start1":379,"start2":379,"length1":18,"length2":18},{"diffs":[[0,"  const "],[-1,"TIME_RANGE"],[1,"time_range"],[0," = 5000;"]],"start1":406,"start2":406,"length1":26,"length2":26},{"diffs":[[0,"nst "],[-1,"MAX_BUFFER_SIZE"],[1,"neurobit_buffer_size"],[0," = ("],[-1,"FS"],[1,"fs"],[0," * ("],[-1,"TIME_RANGE"],[1,"time_range"],[0," / 1"]],"start1":446,"start2":446,"length1":43,"length2":48},{"diffs":[[0,"    "],[-1,"const PIN = AnalogPin.P1;\n\n    let "],[1,"let neurobit_"],[0,"buff"]],"start1":501,"start2":501,"length1":43,"length2":21},{"diffs":[[0,"    let "],[1,"neurobit_"],[0,"write_in"]],"start1":541,"start2":541,"length1":16,"length2":25},{"diffs":[[0,"    let "],[1,"neurobit_"],[0,"read_ind"]],"start1":575,"start2":575,"length1":16,"length2":25},{"diffs":[[0,"read_index = 0;\n"],[1,"\n    const PIN = AnalogPin.P1;\n\n"],[0,"    let signal_l"]],"start1":592,"start2":592,"length1":32,"length2":64},{"diffs":[[0,"EEG "],[-1,"(right now)"],[0,"\n\n  "]],"start1":680,"start2":680,"length1":19,"length2":8},{"diffs":[[0,"let "],[1,"apply_"],[0,"envelope"],[-1,"_sum: number = 0"],[1," = false"],[0,";\n  "]],"start1":690,"start2":690,"length1":32,"length2":30},{"diffs":[[0,"ope_"],[-1,"buffer: number[] = [];\n\n    let ecgTimestamps"],[1,"sum"],[0,": number"],[-1,"[]"],[0," = "],[-1,"[]"],[1,"0"],[0,";\n  "]],"start1":731,"start2":731,"length1":68,"length2":23},{"diffs":[[0,"let "],[-1,"signalType: Signal = Signal.EMG\n    let notInitialized = 1\n    let envelopeValue: number = 0\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG"],[1,"envelope_buffer"],[0,": number"],[1,"[]"],[0," = "],[-1,"0\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    const ECG_JUMP = 40\n    const DEBOUNCE_PERIOD_ECG = 300\n"],[1,"[];\n    "],[0,"\n   "]],"start1":756,"start2":756,"length1":311,"length2":44},{"diffs":[[0,"  */\n\n        //"],[-1," "],[0,"Initialization\n "]],"start1":971,"start2":971,"length1":33,"length2":32},{"diffs":[[0,"l?\n\n"],[-1,"        // Just to be safe\n"],[0,"    "]],"start1":1147,"start2":1147,"length1":35,"length2":8},{"diffs":[[0,"rn 0;\n        }\n"],[1,"        "],[0,"\n        // If b"]],"start1":1200,"start2":1200,"length1":32,"length2":40},{"diffs":[[0," }\n\n"],[-1,"\n"],[0,"    /"],[-1,"/ Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)"],[1,"**\n     * Background Process\n     */\n    control.inBackground(function () {"],[0,"\n   "]],"start1":1859,"start2":1859,"length1":132,"length2":88},{"diffs":[[0,"ms] "],[-1,"(delay from write to read)"],[0,"\n   "]],"start1":1978,"start2":1978,"length1":34,"length2":8},{"diffs":[[0,"t index_"],[-1,"delay"],[1,"gap"],[0," = Math."]],"start1":1995,"start2":1995,"length1":21,"length2":19},{"diffs":[[0,"th.ceil("],[-1,"FS"],[1,"fs"],[0," / (1000"]],"start1":2011,"start2":2011,"length1":18,"length2":18},{"diffs":[[0," 0; i < "],[-1,"MAX_BUFFER_SIZE"],[1,"neurobit_buffer_size"],[0,"; i++) {"]],"start1":2143,"start2":2143,"length1":31,"length2":36},{"diffs":[[0,"            "],[1,"neurobit_"],[0,"buffer[i] = "]],"start1":2180,"start2":2180,"length1":24,"length2":33},{"diffs":[[0,"      //"],[1," \"Actual\""],[0," backgro"]],"start1":2229,"start2":2229,"length1":16,"length2":25},{"diffs":[[0,"    "],[-1,"lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            "],[1,"neurobit_buffer[neurobit_write_index] = pins.analogReadPin(PIN);\n            neurobit_"],[0,"writ"]],"start1":2300,"start2":2300,"length1":172,"length2":94},{"diffs":[[0,"            if ("],[1,"neurobit_"],[0,"write_index >= M"]],"start1":2462,"start2":2462,"length1":32,"length2":41},{"diffs":[[0,"ndex >= "],[-1,"MAX_BUFFER_SIZE"],[1,"neurobit_buffer_size"],[0,") {\n    "]],"start1":2494,"start2":2494,"length1":31,"length2":36},{"diffs":[[0,"        "],[1,"neurobit_"],[0,"write_in"]],"start1":2534,"start2":2534,"length1":16,"length2":25},{"diffs":[[0,";\n            }\n"],[1,"            "],[0,"\n            // "]],"start1":2566,"start2":2566,"length1":32,"length2":44},{"diffs":[[0,"    if ("],[1,"neurobit_"],[0,"write_in"]],"start1":2653,"start2":2653,"length1":16,"length2":25},{"diffs":[[0,"< index_"],[-1,"delay"],[1,"gap"],[0,") {\n    "]],"start1":2682,"start2":2682,"length1":21,"length2":19},{"diffs":[[0,"    "],[-1,"read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index"],[1,"neurobit_read_index = neurobit_buffer_size"],[0," - "],[1,"("],[0,"index_"],[-1,"delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n            "],[1,"gap - neurobit_write_index);\n"],[0,"    "]],"start1":2709,"start2":2709,"length1":582,"length2":89},{"diffs":[[0,"  }\n"],[-1,"                    }\n        "],[0,"    "]],"start1":2804,"start2":2804,"length1":38,"length2":8},{"diffs":[[0,"    "],[-1,"        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n"],[1,"neurobit_read_index = neurobit_write_index - index_gap;\n            }\n\n            // Pause (tick = 4ms)"],[0,"\n   "]],"start1":2839,"start2":2839,"length1":986,"length2":112},{"diffs":[[0," }\n    }"],[-1,"\n\n"],[1,")"],[0,"\n\n    /*"]],"start1":2983,"start2":2983,"length1":18,"length2":17},{"diffs":[[0,"  * "],[-1,"Start r"],[1,"R"],[0,"ecord"],[-1,"ing"],[0," EMG "],[-1,"signal "],[1,"in background"],[0,"\n   "]],"start1":3005,"start2":3005,"length1":35,"length2":32},{"diffs":[[0," //% group=\""],[-1,"Initialization"],[1,"Signal"],[0,"\"\n    //% we"]],"start1":3046,"start2":3046,"length1":38,"length2":30},{"diffs":[[0,"ght="],[-1,"45 "],[1,"105"],[0,"\n   "]],"start1":3077,"start2":3077,"length1":11,"length2":11},{"diffs":[[0,"ck=\""],[-1,"StartRecordingEMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;"],[1,"record EMG in background\"\n    export function set_emg() {"],[0,"\n   "]],"start1":3096,"start2":3096,"length1":137,"length2":65},{"diffs":[[0,"alPin.P8, 1)"],[1,";"],[0,"\n        pin"]],"start1":3192,"start2":3192,"length1":24,"length2":25},{"diffs":[[0,"igitalPin.P9, 1)"],[1,";"],[0,"\n        if (not"]],"start1":3236,"start2":3236,"length1":32,"length2":33},{"diffs":[[0,"    "],[-1,"if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }"],[1,"signal_label = \"EMG\";"],[0,"\n    }\n\n"],[-1,"\n"],[0,"    "]],"start1":3258,"start2":3258,"length1":137,"length2":37},{"diffs":[[0,"  * "],[-1,"Start r"],[1,"R"],[0,"ecord"],[-1,"ing"],[0," E"],[-1,"CG signal"],[1,"KG in background"],[0,"\n   "]],"start1":3302,"start2":3302,"length1":34,"length2":32},{"diffs":[[0," //% group=\""],[-1,"Initialization"],[1,"Signal"],[0,"\"\n    //% we"]],"start1":3343,"start2":3343,"length1":38,"length2":30},{"diffs":[[0,"ght="],[-1,"44 "],[1,"104"],[0,"\n   "]],"start1":3374,"start2":3374,"length1":11,"length2":11},{"diffs":[[0,"ck=\""],[-1,"StartRecordingECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;"],[1,"record EKG in background\"\n    export function set_ekg() {"],[0,"\n   "]],"start1":3393,"start2":3393,"length1":137,"length2":65},{"diffs":[[0,"igitalPin.P8, 0)"],[1,";"],[0,"\n        pins.di"]],"start1":3485,"start2":3485,"length1":32,"length2":33},{"diffs":[[0,"n.P9, 1)"],[1,";"],[0,"\n       "]],"start1":3541,"start2":3541,"length1":16,"length2":17},{"diffs":[[0,"    "],[-1,"if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }"],[1,"signal_label = \"EKG\";\n    }\n"],[0,"\n    "],[-1,"}\n"],[1,"/**"],[0,"\n    "],[-1,"/**\n * Start r"],[1," * R"],[0,"ecord"],[-1,"ing"],[0," EEG "],[-1,"signal\n"],[1,"in background\n    "],[0," */\n"]],"start1":3555,"start2":3555,"length1":174,"length2":81},{"diffs":[[0," group=\""],[-1,"Initialization"],[1,"Signal"],[0,"\"\n    //"]],"start1":3644,"start2":3644,"length1":30,"length2":22},{"diffs":[[0,"ght="],[-1,"43 "],[1,"103"],[0,"\n   "]],"start1":3671,"start2":3671,"length1":11,"length2":11},{"diffs":[[0,"ck=\""],[-1,"StartRecordingEEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;"],[1,"record ECG in background\"\n    export function set_eeg() {"],[0,"\n   "]],"start1":3690,"start2":3690,"length1":137,"length2":65},{"diffs":[[0,"alPin.P8, 0)"],[1,";"],[0,"\n        pin"]],"start1":3786,"start2":3786,"length1":24,"length2":25},{"diffs":[[0,"n.P9, 0)"],[1,";"],[0,"\n       "]],"start1":3838,"start2":3838,"length1":16,"length2":17},{"diffs":[[0,"    "],[-1,"if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }"],[1,"signal_label = \"EEG\";\n    }\n"],[0,"\n\n  "]],"start1":3852,"start2":3852,"length1":134,"length2":36},{"diffs":[[0,"sure"],[-1,"d value of the signal"],[1,"ment"],[0,"\n   "]],"start1":3916,"start2":3916,"length1":29,"length2":12},{"diffs":[[0," //% group=\""],[-1,"Raw data"],[1,"Signal"],[0,"\"\n    //% we"]],"start1":3937,"start2":3937,"length1":32,"length2":30},{"diffs":[[0," weight="],[-1,"4"],[1,"10"],[0,"2\n    //"]],"start1":3964,"start2":3964,"length1":17,"length2":18},{"diffs":[[0," block=\""],[-1,"getSignal"],[1,"return last measurement"],[0,"\"\n    ex"]],"start1":3983,"start2":3983,"length1":25,"length2":39},{"diffs":[[0,"unction "],[-1,"getSignal"],[1,"last_measurement"],[0,"(): numb"]],"start1":4028,"start2":4028,"length1":25,"length2":32},{"diffs":[[0,"    "],[-1,"if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */"],[1,"return neurobit_buffer[neurobit_read_index];\n    }"],[0,"\n\n  "]],"start1":4069,"start2":4069,"length1":205,"length2":58},{"diffs":[[0,"up=\""],[-1,"Raw data"],[1,"Signal"],[0,"\"\n  "]],"start1":4136,"start2":4136,"length1":16,"length2":14},{"diffs":[[0,"ght="],[-1,"41 "],[1,"101"],[0,"\n   "]],"start1":4159,"start2":4159,"length1":11,"length2":11},{"diffs":[[0,"ck=\""],[-1,"getB"],[1,"return b"],[0,"uffer "],[-1,"|| of"],[1,"from"],[0," last $"],[-1,"ms ("],[1,"duration "],[0,"ms"],[-1,")"],[0,"\"\n  "]],"start1":4178,"start2":4178,"length1":37,"length2":44},{"diffs":[[0,"    //% "],[-1,"ms"],[1,"duration"],[0,".shadow="]],"start1":4220,"start2":4220,"length1":18,"length2":24},{"diffs":[[0,"//% "],[-1,"ms"],[1,"duration"],[0,".defl"],[-1," = 5"],[1,"=1"],[0,"000\n"]],"start1":4259,"start2":4259,"length1":19,"length2":23},{"diffs":[[0,"ion "],[-1,"getBuffer(ms"],[1,"last_buffer(duration"],[0,": nu"]],"start1":4298,"start2":4298,"length1":20,"length2":28},{"diffs":[[0,"    let "],[-1,"required"],[1,"copy"],[0,"_size = "]],"start1":4348,"start2":4348,"length1":24,"length2":20},{"diffs":[[0,"ath."],[-1,"ceil((FS * (ms / 1000.0)));;\n\n        if (required_size > MAX_BUFFER_SIZE || read_index > MAX_BUFFER_SIZE - 1) {\n            return [-1]; // Error: required_size exceeds buffer size or unknown index\n        }\n        else {\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }"],[1,"floor(neurobit_buffer_size / (time_range / duration))\n        let copy = neurobit_buffer;\n        return copy;"],[0,"\n    }\n\n"],[1,"\n"],[0,"    "]],"start1":4369,"start2":4369,"length1":877,"length2":127},{"diffs":[[0,"    "],[-1,"    * Return last envelope value\n    "],[1,"* Apply envelope to signal by initializing this block at the top of the code,\n"],[0,"    "]],"start1":4501,"start2":4501,"length1":45,"length2":86},{"diffs":[[0," //% group=\""],[-1,"Processed data"],[1,"Signal"],[0,"\"\n    //% we"]],"start1":4595,"start2":4595,"length1":38,"length2":30},{"diffs":[[0," weight="],[-1,"4"],[1,"10"],[0,"0\n    //"]],"start1":4622,"start2":4622,"length1":17,"length2":18},{"diffs":[[0," block=\""],[-1,"getEnvelope"],[1,"apply envelope to signal"],[0,"\"\n    ex"]],"start1":4641,"start2":4641,"length1":27,"length2":40},{"diffs":[[0,"ion "],[-1,"getE"],[1,"e"],[0,"nvel"]],"start1":4691,"start2":4691,"length1":12,"length2":9},{"diffs":[[0,"velope()"],[-1,": number"],[0," {\n     "]],"start1":4697,"start2":4697,"length1":24,"length2":16},{"diffs":[[0,"    "],[-1,"return "],[1,"apply_"],[0,"envelope"],[-1,"Val"],[1," = tr"],[0,"ue;\n"]],"start1":4712,"start2":4712,"length1":26,"length2":27},{"diffs":[[0," = true;\n    }\n\n"],[1,"\n"],[0,"    /**\n        "]],"start1":4730,"start2":4730,"length1":32,"length2":33},{"diffs":[[0,"    "],[-1,"    * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return 0;\n    }\n\n    //% group=\"Processed data\"\n    //% weight=37\n    //% block=\"\""],[1,"* Choose the signal to print in Serial. \n     * You can also specify the specific time to run the printing. \n     * The default loops.\n     * @param signal = choose electrophysiology\n     * @param duration (optional) = duration(ms) to output the signal. If user does not provide one, then loops\n     */"],[0,"\n\n  "]],"start1":4756,"start2":4756,"length1":470,"length2":310},{"diffs":[[0,"ck=\""],[-1,"P"],[1,"p"],[0,"rint "],[-1,"$shape "],[0,"sign"]],"start1":5115,"start2":5115,"length1":21,"length2":14},{"diffs":[[0,"ignal ||"],[1," "],[0,"for $dur"]],"start1":5126,"start2":5126,"length1":16,"length2":17},{"diffs":[[0,"ion "],[-1,"("],[0,"ms"],[-1,")\"\n    //% shape.defl = 0"],[1,"\""],[0,"\n   "]],"start1":5145,"start2":5145,"length1":36,"length2":11},{"diffs":[[0,"int("],[-1,"shape: SignalShape, "],[0,"dura"]],"start1":5274,"start2":5274,"length1":28,"length2":8},{"diffs":[[0,"if ("],[-1,"shape == SignalShape.ENVELOPE"],[1,"apply_envelope"],[0,") {\n"]],"start1":5446,"start2":5446,"length1":37,"length2":22},{"diffs":[[0,"in the signal + "],[-1,"set"],[1,"make"],[0," baseline to 0\n "]],"start1":5495,"start2":5495,"length1":35,"length2":36},{"diffs":[[0,"ake baseline to "],[1,"be "],[0,"0\n              "]],"start1":5512,"start2":5512,"length1":32,"length2":35},{"diffs":[[0,"et signal = "],[-1,"getSignal"],[1,"last_measurement"],[0,"() - 512;\n  "]],"start1":5554,"start2":5554,"length1":33,"length2":40},{"diffs":[[0,"th.abs(signal);\n"],[1,"                    "],[0,"\n               "]],"start1":5679,"start2":5679,"length1":32,"length2":52},{"diffs":[[0,"gnal_label, "],[-1,"getSignal"],[1,"last_measurement"],[0,"());\n       "]],"start1":5971,"start2":5971,"length1":33,"length2":40},{"diffs":[[0,"e {\n"],[-1,"            let debug_count = 0;\n"],[0,"    "]],"start1":6117,"start2":6117,"length1":41,"length2":8},{"diffs":[[0,"if ("],[-1,"shape == SignalShape.ENVELOPE"],[1,"apply_envelope"],[0,") {\n"]],"start1":6241,"start2":6241,"length1":37,"length2":22},{"diffs":[[0,"ignal + "],[-1,"set"],[1,"make"],[0," baselin"]],"start1":6298,"start2":6298,"length1":19,"length2":20},{"diffs":[[0,"line to "],[1,"be "],[0,"0\n      "]],"start1":6315,"start2":6315,"length1":16,"length2":19},{"diffs":[[0,"ignal = "],[-1,"getSignal"],[1,"last_measurement"],[0,"() - 512"]],"start1":6353,"start2":6353,"length1":25,"length2":32},{"diffs":[[0,"    "],[-1,"debug_count++"],[1,"serial.writeValue(signal_label, last_measurement());\n                }\n            }\n        }\n    }\n\n\n\n\n    // export function eeg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function emg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function ecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P1);\n    // }\n\n    // export function eog(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // /**\n    //  * Return the maximum threshold from some time intervals(ms).\n    //  * As an optional argument, you can change the percentage of threshold\n    //  * to be returned. The defaulut is 100(%).\n    //  * @param ms = duration(ms) to run the get and caluculate max theshold.\n    //  * @param percent (optional) = number as percentage of threshold to be returned. The default is 100%.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=46\n    // //% block=\"get threshold from $ms ms || and return with $percent percent\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.shadow=timePicker\n    // //% percent.defl=100\n    // export function getThreshold(ms: number, percent?: number) {\n    //     const startTimer = control.millis();\n    //     let val = 0;\n    //     let max_val = 0;\n\n    //     while (control.millis() - startTimer < ms) {\n    //         val = emg();\n\n    //         if (max_val < val) {\n    //             max_val = val;\n    //         }\n    //     }\n\n    //     return max_val * (percent / 100);\n    // }\n\n\n    // /**\n    //  * Return the number of spikes that happened during some duration(ms).\n    //  * You can also change the duration but the default is 3000 (i.e. 3 seconds).\n    //  * If you grip tight for minimum 500ms (then release), \n    //  * it will return as -1. \n    //  * @param ms = duration(ms) to run the spike recording.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=45\n    // //% block=\"count spikes for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% ms.defl=3000\n    // export function countSpikes(ms: number) {\n    //     const down_sample_fs = 200;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0;\n    //     let elapsed_time2 = 0;\n\n    //     const buffer_size = 20;\n    //     let buffer: number[] = [];\n\n    //     // Smoothing function for signal\n    //     function movingAverage(data: number[], windowSize: number): number {\n    //         let sum = 0.0;\n    //         let smoothedData = 0;\n    //         //overflow -> floating point\n    //         for (let j = 0; j < windowSize; j++) {\n    //             sum += data[j]"],[0,";\n    "],[1,"//"],[0,"    "]],"start1":6722,"start2":6722,"length1":27,"length2":2664},{"diffs":[[0,"    "],[-1,"       serial.writeValue(signal_label, getSignal()"],[1,"}\n    //         smoothedData = sum / windowSize;\n    //         return smoothedData;\n    //     }\n\n    //     const threshold = 150;\n    //     const interval = 500;\n    //     let signal = 0;\n    //     let smooth_signal = 0;\n    //     let counter = 0;\n    //     let checking = false;\n    //     let check_time = -interval;\n    //     let check_grip = false;\n\n    //     const startTimer = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Begin Timer\n    //     while (control.millis() - startTimer < ms) {\n    //         signal = emg();\n\n    //         // Fill the buffer before the main process\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // Once the buffer fills up, shift\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Smooth out the signal\n    //             smooth_signal = movingAverage(buffer, buffer.length);\n\n    //             // Check the signal above threshold\n    //             let sample_time2 = input.runningTimeMicros();\n    //             while (smooth_signal > threshold) {\n    //                 signal = emg();\n\n    //                 buffer.shift();\n    //                 buffer.push(signal);\n\n    //                 smooth_signal = movingAverage(buffer, buffer.length);\n\n    //                 if (!checking) {\n    //                     // Record the time when the spike is detected\n    //                     // for only once at the beggining during the rising\n    //                     check_time = control.millis();\n    //                     checking = true;\n    //                 }\n\n    //                 // Checking for grip\n    //                 check_grip = true;\n\n    //                 elapsed_time2 = input.runningTimeMicros() - sample_time2;\n\n    //                 if (elapsed_time2 < period) {\n    //                     control.waitMicros(period - elapsed_time2);\n    //                 }\n\n    //                 sample_time2 = input.runningTimeMicros();\n    //             }\n\n    //             // Once signl drops down below the threshold, allow \n    //             // check (for spike) to happen\n    //             checking = false;\n\n    //             // Check if the spike is within the interval window\n    //             // to reduce false positives\n    //             if (control.millis() - check_time < interval) {\n    //                 check_grip = false;\n    //                 counter++; // Increment counter for detected spikes\n    //                 check_time = -interval; // Reset check time\n    //             }\n\n    //             // If the signal goes over one second, assume due to\n    //             // the grip\n    //             if (check_grip) {\n    //                 counter = -1;\n    //             }\n\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return counter; // Return the spike count\n    // }\n\n\n    // /**\n    //  * Give the reaction time from certain cue. User have options to\n    //  * choose either from visual (Heart Icon) or audio (1/2 beat) cue\n    //  * with given threshold. \n    //  * @param cue (optional) = options for user to choose type of cue (visually or auditory). The default is none.\n    //  * @param threshold (optional) = user have option to select their desired threshold. The default is 200.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=44\n    // //% block=\"measure reaction time ||add cue $cue add threshold $threshold\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% threshold.defl=200\n    // //% inlineInputMode=inline\n    // export function reactionTime(cue?: Cue, threshold?: number) {\n    //     const cue_time = 100; // [ms]\n    //     const ms = 1500; // Give user 1.5 seconds to make reaction\n    //     let signal = 0;\n    //     let result = ms;\n    //     let once = true;\n\n    //     //At beggining, give user a cue if needed\n    //     switch (cue) {\n    //         case Cue.none: {\n    //             break;\n    //         }\n    //         case Cue.visual: {\n    //             basic.showIcon(IconNames.Heart, cue_time);\n    //             basic.clearScreen();\n    //             break;\n    //         }\n    //         case Cue.audio: {\n    //             pins.setAudioPin(AnalogPin.P16);\n    //             music.play(music.tonePlayable(262, cue_time),\n    //                 music.PlaybackMode.InBackground);\n    //             break;\n    //         }\n    //     }\n\n    //     const startTime = control.millis();\n\n    //     // Begin measuring the reaction time\n    //     while (control.millis() - startTime < ms) {\n    //         signal = emg();\n    //         // (only once) if the signal go above the threshold,\n    //         // save the reaction time. \n    //         if (signal > threshold && once) {\n    //             result = control.millis() - startTime;\n    //             once = false;\n    //         }\n    //     }\n\n    //     // If user fails to react, return as undefined (question mark)\n    //     if (result == ms) {\n    //         return undefined;\n    //     }\n    //     else {\n    //         return result;\n    //     }\n    // }\n\n\n    // /**\n    //  * Return the average heart beat (bpm) in 5 seconds(default).\n    //  * You can also change the time for recording from \n    //  * optional argument.\n    //  * @param ms (optional) = duration(ms) to run the hearbeat recording. The default is 5000 (i.e. 5 seconds).\n    //  */\n\n    // //% group=\"ECG\"\n    // //% weight=43\n    // //% block=\"measure heartbeat (bpm) || for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=5000\n    // export function heartBeat(ms: number) {\n    //     const down_sample_fs = 150 //Hz;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0\n\n    //     const range = 300;\n    //     const buffer_size = 6;\n    //     let buffer: number[] = [];\n    //     // let buffer_index = 0;\n    //     let beat_num = 0;\n    //     let unit = 0;\n    //     let sum_unit = 0;\n    //     let wait = 0;\n    //     let last_beat = 0;\n\n\n    //     // Fill the buffer first\n    //     for (let i = 0; i < buffer_size; i++) {\n    //         buffer.push(ecg());\n    //     }\n\n    //     const startTime = control.millis();\n    //     let prev_beat = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - startTime < ms) {\n    //         if (wait <= 0) {\n\n    //             // Buffer minimum, maximum calculation\n    //             let buffer_min = buffer[0];\n    //             let buffer_max = buffer[0];\n\n    //             for (let i = 1; i < buffer_size; i++) {\n    //                 if (buffer_min > buffer[i]) {\n    //                     buffer_min = buffer[i];\n    //                 }\n\n    //                 if (buffer_max < buffer[i]) {\n    //                     buffer_max = buffer[i];\n    //                 }\n    //             }\n\n    //             // If the range of buffer is greator than certain range,\n    //             // do heartbeat caluculation\n    //             if (buffer_max - buffer_min > range) {\n    //                 basic.showIcon(IconNames.Heart, 150);\n    //                 basic.clearScreen();\n    //                 last_beat = control.millis() - prev_beat;\n    //                 prev_beat = control.millis();\n    //                 let largeBox = Math.floor(last_beat / 200);\n    //                 let smallBox = Math.floor((last_beat - largeBox * 200) / 40);\n    //                 unit = 1 * largeBox + 0.2 * smallBox;\n    //                 sum_unit += unit;\n    //                 beat_num++;\n    //                 // Wait for buffer_size * 3. \n    //                 // This is possible because distance between\n    //                 // human heart beat is no smaller than time for\n    //                 // buffer_size * 3 samples\n    //                 wait = buffer_size * 3;\n    //             }\n    //         }\n\n\n    //         // May need to use shift\n    //         buffer.shift();\n    //         buffer.push(ecg());\n    //         // buffer[buffer_index] = val;\n    //         // buffer_index = (buffer_index + 1) % buffer_size;\n    //         wait--;\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time)\n    //         }\n\n    //         sample_time = input.runningTimeMicros()\n    //     }\n\n    //     // Check to avoid division by zero\n    //     return beat_num > 0 ? 300 / (sum_unit / beat_num) : undefined;\n    // }\n\n\n    // let currently_up = false;\n    // let currently_down = false;\n    // let center_UD = false;\n    // let cooldown_counter = 0;\n    // let blink_buffer: number[] = [];\n    // let updown_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (up/down/blink) if user move their eyes in\n    //  * vertical direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=42\n    // //% block=\"direction (VEOG)\"\n    // export function gazeV(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50; // [Hz]\n    //     const period = 1000000 / down_sample_fs; // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     const wait_size = Math.floor(down_sample_fs / 3); // 1/3 of second\n    //     let avgBuffer = 0;\n\n    //     let slope = 0;\n    //     const cooldown_period = wait_size + buffer_size;\n\n    //     // Function to return the averge slope of buffer\n    //     function calculateSlope(data: number[]): number {\n    //         const n = data.length;\n    //         let xSum = 0;\n    //         let ySum = 0;\n    //         let xySum = 0;\n    //         let xSquaredSum = 0;\n\n    //         for (let x = 0; x < n; x++) {\n    //             xSum += x;\n    //             ySum += data[x];\n    //             xySum += x * data[x];\n    //             xSquaredSum += x * x;\n    //         }\n\n    //         return (n * xySum - xSum * ySum) / (n * xSquaredSum - xSum * xSum);\n    //     }\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // Shift the buffer so blink analysis happens eariler than\n    //         // up or down analysis\n    //         if (blink_buffer.length < wait_size) {\n    //             blink_buffer.push(signal);\n    //         } else {\n    //             if (updown_buffer.length < buffer_size) {\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             } else {\n    //                 updown_buffer.shift();\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             }\n\n    //             blink_buffer.push(signal);\n    //         }\n\n    //         if (updown_buffer.length == buffer_size) {\n    //             slope = calculateSlope(blink_buffer.slice(0, buffer_size));\n    //             avgBuffer = updown_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Blinking\n    //             if (slope < -75) {\n    //                 // Begin cool down\n    //                 cooldown_counter = 0;\n    //                 result = LookingAt.blink;\n    //             }\n\n    //             // If cooldown is happening\n    //             if (cooldown_counter >= cooldown_period) {\n    //                 // Looking Up\n    //                 if (avgBuffer > baseline * 1.40) {\n    //                     if (currently_down) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.up;\n    //                         center_UD = false;\n    //                         currently_up = true;\n    //                     }\n    //                     // Looking Down \n    //                 } else if (avgBuffer < baseline * 0.60) {\n    //                     if (currently_up) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.down;\n    //                         center_UD = false;\n    //                         currently_down = true;\n    //                     }\n    //                 } else {\n    //                     if (center_UD) {\n    //                         currently_up = false;\n    //                         currently_down = false;\n    //                     }\n    //                 }\n    //             } else {\n    //                 cooldown_counter++;\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time"],[0,");\n    "],[1,"//"],[0,"       "],[1,"  }\n\n    //         sample_time = input.runningTimeMicros();\n    //"],[0,"     }\n"],[1,"\n"],[0,"    "],[1,"//"],[0,"     "],[-1,"   }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}"],[1,"return result;\n\n    // }\n\n\n    // let currently_left = false;\n    // let currently_right = false;\n    // let center_LR = false;\n    // let leftright_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (left/right) if user move their eyes in\n    //  * horizontal direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=41\n    // //% block=\"direction (HEOG)\"\n    // export function gazeH(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50 // [Hz]\n    //     const period = 1000000 / down_sample_fs // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     let avgBuffer = 0;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (leftright_buffer.length < buffer_size) {\n    //             leftright_buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (leftright_buffer.length == buffer_size) {\n    //             leftright_buffer.shift();\n    //             leftright_buffer.push(signal);\n\n    //             // Calculate average of buffer\n    //             avgBuffer = leftright_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Looking Left\n    //             if (avgBuffer > baseline * 1.25) {\n    //                 if (currently_right) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_left = true;\n    //                     result = LookingAt.left;\n    //                 }\n    //             }\n    //             // Looking Right\n    //             else if (avgBuffer < baseline * 0.75) {\n    //                 if (currently_left) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_right = true;\n    //                     result = LookingAt.right;\n    //                 }\n    //             }\n    //             else {\n    //                 if (center_LR) {\n    //                     currently_left = false;\n    //                     currently_right = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return result;\n\n    // }\n\n\n    // /**\n    //  * Return true if user blinks within some time, false otherwise.\n    //  * Defining time is optional argument (the default is one second). \n    //  * @param ms (optional) = duration(ms) to check blink. The default is 1000 (i.e 1 seconds).\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=40\n    // //% block=\"blinked|| within $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=1000\n    // export function blinks(ms?: number): boolean {\n    //     const down_sample_fs = 50 //[Hz]\n    //     const period = 1000000 / down_sample_fs //[μs/hz]\n    //     let elapsed_time = 0;\n\n    //     const buffer_size = 2;\n    //     let buffer = [];\n\n    //     const threshold = 40;\n    //     const blink_time = 300; //[ms]\n\n    //     let blink_check_timer = 0;\n    //     let start_val = 0;\n    //     let currently_checking = false;\n\n    //     let exit = false;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep calculating until \n    //     // 1). time runs out\n    //     // 2). user blinked\n    //     while (control.millis() - start_time < ms && !exit) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Do the following only when first point and second point \n    //             // differs by more than threshold\n    //             if (Math.abs(buffer[0] - buffer[1]) > threshold) {\n    //                 if (!currently_checking && buffer[1] > buffer[0]) {\n    //                     blink_check_timer = control.millis();\n    //                     start_val = buffer[0];\n    //                     currently_checking = true;\n    //                 }\n\n    //                 if (control.millis() - blink_check_timer < blink_time) {\n    //                     if (buffer[0] < start_val) {\n    //                         currently_checking = false;\n    //                         exit = true;\n    //                     }\n    //                 }\n    //                 else {\n    //                     currently_checking = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return exit;\n\n    // }\n\n\n    // /**\n    //  * Looking Up (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=39\n    // //% block=\"up\"\n    // export function up(): number {\n    //     return LookingAt.up;\n    // }\n\n\n    // /**\n    //  * Looking Down (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=38\n    // //% block=\"down\"\n    // export function down(): number {\n    //     return LookingAt.down;\n    // }\n\n\n    // /**\n    //  * Looking Left (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=37\n    // //% block=\"left\"\n    // export function left(): number {\n    //     return LookingAt.left;\n    // }\n\n\n    // /**\n    //  * Looking Right (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=36\n    // //% block=\"right\"\n    // export function right(): number {\n    //     return LookingAt.right;\n    // }\n\n\n    // /**\n    //  * Blink (use with VEOG direction)\n    // */\n\n    // //% group=\"EOG\"\n    // //% weight=35\n    // //% block=\"blink\"\n    // export function blink(): number {\n    //     return LookingAt.blink;\n    // }\n\n\n    \n\n    // /**\n    //  * Set the angle for servo.\n    //  * @param angle = the angle for servo (in degree)\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=28\n    // //% block=\"set servo to $angle degrees\"\n    // export function servo_control(angle: number) {\n    //     pins.servoWritePin(AnalogPin.P0, angle);\n    // }\n\n\n    // /**\n    //  * Pause the program from running until user defined time(ms) pass.\n    //  * If the user provided second argument, pause the program for\n    //  * randomized time between the first input to second input \n    //  *(both inclusinve).\n    //  * @param start = time to pause program. \n    //  * @param end (optional) = use start and end to as range to pick the random time. The default is 0.\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=27\n    // //% block=\"Wait for $start (ms) || $end (ms)\"\n    // //% start.shadow=timePicker\n    // //% end.shadow=timePicker\n    // //% wait.defl=0;\n    // export function wait(start: number, end?: number) {\n    //     let waiting_time = 0;\n\n    //     // If user provides the second argument, choose random time,\n    //     // to wait, else set the the first argument.\n    //     if (end > 0 && end > start) {\n    //         waiting_time = randint(start, end);\n    //     }\n    //     else {\n    //         waiting_time = start;\n    //     }\n\n    //     // Run while loop for some duration\n    //     const start_time = control.millis();\n    //     while (control.millis() - start_time < waiting_time) {\n    //         continue;\n    //     }\n    // }\n\n}\n"]],"start1":9387,"start2":9387,"length1":151,"length2":22003}]}]},{"timestamp":1727201740247,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"neurobit.envelope()\nneurobit.set_emg()\nneurobit.print()\n"]],"start1":0,"start2":0,"length1":0,"length2":56}]}]},{"timestamp":1727201746837,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"0;\n    }"],[-1,"\n    "],[0,"\n\n    //"]],"start1":8119,"start2":8119,"length1":21,"length2":16},{"diffs":[[0,"up=\""],[-1,"Experiments helper\"\n    //% weight=46\n    //% block=\"returnMaxSignal|| from $ms ms || percentage ()\"\n    //% expandableArgumentMode=\"enable\"\n    //% ms.shadow=timePicker\n    //% percent.defl=100\n    export function getThreshold(ms: number, percent?: number) {\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n\n        while (control.millis() - startTimer < ms) {\n            val = emg();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n        }\n\n        return max_val * (percent / 100);\n    }"],[1,"Processed data\"\n    //% weight=37\n    //% block=\"\""],[0,"\n\n  "]],"start1":8140,"start2":8140,"length1":575,"length2":58}]}]},{"timestamp":1727202343500,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"    "],[-1,"if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n        }\n        else {\n            return -1;\n        }"],[1,"return envelopeValue;"],[0,"\n   "]],"start1":7686,"start2":7686,"length1":362,"length2":29},{"diffs":[[0,"rn 0;\n    }\n"],[1,"    "],[0,"\n\n    //% gr"]],"start1":8116,"start2":8116,"length1":24,"length2":28},{"diffs":[[0,"urnMaxSi"],[-1,"n"],[0,"g"],[1,"n"],[0,"al|| fro"]],"start1":8205,"start2":8205,"length1":18,"length2":18},{"diffs":[[0," || "],[-1,"multiply by $constant"],[1,"percentage ()"],[0,"\"\n  "]],"start1":8231,"start2":8231,"length1":29,"length2":21},{"diffs":[[0,"t.defl=1"],[1,"00"],[0,"\n    exp"]],"start1":8333,"start2":8333,"length1":16,"length2":18},{"diffs":[[0,"tion get"],[-1,"MaxSignal"],[1,"Threshold"],[0,"(ms: num"]],"start1":8359,"start2":8359,"length1":25,"length2":25},{"diffs":[[0,"number, "],[-1,"consta"],[1,"perce"],[0,"nt?: num"]],"start1":8381,"start2":8381,"length1":22,"length2":21},{"diffs":[[0," number)"],[-1,": number"],[0," {\n     "]],"start1":8398,"start2":8398,"length1":24,"length2":16},{"diffs":[[0,"0;\n\n"],[-1,"        // unknown constant\n        if (constant < 0) {\n            return -1;\n        }\n\n"],[0,"    "]],"start1":8497,"start2":8497,"length1":98,"length2":8},{"diffs":[[0,"  val = "],[-1,"getEnvelope"],[1,"emg"],[0,"();\n\n   "]],"start1":8564,"start2":8564,"length1":27,"length2":19},{"diffs":[[0,"   }"],[-1,"\n\n            serial.writeLine(\"\");"],[0,"\n   "]],"start1":8653,"start2":8653,"length1":43,"length2":8},{"diffs":[[0,"l * "],[-1,"constant"],[1,"(percent / 100)"],[0,";\n  "]],"start1":8690,"start2":8690,"length1":16,"length2":23}]}]},{"timestamp":1727202940432,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," weight="],[-1,"30"],[1,"46"],[0,"\n    //%"]],"start1":8505,"start2":8505,"length1":18,"length2":18},{"diffs":[[0," block=\""],[-1,"g"],[1,"r"],[0,"et"],[1,"urn"],[0,"MaxSinga"]],"start1":8523,"start2":8523,"length1":19,"length2":22},{"diffs":[[0,"om $"],[-1,"duration (ms) times"],[1,"ms ms || multiply"],[0," by "]],"start1":8551,"start2":8551,"length1":27,"length2":25},{"diffs":[[0,"de=\""],[-1,"togg"],[1,"enab"],[0,"le\"\n"]],"start1":8615,"start2":8615,"length1":12,"length2":12},{"diffs":[[0,"le\"\n    //% "],[-1,"duration"],[1,"ms"],[0,".shadow=time"]],"start1":8623,"start2":8623,"length1":32,"length2":26},{"diffs":[[0,"ker\n"],[-1,"    //% duration.defl=0\n"],[0,"    "]],"start1":8652,"start2":8652,"length1":32,"length2":8},{"diffs":[[0,"xSignal("],[-1,"duration"],[1,"ms"],[0,": number"]],"start1":8704,"start2":8704,"length1":24,"length2":18},{"diffs":[[0,"constant"],[1,"?"],[0,": number"]],"start1":8724,"start2":8724,"length1":16,"length2":17},{"diffs":[[0,"0;\n\n"],[-1,"        if ()\n"],[0,"    "]],"start1":8841,"start2":8841,"length1":22,"length2":8},{"diffs":[[0,"Timer < "],[-1,"duration"],[1,"ms"],[0,") {\n    "]],"start1":8974,"start2":8974,"length1":24,"length2":18},{"diffs":[[0," weight="],[-1,"2"],[1,"3"],[0,"0\n    //"]],"start1":9217,"start2":9217,"length1":17,"length2":17}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," y=\"0\"><"],[1,"statement name=\"HANDLER\"><block type=\"neurobit_envelope\"><next><block type=\"neurobit_set_emg\"><next><block type=\"neurobit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation></block></next></block></next></block></statement><"],[0,"/block><"]],"start1":110,"start2":110,"length1":16,"length2":287}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"\n"]],"start1":0,"start2":0,"length1":1,"length2":0}]}]},{"timestamp":1727203538748,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"    "],[-1,"if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [-1];\n        }\n        else {"],[1,"let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n        if (required_size > MAX_BUFFER_SIZE || read_index > MAX_BUFFER_SIZE - 1) {\n            return [-1]; // Error: required_size exceeds buffer size or unknown index"],[0,"\n   "]],"start1":6604,"start2":6604,"length1":164,"length2":231},{"diffs":[[0,"    "],[1,"}\n"],[0,"    "],[-1,"let required_size = Math.ceil((FS * (ms / 1000.0)));;\n"],[1,"    else {"],[0,"\n   "]],"start1":6836,"start2":6836,"length1":66,"length2":24},{"diffs":[[0,"if ("],[-1,"duration == 0) {\n            let copy_buffer = getBuffer(TIME_RANGE);\n            \n        }\n        "],[1,")\n        // unknown constant"],[0,"\n   "]],"start1":8887,"start2":8887,"length1":109,"length2":37}]}]},{"timestamp":1727204081839,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"\"get"],[-1," max s"],[1,"MaxS"],[0,"ingal"],[1,"||"],[0," fro"]],"start1":8505,"start2":8505,"length1":19,"length2":19},{"diffs":[[0,"ms) "],[-1,"|| *"],[1,"times by"],[0," $co"]],"start1":8537,"start2":8537,"length1":12,"length2":16},{"diffs":[[0,"    //% "],[-1,"consta"],[1,"perce"],[0,"nt.defl="]],"start1":8660,"start2":8660,"length1":22,"length2":21},{"diffs":[[0,"r {\n"],[-1,"        if (duration < 0 || constant < 0) {\n            return -1;\n        }\n\n"],[0,"    "]],"start1":8758,"start2":8758,"length1":86,"length2":8},{"diffs":[[0,"al = 0;\n"],[1,"\n"],[0,"        "],[1,"if (duration == 0) {\n            let copy_buffer = getBuffer(TIME_RANGE);\n            \n        }\n        \n        if (constant < 0) {\n            return -1;\n        }\n"],[0,"\n       "]],"start1":8845,"start2":8845,"length1":24,"length2":192}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"es><"],[-1,"variable id=\"9{I/khZtdn6+^=f;JpL#\">threshold</variable></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"neurobit_startRecordingEMG\"><next><block type=\"variables_set\"><field name=\"VAR\" id=\"9{I/khZtdn6+^=f;JpL#\">threshold</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow></value></block></next></block></statement"],[1,"/variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\""],[0,"></b"]],"start1":63,"start2":63,"length1":401,"length2":57}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"neurobit.startRecordingEMG()\nlet threshold = 0"],[0,"\n"]],"start1":0,"start2":0,"length1":47,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727204681051,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"leArgumentMode=\""],[-1,"enab"],[1,"togg"],[0,"le\"\n    //% dura"]],"start1":8573,"start2":8573,"length1":36,"length2":36},{"diffs":[[0,"on.defl="],[-1,"100"],[0,"0\n    //"]],"start1":8646,"start2":8646,"length1":19,"length2":16},{"diffs":[[0,"constant"],[-1,"?"],[0,": number"]],"start1":8731,"start2":8731,"length1":17,"length2":16},{"diffs":[[0," }\n\n"],[-1,"    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"count spikes during $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl=3000\n    export function countSpikes(ms: number) {\n        const down_sample_fs = 200;\n        const period = 1000000 / down_sample_fs;\n        let elapsed_time = 0;\n        let elapsed_time2 = 0;\n\n        const buffer_size = 20;\n        let buffer: number[] = [];\n\n        const threshold = 150;\n        const interval = 500;\n        let signal = 0;\n        let smooth_signal = 0;\n        let counter = 0;\n        let checking = false;\n        let check_time = -interval;\n        let check_grip = false;\n\n        const startTimer = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Begin Timer\n        while (control.millis() - startTimer < ms) {\n            signal = getEnvelope();\n\n            // Fill the buffer before the main process\n            if (buffer.length < buffer_size) {\n                buffer.push(signal);\n            }\n\n            // Once the buffer fills up, shift\n            if (buffer.length == buffer_size) {\n                buffer.shift();\n                buffer.push(signal);\n\n                // Smooth out the signal\n                smooth_signal = movingAverage(buffer, buffer.length);\n\n                // Check the signal above threshold\n                let sample_time2 = input.runningTimeMicros();\n                while (smooth_signal > threshold) {\n                    signal = emg();\n\n                    buffer.shift();\n                    buffer.push(signal);\n\n                    smooth_signal = movingAverage(buffer, buffer.length);\n\n                    if (!checking) {\n                        // Record the time when the spike is detected\n                        // for only once at the beggining during the rising\n                        check_time = control.millis();\n                        checking = true;\n                    }\n\n                    // Checking for grip\n                    check_grip = true;\n\n                    elapsed_time2 = input.runningTimeMicros() - sample_time2;\n\n                    if (elapsed_time2 < period) {\n                        control.waitMicros(period - elapsed_time2);\n                    }\n\n                    sample_time2 = input.runningTimeMicros();\n                }\n\n                // Once signl drops down below the threshold, allow \n                // check (for spike) to happen\n                checking = false;\n\n                // Check if the spike is within the interval window\n                // to reduce false positives\n                if (control.millis() - check_time < interval) {\n                    check_grip = false;\n                    counter++; // Increment counter for detected spikes\n                    check_time = -interval; // Reset check time\n                }\n\n                // If the signal goes over one second, assume due to\n                // the grip\n                if (check_grip) {\n                    counter = -1;\n                }\n\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();\n        }\n\n        return counter; // Return the spike count\n    }\n\n"],[0,"    "]],"start1":9192,"start2":9192,"length1":3409,"length2":8}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"4"],[0,"0\" y=\""],[-1,"49"],[1,"0"],[0,"\"><s"]],"start1":160,"start2":160,"length1":17,"length2":15},{"diffs":[[0,"ber\""],[-1," disabled-reasons=\"MANUALLY_DISABLED\""],[0,"><fi"]],"start1":377,"start2":377,"length1":45,"length2":8},{"diffs":[[0,"ow><"],[-1,"block type=\"neurobit_getMaxSignal\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value><value name=\"constant\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value></block></value><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"9{I/khZtdn6+^=f;JpL#\">threshold</field></block></value></block></next"],[1,"/value"],[0,"></b"]],"start1":415,"start2":415,"length1":618,"length2":14}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"neurobit.startRecordingEMG()\nlet threshold = 0"],[0,"\n"]],"start1":0,"start2":0,"length1":1,"length2":47}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727205238411,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"                "],[-1,"//"],[0,"smooth_signal = "]],"start1":10421,"start2":10421,"length1":34,"length2":32},{"diffs":[[0,"        "],[-1,"//"],[0,"signal ="]],"start1":10670,"start2":10670,"length1":18,"length2":16},{"diffs":[[0,"        "],[-1,"//"],[0,"smooth_s"]],"start1":10785,"start2":10785,"length1":18,"length2":16}]}]},{"timestamp":1727205511541,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"unction "],[1,"countSpikes"],[0,"(ms: num"]],"start1":9360,"start2":9360,"length1":16,"length2":27}]}]},{"timestamp":1727206133898,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"unction "],[-1,"get"],[0,"(ms: num"]],"start1":9360,"start2":9360,"length1":19,"length2":16}]}]},{"timestamp":1727206134841,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," get"],[-1,"Spikes"],[0,"(ms:"]],"start1":9367,"start2":9367,"length1":14,"length2":8},{"diffs":[[0,"    "],[-1,"let elapsed_time = 0;\n        let elapsed_time2 = 0"],[1,"const down_sample_fs = 200;\n        const period = 1000000 / down_sample_fs;\n        let elapsed_time = 0;\n        let elapsed_time2 = 0;\n\n        const buffer_size = 20;\n        let buffer: number[] = []"],[0,";\n\n "]],"start1":9390,"start2":9390,"length1":59,"length2":212},{"diffs":[[0,"let signal = 0;\n"],[1,"        let smooth_signal = 0;\n"],[0,"        let coun"]],"start1":9670,"start2":9670,"length1":32,"length2":63},{"diffs":[[0,"illis();"],[1,"\n        let sample_time = input.runningTimeMicros();"],[0,"\n\n      "]],"start1":9877,"start2":9877,"length1":16,"length2":69},{"diffs":[[0,"elope();"],[1,"\n\n            // Fill the buffer before the main process\n            if (buffer.length < buffer_size) {\n                buffer.push(signal);\n            }\n\n            // Once the buffer fills up, shift\n            if (buffer.length == buffer_size) {\n                buffer.shift();\n                buffer.push(signal);\n\n                // Smooth out the signal\n                //smooth_signal = movingAverage(buffer, buffer.length);\n\n                // Check the signal above threshold\n                let sample_time2 = input.runningTimeMicros();\n                while (smooth_signal > threshold) {\n                    //signal = emg();\n\n                    buffer.shift();\n                    buffer.push(signal);\n\n                    //smooth_signal = movingAverage(buffer, buffer.length);\n\n                    if (!checking) {\n                        // Record the time when the spike is detected\n                        // for only once at the beggining during the rising\n                        check_time = control.millis();\n                        checking = true;\n                    }\n\n                    // Checking for grip\n                    check_grip = true;\n\n                    elapsed_time2 = input.runningTimeMicros() - sample_time2;\n\n                    if (elapsed_time2 < period) {\n                        control.waitMicros(period - elapsed_time2);\n                    }\n\n                    sample_time2 = input.runningTimeMicros();\n                }\n\n                // Once signl drops down below the threshold, allow \n                // check (for spike) to happen\n                checking = false;\n\n                // Check if the spike is within the interval window\n                // to reduce false positives\n                if (control.millis() - check_time < interval) {\n                    check_grip = false;\n                    counter++; // Increment counter for detected spikes\n                    check_time = -interval; // Reset check time\n                }\n\n                // If the signal goes over one second, assume due to\n                // the grip\n                if (check_grip) {\n                    counter = -1;\n                }\n\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();"],[0,"\n       "]],"start1":10043,"start2":10043,"length1":16,"length2":2495}]}]},{"timestamp":1727206727059,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," block=\""],[-1,"ge"],[1,"coun"],[0,"t spikes"]],"start1":9260,"start2":9260,"length1":18,"length2":20},{"diffs":[[0," spikes "],[-1,"from $duration"],[1,"during $ms"],[0," (ms)\"\n "]],"start1":9273,"start2":9273,"length1":30,"length2":26},{"diffs":[[0,"s)\"\n    //% "],[-1,"duration"],[1,"ms"],[0,".shadow=time"]],"start1":9294,"start2":9294,"length1":32,"length2":26},{"diffs":[[0,"ker\n    //% "],[-1,"duration"],[1,"ms"],[0,".defl=3000\n "]],"start1":9323,"start2":9323,"length1":32,"length2":26},{"diffs":[[0,"tSpikes("],[-1,"duration"],[1,"ms"],[0,": number"]],"start1":9370,"start2":9370,"length1":24,"length2":18},{"diffs":[[0,"(ms: number)"],[-1,": number"],[0," {\n        i"]],"start1":9377,"start2":9377,"length1":32,"length2":24},{"diffs":[[0,"    "],[-1,"if (duration < 0) {\n            return -1;\n        }\n"],[1,"let elapsed_time = 0;\n        let elapsed_time2 = 0;\n\n        const threshold = 150;"],[0,"\n   "]],"start1":9396,"start2":9396,"length1":61,"length2":92},{"diffs":[[0,"nst "],[-1,"THRESHOLD"],[1,"interval"],[0," = 50"],[1,"0"],[0,";"],[-1,"\n"],[0,"\n   "]],"start1":9495,"start2":9495,"length1":24,"length2":23},{"diffs":[[0,"   let check"],[-1,"_once"],[1,"ing = false;\n        let check_time = -interval;\n        let check_grip"],[0," = false;\n\n "]],"start1":9569,"start2":9569,"length1":29,"length2":95},{"diffs":[[0,"ontrol.millis();"],[1,"\n\n        // Begin Timer"],[0,"\n        while ("]],"start1":9691,"start2":9691,"length1":32,"length2":56},{"diffs":[[0,"r < "],[-1,"duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\""],[1,"ms) {\n            signal = getEnvelope("],[0,");\n "]],"start1":9775,"start2":9775,"length1":365,"length2":47}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"variable id=\"9{I/khZtdn6+^=f;JpL#\">threshold</variable><"],[0,"/variabl"]],"start1":59,"start2":59,"length1":16,"length2":72},{"diffs":[[0," x=\""],[-1,"33"],[1,"40"],[0,"\" y=\""],[-1,"50"],[1,"49"],[0,"\"><s"]],"start1":160,"start2":160,"length1":17,"length2":17},{"diffs":[[0,"pe=\""],[-1,"device_show_number\""],[1,"variables_set\"><field name=\"VAR\" id=\"9{I/khZtdn6+^=f;JpL#\">threshold</field"],[0,"><va"]],"start1":257,"start2":257,"length1":27,"length2":83},{"diffs":[[0,"e name=\""],[-1,"number"],[1,"VALUE"],[0,"\"><shado"]],"start1":342,"start2":342,"length1":22,"length2":21},{"diffs":[[0,"_number\""],[1," disabled-reasons=\"MANUALLY_DISABLED\""],[0,"><field "]],"start1":375,"start2":375,"length1":16,"length2":53},{"diffs":[[0,"_get"],[-1,"Spikes\""],[1,"MaxSignal\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation"],[0,"><va"]],"start1":478,"start2":478,"length1":15,"length2":109},{"diffs":[[0,"me=\"ms\">"],[-1,"3"],[1,"2"],[0,"000</fie"]],"start1":642,"start2":642,"length1":17,"length2":17},{"diffs":[[0,"ue><"],[-1,"/block></value"],[1,"value name=\"constant\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value></block></value><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"9{I/khZtdn6+^=f;JpL#\">threshold</field></block></value></block></next"],[0,"></b"]],"start1":676,"start2":676,"length1":22,"length2":396}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"neurobit.startRecordingEMG()\nbasic.showNumber(neurobit.getSpikes(3000))"],[0,"\n"]],"start1":0,"start2":0,"length1":72,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727207264870,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727211723405,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"umber\"><"],[1,"shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><"],[0,"block ty"]],"start1":239,"start2":239,"length1":16,"length2":79}]}]},{"timestamp":1727221691387,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727221691589,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"      }\n"],[-1,"        "],[0,"\n       "]],"start1":9473,"start2":9473,"length1":24,"length2":16}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"-34"],[1,"33"],[0,"\" y=\""],[-1,"131"],[1,"50"],[0,"\"><s"]],"start1":104,"start2":104,"length1":19,"length2":17},{"diffs":[[0,"r\"><"],[-1,"shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><"],[0,"bloc"]],"start1":243,"start2":243,"length1":71,"length2":8},{"diffs":[[0,"ck><"],[-1,"block type=\"device_pause\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"243\" y=\"237\"><value name=\"pause\"><shadow type=\"timePicker\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"ms\">5000</field></shadow></value></block><"],[0,"/xml"]],"start1":430,"start2":430,"length1":240,"length2":8}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727222293535,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"false;\n\n"],[-1,"        \n"],[0,"        "]],"start1":9595,"start2":9595,"length1":25,"length2":16}]}]},{"timestamp":1727222301184,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"r {\n"],[-1,"        basic.pause(10); //To avoid weird spike happen when turning on\n\n"],[0,"    "]],"start1":9416,"start2":9416,"length1":80,"length2":8},{"diffs":[[0,"e = false;\n\n"],[1,"        \n"],[0,"        cons"]],"start1":9591,"start2":9591,"length1":24,"length2":33}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"0"],[1,"-34"],[0,"\" y=\""],[-1,"0"],[1,"131"],[0,"\"><s"]],"start1":104,"start2":104,"length1":15,"length2":19},{"diffs":[[0,"umber\"><"],[1,"shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><"],[0,"block ty"]],"start1":241,"start2":241,"length1":16,"length2":79},{"diffs":[[0,"/block><"],[1,"block type=\"device_pause\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"243\" y=\"237\"><value name=\"pause\"><shadow type=\"timePicker\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"ms\">5000</field></shadow></value></block><"],[0,"/xml>"]],"start1":491,"start2":491,"length1":13,"length2":245}]}]},{"timestamp":1727222532435,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"1"],[0,"0\" y=\""],[-1,"1"],[0,"0\"><"]],"start1":104,"start2":104,"length1":16,"length2":14}]}]},{"timestamp":1727300617400,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727300617536,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[1,"1"],[0,"0\" y=\""],[1,"1"],[0,"0\"><"]],"start1":104,"start2":104,"length1":14,"length2":16},{"diffs":[[0,"pe=\""],[-1,"neurobit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field"],[1,"device_show_number\"><value name=\"number\"><block type=\"neurobit_getSpikes\""],[0,"><va"]],"start1":201,"start2":201,"length1":162,"length2":81},{"diffs":[[0,"ms\">"],[-1,"5"],[1,"3"],[0,"000<"]],"start1":341,"start2":341,"length1":9,"length2":9},{"diffs":[[0,"block></"],[1,"value></block></"],[0,"next></b"]],"start1":376,"start2":376,"length1":16,"length2":32}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"G()\n"],[-1,"neurobit.print(SignalShape.ENVELOPE"],[1,"basic.showNumber(neurobit.getSpikes(3000)"],[0,")\n"]],"start1":25,"start2":25,"length1":41,"length2":47}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727301130056,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," }\n\n"],[-1,"    \n\n"],[0,"    "]],"start1":10191,"start2":10191,"length1":14,"length2":8}]}]},{"timestamp":1727301871854,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"ount\n    }\n\n"],[-1,"\n"],[0,"    \n\n    //"]],"start1":10183,"start2":10183,"length1":25,"length2":24}]}]},{"timestamp":1727301873592,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"ter;"],[-1,"\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=28\n    //% block=\"get reaction time ||with threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=50\n    export function reactionTime(threshold?: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (threshold < 0) {\n            return -1;\n        }\n\n        const time_limit = 10000; // Maximum 10 seconds to make reaction\n        let signal = 0;\n        let result_time = 0;\n\n        const startTime = control.millis();\n\n        signal = getEnvelope();\n        while (signal < threshold) {\n            signal = getEnvelope();\n            result_time = control.millis() - startTime;\n            if (result_time > time_limit) return -1;\n            serial.writeLine(\"\");\n        }\n\n        return result_time;"],[1," // Return the spike count\n    }\n\n"],[0,"\n    "],[-1,"}"],[0,"\n\n  "]],"start1":10157,"start2":10157,"length1":860,"length2":47}]}]},{"timestamp":1727302345476,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"ion time"],[1," "],[0,"||"],[-1," "],[0,"with thr"]],"start1":10247,"start2":10247,"length1":19,"length2":19},{"diffs":[[0,"ion "],[-1,"getR"],[1,"r"],[0,"eact"]],"start1":10367,"start2":10367,"length1":12,"length2":9}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"36"],[1,"0"],[0,"\" y=\""],[-1,"48"],[1,"0"],[0,"\"><s"]],"start1":104,"start2":104,"length1":17,"length2":15},{"diffs":[[0,"pe=\""],[-1,"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_getReactionTime"],[1,"neurobit_print"],[0,"\"><m"]],"start1":199,"start2":199,"length1":274,"length2":22},{"diffs":[[0,"tation><"],[1,"field name=\"shape\">SignalShape.ENVELOPE</field><"],[0,"value na"]],"start1":303,"start2":303,"length1":16,"length2":64},{"diffs":[[0,"me=\""],[-1,"threshold"],[1,"duration"],[0,"\"><s"]],"start1":367,"start2":367,"length1":17,"length2":16},{"diffs":[[0,"pe=\""],[-1,"math_numb"],[1,"timePick"],[0,"er\">"]],"start1":391,"start2":391,"length1":17,"length2":16},{"diffs":[[0,"me=\""],[-1,"NUM"],[1,"ms"],[0,"\">50"],[1,"00"],[0,"</fi"]],"start1":416,"start2":416,"length1":15,"length2":16},{"diffs":[[0,"k></"],[-1,"value></block></next></block></"],[0,"next"]],"start1":459,"start2":459,"length1":39,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"G()\n"],[-1,"basic.pause(2000)\nbasic.showNumber(neurobit.getReactionTime()"],[1,"neurobit.print(SignalShape.ENVELOPE"],[0,")\n"]],"start1":25,"start2":25,"length1":67,"length2":41}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727302758733,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," y=\""],[-1,"1"],[0,"4"],[1,"8"],[0,"\"><s"]],"start1":111,"start2":111,"length1":10,"length2":10},{"diffs":[[0,"ock "],[-1,"type=\"music_playable_play\"><field name=\"playbackMode\">music.PlaybackMode.UntilDone</field><value name=\"toPlay\"><shadow type=\"music_tone_playable\"><value name=\"note\"><shadow type=\"device_note\"><field name=\"name\">262</field></shadow></value><value name=\"duration\"><shadow type=\"device_beat\"><field name=\"fraction\">BeatFraction.Half</field></shadow></value></shadow></value><next><block "],[0,"type"]],"start1":320,"start2":320,"length1":392,"length2":8},{"diffs":[[0,"block></"],[-1,"next></block></"],[0,"statemen"]],"start1":708,"start2":708,"length1":31,"length2":16}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"00)\n"],[-1,"music.play(music.tonePlayable(262, music.beat(BeatFraction.Half)), music.PlaybackMode.UntilDone)\n"],[0,"basi"]],"start1":43,"start2":43,"length1":105,"length2":8}]}]},{"timestamp":1727303121003,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"0"],[1,"36"],[0,"\" y=\""],[-1,"0"],[1,"14"],[0,"\"><s"]],"start1":104,"start2":104,"length1":15,"length2":17}]}]},{"timestamp":1727304246404,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727304246645,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \""],[-1,"Neuro"],[1,"Free testing space"],[0,"\",\n "]],"start1":11,"start2":11,"length1":13,"length2":26}]}]},{"timestamp":1727378616857,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,": \"Neuro"],[-1,"bit"],[0,"\",\n    \""]],"start1":12,"start2":12,"length1":19,"length2":16}]}]},{"timestamp":1727378618559,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"return ["],[-1,"0"],[1,"-1"],[0,"];\n     "]],"start1":6727,"start2":6727,"length1":17,"length2":18},{"diffs":[[0,"         return "],[-1,"0"],[1,"-1"],[0,";\n        }\n    "]],"start1":7990,"start2":7990,"length1":33,"length2":34},{"diffs":[[0,"     return "],[-1,"undefined"],[1,"-1"],[0,";\n        }\n"]],"start1":8814,"start2":8814,"length1":33,"length2":26},{"diffs":[[0,"     return "],[-1,"undefined"],[1,"-1"],[0,";\n        }\n"]],"start1":9527,"start2":9527,"length1":33,"length2":26},{"diffs":[[0,"urn "],[-1,"undefined"],[1,"-1"],[0,";\n  "]],"start1":10533,"start2":10533,"length1":17,"length2":10},{"diffs":[[0," return "],[-1,"time_limit"],[1,"-1"],[0,";\n      "]],"start1":10926,"start2":10926,"length1":26,"length2":18}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \""],[-1,"Free Testing Space"],[1,"Neurobit"],[0,"\",\n "]],"start1":11,"start2":11,"length1":26,"length2":16}]}]},{"timestamp":1727378929329,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"er[] = [];\n\n"],[1,"    let ecgTimestamps: number[] = [];\n"],[0,"    let sign"]],"start1":537,"start2":537,"length1":24,"length2":62},{"diffs":[[0,"= 1\n"],[-1,"\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    let envelopeValue: number = 0;\n\n    const ECG_JUMP = 40;\n    const DEBOUNCE_PERIOD_ECG = 300;\n    let ecgTimestamps: number[] = [];"],[1,"    let envelopeValue: number = 0"],[0,"\n   "]],"start1":650,"start2":650,"length1":203,"length2":41},{"diffs":[[0,"ber = 0\n"],[-1,"\n"],[0,"    cons"]],"start1":771,"start2":771,"length1":17,"length2":16},{"diffs":[[0,"nst "],[-1,"SAMPLING_RATE: number = 250;       // Hz\n    const ALPHA_WAVE_FREQUENCY: number = 20;     // Hz (Notch frequency)\n    const Q: number = 1;                   // Quality factor\n    const BASELINE_ALPHA: number = 20;\n\n    let eegSignalPower: number = 0;\n    let eegNotchedSignalPower: number = 0;\n    let filteredValue: number = 0;\n    let eegAlphaPower: number = 0;"],[1,"NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    const ECG_JUMP = 40\n    const DEBOUNCE_PERIOD_ECG = 300"],[0,"\n\n  "]],"start1":785,"start2":785,"length1":371,"length2":116}]}]},{"timestamp":1727379450932,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"r = 250;"],[1,"      "],[0," // Hz\n "]],"start1":934,"start2":934,"length1":16,"length2":22},{"diffs":[[0,"r = "],[-1,"1"],[1,"2"],[0,"0;"],[1,"    "],[0," // "]],"start1":992,"start2":992,"length1":11,"length2":15},{"diffs":[[0,"ber = 1;"],[1,"                  "],[0," // Qual"]],"start1":1044,"start2":1044,"length1":16,"length2":34},{"diffs":[[0,"20;\n"],[-1,"    let coefficients: number[] = [0, 0, 0, 0, 0];"],[0,"\n   "]],"start1":1124,"start2":1124,"length1":57,"length2":8},{"diffs":[[0," }\n\n"],[-1,"    /**\n     * Calculate intermediate variables and set filter coefficients\n     */\n    function calculateNotchCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = 1 / a0;\n        const b1 = (-2 * omegaC) / a0;\n        const b2 = 1 / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n        // Set the coefficients array\n        coefficients[0] = b0;\n        coefficients[1] = b1;\n        coefficients[2] = b2;\n        coefficients[3] = a1;\n        coefficients[4] = a2;\n    }\n\n"],[0,"\n   "]],"start1":2361,"start2":2361,"length1":738,"length2":8}]}]},{"timestamp":1727379842133,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"AY = 2;\n"],[-1,"    \n"],[0,"    let "]],"start1":668,"start2":668,"length1":21,"length2":16},{"diffs":[[0,"number = 0;\n"],[1,""],[0,"\n    const E"]],"start1":699,"start2":699,"length1":24,"length2":24},{"diffs":[[0," = 300;\n"],[-1,"\n"],[0,"    let "]],"start1":766,"start2":766,"length1":17,"length2":16},{"diffs":[[0," 20;"],[-1,"\n\n    let gInputKeepBuffer: number[] = [0, 0];\n    let gOutputKeepBuffer: number[] = [0, 0];\n\n    let tempCalculationValue: number = 0"],[0,"\n   "]],"start1":1095,"start2":1095,"length1":142,"length2":8},{"diffs":[[0,"  }\n"],[-1,"    \n    function filterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (coefficients[0] * inputValue) +\n            (coefficients[1] * gInputKeepBuffer[0]) +\n            (coefficients[2] * gInputKeepBuffer[1]) -\n            (coefficients[3] * gOutputKeepBuffer[0]) -\n            (coefficients[4] * gOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        gInputKeepBuffer[1] = gInputKeepBuffer[0]; // x[n-2] = x[n-1]\n        gInputKeepBuffer[0] = inputValue;           // x[n-1] = x[n]\n\n        // Update the output buffer (shift the samples)\n        gOutputKeepBuffer[1] = gOutputKeepBuffer[0]; // y[n-2] = y[n-1]\n        gOutputKeepBuffer[0] = y;                     // y[n-1] = y[n]\n\n        return y | 0;\n    }\n"],[0,"\n\n  "]],"start1":3111,"start2":3111,"length1":911,"length2":8},{"diffs":[[0,") {\n"],[-1,"                eegSignalPower = eegSignalPower * 0.99 + 0.01 * (Math.abs(tempCalculationValue - 512))\n                filteredValue = filterSingleSample(tempCalculationValue)\n                eegNotchedSignalPower = eegNotchedSignalPower * 0.99 + 0.01 * (Math.abs(filteredValue - 512))\n                eegAlphaPower = (eegSignalPower - eegNotchedSignalPower) - BASELINE_ALPHA;\n                if (eegAlphaPower < 0) {\n                    eegAlphaPower = 0;\n                }"],[0,"\n"],[1,""],[0,"    "]],"start1":5610,"start2":5610,"length1":483,"length2":9},{"diffs":[[0," return "],[-1,"eegAlphaPower"],[1,"0"],[0,";\n    }\n"]],"start1":9548,"start2":9548,"length1":29,"length2":17}]}]},{"timestamp":1727380263923,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"ace "],[-1,"spiker"],[1,"neurobit"],[0," {\n "]],"start1":172,"start2":172,"length1":14,"length2":16}]}]},{"timestamp":1727450021421,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"ace "],[-1,"neurobit"],[1,"spiker"],[0," {\n "]],"start1":172,"start2":172,"length1":16,"length2":14}]}]},{"timestamp":1727450025612,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"r=\"#"],[-1,"FF805E"],[1,"E69138"],[0,"\" ic"]],"start1":130,"start2":130,"length1":14,"length2":14},{"diffs":[[0,"ace "],[-1,"spiker"],[1,"neuro"],[0,"bit "]],"start1":172,"start2":172,"length1":14,"length2":13}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"neurobit_startRecordingEMG\"><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value><next><block type=\"music_playable_play\"><field name=\"playbackMode\">music.PlaybackMode.UntilDone</field><value name=\"toPlay\"><shadow type=\"music_tone_playable\"><value name=\"note\"><shadow type=\"device_note\"><field name=\"name\">262</field></shadow></value><value name=\"duration\"><shadow type=\"device_beat\"><field name=\"fraction\">BeatFraction.Half</field></shadow></value></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_getReactionTime\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"threshold\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value></block></value></block></next></block></next></block></next></block></statement></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":1066}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"neurobit.startRecordingEMG()\nbasic.pause(2000)\nmusic.play(music.tonePlayable(262, music.beat(BeatFraction.Half)), music.PlaybackMode.UntilDone)\nbasic.showNumber(neurobit.getReactionTime())"],[0,"\n"]],"start1":0,"start2":0,"length1":1,"length2":189}]}]},{"timestamp":1727450182388,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727731208884,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727731210806,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"= false;"],[-1,"\n        let check"],[0,"\n\n      "]],"start1":12338,"start2":12338,"length1":34,"length2":16}]}]},{"timestamp":1727736006461,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"heck"],[-1,"_interva; "],[0,"\n\n  "]],"start1":12360,"start2":12360,"length1":18,"length2":8}]}]},{"timestamp":1727736009121,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"= false;"],[1,"\n        let check_interva; "],[0,"\n\n      "]],"start1":12338,"start2":12338,"length1":16,"length2":44},{"diffs":[[0,") {\n"],[-1,"                if (control.millis() - startTimer > duration) {\n                    return -1;\n                }\n"],[0,"    "]],"start1":12554,"start2":12554,"length1":121,"length2":8}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"es><"],[-1,"block type=\"pxt-on-start\" x=\"37\" y=\"50\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"spikerbit_getSpikes\"><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value></block></value></block></next></block></statement></block><"],[0,"/xml"]],"start1":75,"start2":75,"length1":428,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"spikerbit.startRecordingEMG()\nbasic.showNumber(spikerbit.getSpikes(2000))"],[0,"\n"]],"start1":0,"start2":0,"length1":74,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727736535531,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"c.pause("],[-1,"5"],[1,"1"],[0,"0); //To"]],"start1":12098,"start2":12098,"length1":17,"length2":17},{"diffs":[[0,"SHOLD = "],[-1,"2"],[0,"5"],[1,"0"],[0,";\n\n     "]],"start1":12253,"start2":12253,"length1":18,"length2":18}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"x=\"3"],[-1,"8"],[1,"7"],[0,"\" y=\""],[-1,"17"],[1,"50"],[0,"\"><s"]],"start1":105,"start2":105,"length1":16,"length2":16},{"diffs":[[0,"pe=\""],[-1,"music_playable_play\"><field name=\"playbackMode\">music.PlaybackMode.UntilDone</field><value name=\"toPlay\"><shadow type=\"music_tone_playable"],[1,"device_show_number"],[0,"\"><v"]],"start1":202,"start2":202,"length1":146,"length2":26},{"diffs":[[0," name=\"n"],[-1,"ote"],[1,"umber"],[0,"\"><shado"]],"start1":232,"start2":232,"length1":19,"length2":21},{"diffs":[[0,"pe=\""],[-1,"device_note\"><field name=\"name\">262</field></shadow></value><value name=\"duration\"><shadow type=\"device_beat\"><field name=\"fraction\">BeatFraction.Half</field></shadow></value></shadow></value><next><block type=\"device_show_number\"><value name=\"number\""],[1,"math_number\"><field name=\"NUM\">0</field></shadow"],[0,"><bl"]],"start1":257,"start2":257,"length1":259,"length2":56},{"diffs":[[0,"block></"],[-1,"next></block></"],[0,"statemen"]],"start1":472,"start2":472,"length1":31,"length2":16}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"G()\n"],[-1,"music.play(music.tonePlayable(262, music.beat(BeatFraction.Half)), music.PlaybackMode.UntilDone)\n"],[0,"basi"]],"start1":26,"start2":26,"length1":105,"length2":8}]}]},{"timestamp":1727737107265,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"0"],[1,"38"],[0,"\" y=\""],[-1,"0"],[1,"17"],[0,"\"><s"]],"start1":104,"start2":104,"length1":15,"length2":17}]}]},{"timestamp":1727806764611,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"spikerbit.startRecordingEMG()\nmusic.play(music.tonePlayable(262, music.beat(BeatFraction.Half)), music.PlaybackMode.UntilDone)\nbasic.showNumber(spikerbit.getSpikes(2000))"],[0,"\n"]],"start1":0,"start2":0,"length1":1,"length2":171}]}]},{"timestamp":1727806766526,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"e=\"s"],[-1,"ervoservosetangle\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractor"],[1,"pikerbit_startRecordingEMG\"><next><block type=\"music_playable_play\"><field name=\"playbackMode\">music.PlaybackMode.UntilDone</field><value name=\"toPlay\"><shadow type=\"music_tone_playable\"><value name=\"note\"><shadow type=\"device_note\"><field name=\"name\">262</field></shadow></value><value name=\"duration\"><shadow type=\"device_beat\"><field name=\"fraction\">BeatFraction.Half</field></shadow></value></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><block type=\"spikerbit_getSpikes\"><value name=\"duration\"><shadow type=\"time"],[0,"Pick"]],"start1":153,"start2":153,"length1":110,"length2":555},{"diffs":[[0,"me=\""],[-1,"angle\">45"],[1,"ms\">2000"],[0,"</fi"]],"start1":721,"start2":721,"length1":17,"length2":16},{"diffs":[[0,"block></"],[1,"value></block></next></block></next></block></"],[0,"statemen"]],"start1":760,"start2":760,"length1":16,"length2":62}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"servos.P0.setAngle(45)"],[0,"\n"]],"start1":0,"start2":0,"length1":23,"length2":1}]}]},{"timestamp":1727806822812,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"etAngle("],[1,"4"],[0,"5)\n"]],"start1":11,"start2":11,"length1":11,"length2":12}]}]},{"timestamp":1727807609101,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"\"angle\">"],[1,"4"],[0,"5</field"]],"start1":279,"start2":279,"length1":16,"length2":17}]}]},{"timestamp":1727807609171,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"le\">"],[-1,"90"],[1,"5"],[0,"</fi"]],"start1":283,"start2":283,"length1":10,"length2":9}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"gle("],[-1,"90"],[1,"5"],[0,")\n"]],"start1":15,"start2":15,"length1":8,"length2":7}]}]},{"timestamp":1727807674106,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"gle("],[-1,"18"],[1,"9"],[0,"0)\n"]],"start1":15,"start2":15,"length1":9,"length2":8}]}]},{"timestamp":1727905256762,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"le\">"],[-1,"18"],[1,"9"],[0,"0</f"]],"start1":283,"start2":283,"length1":10,"length2":9}]}]},{"timestamp":1727905256792,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"le\">"],[-1,"9"],[1,"18"],[0,"0</f"]],"start1":283,"start2":283,"length1":9,"length2":10}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"gle("],[-1,"9"],[1,"18"],[0,"0)\n"]],"start1":15,"start2":15,"length1":8,"length2":9}]}]},{"timestamp":1727905271390,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727908325285,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"spikerbit.startRecordingEMG()\nbasic.forever(function () {\n    if (spikerbit.getEnvelope() > 15) {\n        servos.P0.setAngle(180)\n    } else {\n        "],[0,"serv"]],"start1":0,"start2":0,"length1":155,"length2":4},{"diffs":[[0,"90)\n"],[-1,"    }\n})\n"]],"start1":19,"start2":19,"length1":13,"length2":4}]}]},{"timestamp":1727908326893,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"pe=\""],[-1,"device_forever\" x=\"247\" y=\"20\"><statement name=\"HANDLER\"><block type=\"controls_if\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\"><field name=\"OP\">GT</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"spikerbit_getEnvelope\"></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">30</field></shadow></value></block></value><statement name=\"DO0\"><block type=\"servoservosetangle\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractorPicker\"><field name=\"angle\">180</field></shadow></value></block></statement"],[1,"pxt-on-start\" x=\"0\" y=\"0\""],[0,"><st"]],"start1":87,"start2":87,"length1":711,"length2":33},{"diffs":[[0,"me=\""],[-1,"ELSE"],[1,"HANDLER"],[0,"\"><b"]],"start1":130,"start2":130,"length1":12,"length2":15},{"diffs":[[0,"k></"],[-1,"statement></block><block type=\"pxt-on-start\" x=\"39\" y=\"49\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"></block></statement></block></"],[0,"xml>"]],"start1":340,"start2":340,"length1":165,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") > "],[-1,"30"],[1,"15"],[0,") {\n"]],"start1":88,"start2":88,"length1":10,"length2":10}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727908611991,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"x=\"2"],[-1,"08"],[1,"47"],[0,"\" y=\""],[-1,"-29"],[1,"20"],[0,"\"><s"]],"start1":107,"start2":107,"length1":18,"length2":17},{"diffs":[[0," x=\""],[-1,"0"],[1,"39"],[0,"\" y=\""],[-1,"0"],[1,"49"],[0,"\"><s"]],"start1":1063,"start2":1063,"length1":15,"length2":17}]}]},{"timestamp":1727911120846,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"ock "],[-1,"type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"></block></statement></block><block "],[0,"type"]],"start1":81,"start2":81,"length1":143,"length2":8},{"diffs":[[0,"=\"20"],[-1,"9"],[1,"8"],[0,"\" y=\""],[-1,"2"],[1,"-29"],[0,"\"><s"]],"start1":108,"start2":108,"length1":15,"length2":17},{"diffs":[[0,"/block><"],[1,"block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"></block></statement></block><"],[0,"/xml>"]],"start1":1031,"start2":1031,"length1":13,"length2":148}]}]},{"timestamp":1727911126413,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"_size = "],[-1,"2"],[0,"5"],[1,"0"],[0,"; // Arb"]],"start1":1667,"start2":1667,"length1":18,"length2":18},{"diffs":[[0,"      //"],[-1," //"],[0," Obtain "]],"start1":10344,"start2":10344,"length1":19,"length2":16},{"diffs":[[0,"\n           "],[-1," //"],[0," let signal "]],"start1":10390,"start2":10390,"length1":27,"length2":24},{"diffs":[[0,"      //"],[-1," //"],[0," Rectify"]],"start1":10441,"start2":10441,"length1":19,"length2":16},{"diffs":[[0,"        "],[-1," //"],[0," let rec"]],"start1":10472,"start2":10472,"length1":19,"length2":16},{"diffs":[[0,"      //"],[-1," //"],[0," Serial "]],"start1":10529,"start2":10529,"length1":19,"length2":16},{"diffs":[[0,"        "],[-1," //"],[0," return "]],"start1":10563,"start2":10563,"length1":19,"length2":16},{"diffs":[[0,"l);\n"],[-1,"            return envelopeValue;\n"],[0,"    "]],"start1":10606,"start2":10606,"length1":42,"length2":8}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"bles><block "],[1,"type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"></block></statement></block><block "],[0,"type=\"device"]],"start1":73,"start2":73,"length1":24,"length2":159},{"diffs":[[0," x=\""],[-1,"357"],[1,"209"],[0,"\" y=\""],[-1,"30"],[1,"2"],[0,"\"><s"]],"start1":241,"start2":241,"length1":18,"length2":17},{"diffs":[[0,"e=\"NUM\">"],[-1,"5"],[1,"3"],[0,"0</field"]],"start1":664,"start2":664,"length1":17,"length2":17},{"diffs":[[0,"ck><"],[-1,"block type=\"pxt-on-start\" x=\"40\" y=\"51\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"></block></statement></block><block type=\"spikerbit_print\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"113\" y=\"431\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field><value name=\"duration\"><shadow type=\"timePicker\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"ms\">0</field></shadow></value></block><"],[0,"/xml"]],"start1":1168,"start2":1168,"length1":519,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,") > "],[-1,"5"],[1,"3"],[0,"0) {"]],"start1":88,"start2":88,"length1":9,"length2":9}]}]},{"timestamp":1727911685617,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"_size = "],[-1,"30"],[1,"25"],[0,"; // Arb"]],"start1":1667,"start2":1667,"length1":18,"length2":18}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"x=\"3"],[-1,"13\" y=\"5\"></block><block type=\"pxt-on-start\" x=\"33\" y=\"56\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"><next><block type=\"spikerbit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">0</field></shadow></value></block></next></block></statement></block><block type=\"controls_if\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"455\" y=\"179"],[1,"57\" y=\"30\"><statement name=\"HANDLER\"><block type=\"controls_if"],[0,"\"><m"]],"start1":107,"start2":107,"length1":537,"length2":69},{"diffs":[[0,"are\""],[-1," disabled-reasons=\"MANUALLY_DISABLED\""],[0,"><fi"]],"start1":314,"start2":314,"length1":45,"length2":8},{"diffs":[[0,"ope\""],[-1," disabled-reasons=\"MANUALLY_DISABLED\""],[0,"></b"]],"start1":456,"start2":456,"length1":45,"length2":8},{"diffs":[[0,"ber\""],[-1," disabled-reasons=\"MANUALLY_DISABLED\""],[0,"><fi"]],"start1":515,"start2":515,"length1":45,"length2":8},{"diffs":[[0,"e=\"NUM\">"],[-1,"7"],[1,"5"],[0,"0</field"]],"start1":530,"start2":530,"length1":17,"length2":17},{"diffs":[[0,"gle\""],[-1," disabled-reasons=\"MANUALLY_DISABLED\""],[0,"><fi"]],"start1":631,"start2":631,"length1":45,"length2":8},{"diffs":[[0,"ker\""],[-1," disabled-reasons=\"MANUALLY_DISABLED\""],[0,"><fi"]],"start1":722,"start2":722,"length1":45,"length2":8},{"diffs":[[0,"gle\""],[-1," disabled-reasons=\"MANUALLY_DISABLED\""],[0,"><fi"]],"start1":846,"start2":846,"length1":45,"length2":8},{"diffs":[[0,"ker\""],[-1," disabled-reasons=\"MANUALLY_DISABLED\""],[0,"><fi"]],"start1":937,"start2":937,"length1":45,"length2":8},{"diffs":[[0,"ck><"],[-1,"block type=\"device_show_number"],[1,"/statement></block><block type=\"pxt-on-start\" x=\"40\" y=\"51\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"></block></statement></block><block type=\"spikerbit_print"],[0,"\" di"]],"start1":1014,"start2":1014,"length1":38,"length2":192},{"diffs":[[0,"x=\"1"],[-1,"4"],[1,"13"],[0,"\" y=\""],[1,"4"],[0,"31"],[-1,"2"],[0,"\"><"],[-1,"value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"spikerbit_getSpikes\" disabled-reasons=\"MANUALLY_DISABLED\""],[1,"mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field"],[0,"><va"]],"start1":1256,"start2":1256,"length1":173,"length2":158},{"diffs":[[0,"ms\">"],[-1,"300"],[0,"0</f"]],"start1":1510,"start2":1510,"length1":11,"length2":8},{"diffs":[[0,"block></"],[-1,"value></block></"],[0,"xml>"]],"start1":1542,"start2":1542,"length1":28,"length2":12}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"G()\n"],[-1,"spikerbit.print(SignalShape.ENVELOPE)\nbasic.forever(function () {\n\t"],[1,"basic.forever(function () {\n    if (spikerbit.getEnvelope() > 50) {\n        servos.P0.setAngle(180)\n    } else {\n        servos.P0.setAngle(90)\n    }"],[0,"\n})\n"]],"start1":26,"start2":26,"length1":75,"length2":157}]}]},{"timestamp":1727912273462,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"l);\n"],[-1,"            \n"],[0,"    "]],"start1":10624,"start2":10624,"length1":21,"length2":8},{"diffs":[[0,"SHOLD = "],[1,"2"],[0,"5"],[-1,"0"],[0,";\n\n     "]],"start1":12305,"start2":12305,"length1":18,"length2":18}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"298"],[1,"313"],[0,"\" y=\""],[-1,"-62"],[1,"5"],[0,"\"></"]],"start1":106,"start2":106,"length1":19,"length2":17},{"diffs":[[0," x=\""],[-1,"0"],[1,"33"],[0,"\" y=\""],[-1,"0"],[1,"56"],[0,"\"><s"]],"start1":155,"start2":155,"length1":15,"length2":17},{"diffs":[[0,"/field><"],[1,"value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">0</field></shadow></value><"],[0,"/block><"]],"start1":406,"start2":406,"length1":16,"length2":108},{"diffs":[[0,"pe=\""],[-1,"music_playable_play"],[1,"controls_if"],[0,"\" di"]],"start1":557,"start2":557,"length1":27,"length2":19},{"diffs":[[0," x=\""],[-1,"570"],[1,"455"],[0,"\" y=\"1"],[-1,"52\"><field name=\"playbackMode\">music.PlaybackMode.UntilDone"],[1,"79\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"OP\">GT"],[0,"</fi"]],"start1":625,"start2":625,"length1":76,"length2":222},{"diffs":[[0,"me=\""],[-1,"toPlay"],[1,"A"],[0,"\"><s"]],"start1":860,"start2":860,"length1":14,"length2":9},{"diffs":[[0,"e=\"m"],[-1,"usic_tone_playabl"],[1,"ath_number\"><field name=\"NUM\">0</field></shadow><block type=\"spikerbit_getEnvelop"],[0,"e\" d"]],"start1":878,"start2":878,"length1":25,"length2":89},{"diffs":[[0,"ALLY_DISABLED\"><"],[1,"/block></value><"],[0,"value name=\"note"]],"start1":988,"start2":988,"length1":32,"length2":48},{"diffs":[[0,"e name=\""],[-1,"note"],[1,"B"],[0,"\"><shado"]],"start1":1024,"start2":1024,"length1":20,"length2":17},{"diffs":[[0,"pe=\""],[-1,"device_note"],[1,"math_number"],[0,"\" di"]],"start1":1045,"start2":1045,"length1":19,"length2":19},{"diffs":[[0,"me=\""],[-1,"name\">262"],[1,"NUM\">70"],[0,"</fi"]],"start1":1108,"start2":1108,"length1":17,"length2":15},{"diffs":[[0,"ue><"],[-1,"value name=\"duration\"><shadow type=\"device_beat\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"fraction\">BeatFraction.Half</field></shadow></value></shadow></value><next"],[1,"/block></value><statement name=\"DO0\"><block type=\"servoservosetangle\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractorPicker\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"angle\">180</field></shadow></value></block></statement><statement name=\"ELSE\"><block type=\"servoservosetangle\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractorPicker\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"angle\">90</field></shadow></value></block></statement></block"],[0,"><bl"]],"start1":1141,"start2":1141,"length1":181,"length2":606},{"diffs":[[0,"NUALLY_DISABLED\""],[1," x=\"14\" y=\"312\""],[0,"><value name=\"nu"]],"start1":1812,"start2":1812,"length1":32,"length2":47},{"diffs":[[0,"block></"],[-1,"next></block></"],[0,"xml>"]],"start1":2149,"start2":2149,"length1":27,"length2":12}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1727912860305,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"_size = "],[-1,"4"],[1,"3"],[0,"0; // Ar"]],"start1":1667,"start2":1667,"length1":17,"length2":17},{"diffs":[[0,"{\n            //"],[1," //"],[0," Obtain the sign"]],"start1":10336,"start2":10336,"length1":32,"length2":35},{"diffs":[[0,"to 0\n           "],[1," //"],[0," let signal = ge"]],"start1":10389,"start2":10389,"length1":32,"length2":35},{"diffs":[[0,";\n            //"],[1," //"],[0," Rectify the sig"]],"start1":10439,"start2":10439,"length1":32,"length2":35},{"diffs":[[0,"gnal\n           "],[1," //"],[0," let rectified_s"]],"start1":10473,"start2":10473,"length1":32,"length2":35},{"diffs":[[0,"\n\n            //"],[1," //"],[0," Serial Out the "]],"start1":10533,"start2":10533,"length1":32,"length2":35},{"diffs":[[0,"gnal\n           "],[1," //"],[0," return convolut"]],"start1":10570,"start2":10570,"length1":32,"length2":35},{"diffs":[[0,"    \n           "],[-1," //"],[0," return envelope"]],"start1":10636,"start2":10636,"length1":35,"length2":32},{"diffs":[[0,"));\n"],[-1,"                    // serial.writeValue(signal_label, getEnvelope());\n"],[0,"    "]],"start1":14696,"start2":14696,"length1":79,"length2":8},{"diffs":[[0,"));\n"],[-1,"                    // serial.writeValue(signal_label, getEnvelope());\n"],[0,"    "]],"start1":15501,"start2":15501,"length1":79,"length2":8}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"bles><block "],[1,"type=\"device_forever\" x=\"298\" y=\"-62\"></block><block "],[0,"type=\"pxt-on"]],"start1":73,"start2":73,"length1":24,"length2":77},{"diffs":[[0,"G\"><"],[-1,"/block></statement></block><block type=\"device_forever\" x=\"265\" y=\"-5\"><statement name=\"HANDLER\"><block type=\"controls_if\"><mutation else=\"1"],[1,"next><block type=\"spikerbit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true"],[0,"\"></"]],"start1":235,"start2":235,"length1":148,"length2":121},{"diffs":[[0,"on><"],[-1,"value"],[1,"field"],[0," name=\""],[-1,"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\"><field name=\"OP\">GT"],[1,"shape\">SignalShape.ENVELOPE</field></block></next></block></statement></block><block type=\"music_playable_play\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"570\" y=\"152\"><field name=\"playbackMode\">music.PlaybackMode.UntilDone"],[0,"</fi"]],"start1":362,"start2":362,"length1":141,"length2":255},{"diffs":[[0,"e name=\""],[-1,"A"],[1,"toPlay"],[0,"\"><shado"]],"start1":626,"start2":626,"length1":17,"length2":22},{"diffs":[[0,"e=\"m"],[-1,"ath_number\"><field name=\"NUM\">0</field"],[1,"usic_tone_playable\" disabled-reasons=\"MANUALLY_DISABLED\"><value name=\"note\""],[0,"><"],[-1,"/"],[0,"shadow"],[-1,"><block type=\"spikerbit_getEnvelope\"></block"],[1," type=\"device_note\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"name\">262</field></shadow"],[0,"></v"]],"start1":653,"start2":653,"length1":99,"length2":186},{"diffs":[[0,"e name=\""],[-1,"B"],[1,"duration"],[0,"\"><shado"]],"start1":849,"start2":849,"length1":17,"length2":24},{"diffs":[[0,"pe=\""],[-1,"math_number\"><field name=\"NUM\">25"],[1,"device_beat\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"fraction\">BeatFraction.Half"],[0,"</fi"]],"start1":877,"start2":877,"length1":41,"length2":98},{"diffs":[[0,"value></"],[-1,"block"],[1,"shadow"],[0,"></value"]],"start1":990,"start2":990,"length1":21,"length2":22},{"diffs":[[0,"ue><"],[-1,"statement name=\"DO0\"><block type=\"servoservosetangle\"><field name=\"servo\">servos.P0</field"],[1,"next><block type=\"device_show_number\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\""],[0,"><va"]],"start1":1010,"start2":1010,"length1":98,"length2":97},{"diffs":[[0,"D\"><value name=\""],[-1,"degrees"],[1,"number"],[0,"\"><shadow type=\""]],"start1":1101,"start2":1101,"length1":39,"length2":38},{"diffs":[[0,"hadow type=\""],[-1,"protractorPick"],[1,"math_numb"],[0,"er\"><field n"]],"start1":1127,"start2":1127,"length1":38,"length2":33},{"diffs":[[0,"me=\""],[-1,"angle"],[1,"NUM"],[0,"\">"],[-1,"9"],[0,"0</f"]],"start1":1161,"start2":1161,"length1":16,"length2":13},{"diffs":[[0,"ow><"],[-1,"/value></block></statement><statement name=\"ELSE\"><block type=\"servoservosetangle\"><field name=\"servo\">servos.P0</field"],[1,"block type=\"spikerbit_getSpikes\" disabled-reasons=\"MANUALLY_DISABLED\""],[0,"><va"]],"start1":1185,"start2":1185,"length1":127,"length2":77},{"diffs":[[0,"e=\"d"],[-1,"egrees"],[1,"uration"],[0,"\"><s"]],"start1":1269,"start2":1269,"length1":14,"length2":15},{"diffs":[[0,"pe=\""],[-1,"protractorPicker"],[1,"timePicker\" disabled-reasons=\"MANUALLY_DISABLED"],[0,"\"><f"]],"start1":1292,"start2":1292,"length1":24,"length2":55},{"diffs":[[0,"me=\""],[-1,"angle\">18"],[1,"ms\">300"],[0,"0</f"]],"start1":1354,"start2":1354,"length1":17,"length2":15},{"diffs":[[0,"e></block></"],[-1,"statement"],[1,"value"],[0,"></block></s"]],"start1":1389,"start2":1389,"length1":33,"length2":29},{"diffs":[[0,"e></block></"],[-1,"statemen"],[1,"nex"],[0,"t></block></"]],"start1":1405,"start2":1405,"length1":32,"length2":27}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"G()\n"],[-1,"basic.forever(function () {\n    if (spikerbit.getEnvelope() > 25) {\n        servos.P0.setAngle(90)\n    } else {\n        servos.P0.setAngle(180)\n    }"],[1,"spikerbit.print(SignalShape.ENVELOPE)\nbasic.forever(function () {\n\t"],[0,"\n})\n"]],"start1":26,"start2":26,"length1":157,"length2":75}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1727913432426,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"_size = "],[-1,"2"],[1,"4"],[0,"0; // Ar"]],"start1":1667,"start2":1667,"length1":17,"length2":17}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"bles><block "],[1,"type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"></block></statement></block><block "],[0,"type=\"device"]],"start1":73,"start2":73,"length1":24,"length2":159},{"diffs":[[0,"ck><"],[-1,"block type=\"pxt-on-start\" x=\"33\" y=\"50\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"><next><block type=\"spikerbit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">0</field></shadow></value></block></next></block></statement></block><"],[0,"/xml"]],"start1":1169,"start2":1169,"length1":427,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"G()\n"],[-1,"spikerbit.print(SignalShape.ENVELOPE)\n"],[0,"basi"]],"start1":26,"start2":26,"length1":46,"length2":8}]}]},{"timestamp":1727913531342,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"x=\"2"],[-1,"32"],[1,"65"],[0,"\" y=\"-5"],[-1,"5"],[0,"\"><s"]],"start1":107,"start2":107,"length1":18,"length2":17},{"diffs":[[0," x=\""],[-1,"0"],[1,"33"],[0,"\" y=\""],[1,"5"],[0,"0\"><"]],"start1":1063,"start2":1063,"length1":14,"length2":16}]}]},{"timestamp":1728058151362,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1728058314478,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0," block=\""],[-1,"s"],[1,"S"],[0,"tart"],[-1," r"],[1,"R"],[0,"ecording"],[-1," "],[0,"EMG\"\n   "]],"start1":7357,"start2":7357,"length1":32,"length2":30},{"diffs":[[0," block=\""],[-1,"s"],[1,"S"],[0,"tart"],[-1," r"],[1,"R"],[0,"ecording"],[-1," "],[0,"ECG\"\n   "]],"start1":7834,"start2":7834,"length1":32,"length2":30},{"diffs":[[0,"ck=\""],[-1,"s"],[1,"S"],[0,"tart"],[-1," r"],[1,"R"],[0,"ecording"],[-1," "],[0,"EEG\""]],"start1":8306,"start2":8306,"length1":24,"length2":22},{"diffs":[[0,"ock=\"get"],[-1," s"],[1,"S"],[0,"ignal\"\n "]],"start1":8788,"start2":8788,"length1":18,"length2":17},{"diffs":[[0,"ock=\"get"],[-1," b"],[1,"B"],[0,"uffer ||"]],"start1":9107,"start2":9107,"length1":18,"length2":17},{"diffs":[[0,"ock=\"get"],[-1," e"],[1,"E"],[0,"nvelope\""]],"start1":10243,"start2":10243,"length1":18,"length2":17},{"diffs":[[0,"ock=\"get"],[-1," h"],[1,"H"],[0,"eart"],[-1," r"],[1,"R"],[0,"ate\"\n   "]],"start1":10833,"start2":10833,"length1":24,"length2":22},{"diffs":[[0,"ock=\"get"],[-1," a"],[1,"A"],[0,"lpha"],[-1," w"],[1,"W"],[0,"aves\"\n  "]],"start1":11043,"start2":11043,"length1":24,"length2":22},{"diffs":[[0," block=\""],[-1,"p"],[1,"P"],[0,"rint $sh"]],"start1":13916,"start2":13916,"length1":17,"length2":17}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"331"],[1,"232"],[0,"\" y=\"-"],[-1,"3"],[1,"5"],[0,"5\"><"]],"start1":106,"start2":106,"length1":18,"length2":18}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":21,"length2":17}]}]},{"timestamp":1728058474091,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"spikerbit.startRecordingEMG()\nspikerbit.print(SignalShape.ENVELOPE)\n"],[0,"basic.fo"]],"start1":0,"start2":0,"length1":8,"length2":76}]}]},{"timestamp":1728492310435,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"/block><"],[1,"block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"><next><block type=\"spikerbit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">0</field></shadow></value></block></next></block></statement></block><"],[0,"/xml>"]],"start1":1031,"start2":1031,"length1":13,"length2":430}]}]},{"timestamp":1728492310475,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"custom.ts","patch":[{"diffs":[[0,"    "],[-1,"DEFAULT,\n    CONTROL"],[1,"RAW,\n    ENVELOPE"],[0,"\n}\n\n"]],"start1":95,"start2":95,"length1":28,"length2":25},{"diffs":[[0,"ck=\""],[-1,"S"],[1,"s"],[0,"tart"],[-1,"MuscleR"],[1," r"],[0,"ecording"],[1," EMG"],[0,"\"\n  "]],"start1":7361,"start2":7361,"length1":28,"length2":27},{"diffs":[[0,"ck=\""],[-1,"S"],[1,"s"],[0,"tart"],[-1,"HeartR"],[1," r"],[0,"ecording"],[1," ECG"],[0,"\"\n  "]],"start1":7840,"start2":7840,"length1":27,"length2":27},{"diffs":[[0,"ck=\""],[-1,"S"],[1,"s"],[0,"tart"],[-1,"BrainR"],[1," r"],[0,"ecording"],[1," EEG"],[0,"\"\n  "]],"start1":8310,"start2":8310,"length1":27,"length2":27},{"diffs":[[0,"% block=\"get"],[-1,"S"],[1," s"],[0,"ignal\"\n    e"]],"start1":8790,"start2":8790,"length1":25,"length2":26},{"diffs":[[0,"\"get"],[-1,"SignalBlock || from"],[1," buffer || of"],[0," las"]],"start1":9118,"start2":9118,"length1":27,"length2":21},{"diffs":[[0,"\"get"],[-1,"ControlSignal"],[1," envelope"],[0,"\"\n  "]],"start1":10255,"start2":10255,"length1":21,"length2":17},{"diffs":[[0,"ock=\"get"],[-1,"H"],[1," h"],[0,"eart"],[-1,"R"],[1," r"],[0,"ate\"\n   "]],"start1":10842,"start2":10842,"length1":22,"length2":24},{"diffs":[[0,"ock=\"get"],[-1,"A"],[1," a"],[0,"lpha"],[-1,"W"],[1," w"],[0,"aves\"\n  "]],"start1":11054,"start2":11054,"length1":22,"length2":24},{"diffs":[[0,"wer;\n    }\n\n\n   "],[-1," //"],[0," //% group=\"Expe"]],"start1":11147,"start2":11147,"length1":35,"length2":32},{"diffs":[[0,"ents helper\"\n   "],[-1," //"],[0," //% weight=30\n "]],"start1":11182,"start2":11182,"length1":35,"length2":32},{"diffs":[[0,"eight=30\n   "],[-1," //"],[0," //% block=\""]],"start1":11204,"start2":11204,"length1":27,"length2":24},{"diffs":[[0,"onstant\"\n   "],[-1," //"],[0," //% expanda"]],"start1":11270,"start2":11270,"length1":27,"length2":24},{"diffs":[[0,"\"enable\"\n   "],[-1," //"],[0," //% duratio"]],"start1":11310,"start2":11310,"length1":27,"length2":24},{"diffs":[[0,"w=timePicker\n   "],[-1," //"],[0," //% duration.de"]],"start1":11341,"start2":11341,"length1":35,"length2":32},{"diffs":[[0,"efl=1000\n   "],[-1," //"],[0," //% constan"]],"start1":11372,"start2":11372,"length1":27,"length2":24},{"diffs":[[0,"t.defl=1\n   "],[-1," //"],[0," export func"]],"start1":11396,"start2":11396,"length1":27,"length2":24},{"diffs":[[0,"number {\n   "],[-1," //"],[0,"     if (dur"]],"start1":11476,"start2":11476,"length1":27,"length2":24},{"diffs":[[0,"stant < 0) {\n   "],[-1," //"],[0,"         return "]],"start1":11516,"start2":11516,"length1":35,"length2":32},{"diffs":[[0,"n undefined;\n   "],[-1," //"],[0,"     }\n\n    //  "]],"start1":11546,"start2":11546,"length1":35,"length2":32},{"diffs":[[0,";\n        }\n\n   "],[-1," //"],[0,"     const start"]],"start1":11557,"start2":11557,"length1":35,"length2":32},{"diffs":[[0,"illis();\n   "],[-1," //"],[0,"     let val"]],"start1":11606,"start2":11606,"length1":27,"length2":24},{"diffs":[[0,"let val = 0;\n   "],[-1," //"],[0,"     let max_val"]],"start1":11623,"start2":11623,"length1":35,"length2":32},{"diffs":[[0,"        \n   "],[-1," //"],[0,"     while ("]],"start1":11661,"start2":11661,"length1":27,"length2":24},{"diffs":[[0," duration) {\n   "],[-1," //"],[0,"         val = g"]],"start1":11716,"start2":11716,"length1":35,"length2":32},{"diffs":[[0,"ope();\n\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"if (max_val "]],"start1":11755,"start2":11755,"length1":35,"length2":32},{"diffs":[[0,"< val) {\n   "],[-1," //"],[0,"            "]],"start1":11787,"start2":11787,"length1":27,"length2":24},{"diffs":[[0,"l = val;\n   "],[-1," //"],[0,"         }\n\n"]],"start1":11818,"start2":11818,"length1":27,"length2":24},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         serial."]],"start1":11829,"start2":11829,"length1":35,"length2":32},{"diffs":[[0,"iteLine(\"\");\n   "],[-1," //"],[0,"     }\n\n    //  "]],"start1":11863,"start2":11863,"length1":35,"length2":32},{"diffs":[[0,";\n        }\n\n   "],[-1," //"],[0,"     return max_"]],"start1":11874,"start2":11874,"length1":35,"length2":32},{"diffs":[[0,"ant;\n   "],[-1," //"],[0," }\n\n   "],[-1," //"],[0," //% gro"]],"start1":11917,"start2":11917,"length1":29,"length2":23},{"diffs":[[0,"ents helper\"\n   "],[-1," //"],[0," //% weight=29\n "]],"start1":11951,"start2":11951,"length1":35,"length2":32},{"diffs":[[0,"eight=29\n   "],[-1," //"],[0," //% block=\""]],"start1":11973,"start2":11973,"length1":27,"length2":24},{"diffs":[[0,"on (ms)\"\n   "],[-1," //"],[0," //% duratio"]],"start1":12020,"start2":12020,"length1":27,"length2":24},{"diffs":[[0,"mePicker\n   "],[-1," //"],[0," //% duratio"]],"start1":12055,"start2":12055,"length1":27,"length2":24},{"diffs":[[0,"efl=3000\n   "],[-1," //"],[0," export func"]],"start1":12082,"start2":12082,"length1":27,"length2":24},{"diffs":[[0,"r): number {\n   "],[-1," //"],[0,"     basic.pause"]],"start1":12136,"start2":12136,"length1":35,"length2":32},{"diffs":[[0," turning on\n\n   "],[-1," //"],[0,"     if (duratio"]],"start1":12208,"start2":12208,"length1":35,"length2":32},{"diffs":[[0," < 0) {\n    "],[-1,"//"],[0,"        "],[-1," "],[0,"return undef"]],"start1":12241,"start2":12241,"length1":35,"length2":32},{"diffs":[[0,"defined;\n   "],[-1," //"],[0,"     }\n     "]],"start1":12270,"start2":12270,"length1":27,"length2":24},{"diffs":[[0,"        \n   "],[-1," //"],[0,"     const T"]],"start1":12289,"start2":12289,"length1":27,"length2":24},{"diffs":[[0,"D = 50;\n\n   "],[-1," //"],[0,"     let sig"]],"start1":12320,"start2":12320,"length1":27,"length2":24},{"diffs":[[0," signal = 0;\n   "],[-1," //"],[0,"     let counter"]],"start1":12340,"start2":12340,"length1":35,"length2":32},{"diffs":[[0,"counter = 0;\n   "],[-1," //"],[0,"     let check_o"]],"start1":12365,"start2":12365,"length1":35,"length2":32},{"diffs":[[0," false;\n\n   "],[-1," //"],[0,"     const s"]],"start1":12402,"start2":12402,"length1":27,"length2":24},{"diffs":[[0,"illis();\n   "],[-1," //"],[0,"     while ("]],"start1":12447,"start2":12447,"length1":27,"length2":24},{"diffs":[[0," duration) {\n   "],[-1," //"],[0,"         signal "]],"start1":12502,"start2":12502,"length1":35,"length2":32},{"diffs":[[0,"lope();\n\n   "],[-1," //"],[0,"         whi"]],"start1":12543,"start2":12543,"length1":27,"length2":24},{"diffs":[[0,"SHOLD) {\n   "],[-1," //"],[0,"            "]],"start1":12584,"start2":12584,"length1":27,"length2":24},{"diffs":[[0,"ation) {\n   "],[-1," //"],[0,"            "]],"start1":12648,"start2":12648,"length1":27,"length2":24},{"diffs":[[0,"turn -1;\n   "],[-1," //"],[0,"            "]],"start1":12679,"start2":12679,"length1":27,"length2":24},{"diffs":[[0,"       }\n   "],[-1," //"],[0,"            "]],"start1":12697,"start2":12697,"length1":27,"length2":24},{"diffs":[[0,"tEnvelope();\n   "],[-1," //"],[0,"             che"]],"start1":12733,"start2":12733,"length1":35,"length2":32},{"diffs":[[0,"= true;\n    "],[-1,"//"],[0,"            "]],"start1":12773,"start2":12773,"length1":26,"length2":24},{"diffs":[[0,"                "],[-1," "],[0,"serial.writeLine"]],"start1":12781,"start2":12781,"length1":33,"length2":32},{"diffs":[[0,"ine(\"\");\n   "],[-1," //"],[0,"         }\n\n"]],"start1":12810,"start2":12810,"length1":27,"length2":24},{"diffs":[[0,"          }\n\n   "],[-1," //"],[0,"         if (che"]],"start1":12821,"start2":12821,"length1":35,"length2":32},{"diffs":[[0,"_once) {\n   "],[-1," //"],[0,"            "]],"start1":12855,"start2":12855,"length1":27,"length2":24},{"diffs":[[0,"unter++;\n   "],[-1," //"],[0,"            "]],"start1":12882,"start2":12882,"length1":27,"length2":24},{"diffs":[[0,"= false;\n   "],[-1," //"],[0,"         }\n\n"]],"start1":12918,"start2":12918,"length1":27,"length2":24},{"diffs":[[0,"      }\n\n   "],[-1," //"],[0,"         ser"]],"start1":12933,"start2":12933,"length1":27,"length2":24},{"diffs":[[0,"iteLine(\"\");\n   "],[-1," //"],[0,"     }\n\n    //  "]],"start1":12963,"start2":12963,"length1":35,"length2":32},{"diffs":[[0,";\n        }\n\n   "],[-1," //"],[0,"     return coun"]],"start1":12974,"start2":12974,"length1":35,"length2":32},{"diffs":[[0,"\n   "],[-1," //"],[0," }\n\n\n   "],[-1," //"],[0," //%"]],"start1":13010,"start2":13010,"length1":22,"length2":16},{"diffs":[[0," helper\"\n   "],[-1," //"],[0," //% weight="]],"start1":13045,"start2":13045,"length1":27,"length2":24},{"diffs":[[0,"eight=28\n   "],[-1," //"],[0," //% block=\""]],"start1":13063,"start2":13063,"length1":27,"length2":24},{"diffs":[[0,"reshold\"\n   "],[-1," //"],[0," //% expanda"]],"start1":13125,"start2":13125,"length1":27,"length2":24},{"diffs":[[0,"ble\"\n   "],[-1," //"],[0," //% thr"]],"start1":13169,"start2":13169,"length1":19,"length2":16},{"diffs":[[0,"l=50\n   "],[-1," //"],[0," export "]],"start1":13195,"start2":13195,"length1":19,"length2":16},{"diffs":[[0,"number {\n   "],[-1," //"],[0,"     basic.p"]],"start1":13257,"start2":13257,"length1":27,"length2":24},{"diffs":[[0,"ning on\n\n   "],[-1," //"],[0,"     if (thr"]],"start1":13329,"start2":13329,"length1":27,"length2":24},{"diffs":[[0,"d < 0) {\n   "],[-1," //"],[0,"         ret"]],"start1":13358,"start2":13358,"length1":27,"length2":24},{"diffs":[[0,"defined;\n   "],[-1," //"],[0,"     }\n\n    "]],"start1":13388,"start2":13388,"length1":27,"length2":24},{"diffs":[[0,"      }\n\n   "],[-1," //"],[0,"     const t"]],"start1":13399,"start2":13399,"length1":27,"length2":24},{"diffs":[[0,"reaction\n   "],[-1," //"],[0,"     let sig"]],"start1":13472,"start2":13472,"length1":27,"length2":24},{"diffs":[[0,"nal = 0;\n   "],[-1," //"],[0,"     let res"]],"start1":13496,"start2":13496,"length1":27,"length2":24},{"diffs":[[0,"me = 0;\n\n   "],[-1," //"],[0,"     const s"]],"start1":13526,"start2":13526,"length1":27,"length2":24},{"diffs":[[0,"llis();\n\n   "],[-1," //"],[0,"     signal "]],"start1":13571,"start2":13571,"length1":27,"length2":24},{"diffs":[[0,"();\n    "],[-1,"//"],[0,"    "],[-1," "],[0,"while (s"]],"start1":13608,"start2":13608,"length1":23,"length2":20},{"diffs":[[0,"shold) {\n   "],[-1," //"],[0,"         sig"]],"start1":13640,"start2":13640,"length1":27,"length2":24},{"diffs":[[0,"elope();\n   "],[-1," //"],[0,"         res"]],"start1":13676,"start2":13676,"length1":27,"length2":24},{"diffs":[[0,"artTime;\n   "],[-1," //"],[0,"         if "]],"start1":13732,"start2":13732,"length1":27,"length2":24},{"diffs":[[0,"e_limit;\n   "],[-1," //"],[0,"         ser"]],"start1":13793,"start2":13793,"length1":27,"length2":24},{"diffs":[[0,"ine(\"\");\n   "],[-1," //"],[0,"     }\n\n    "]],"start1":13827,"start2":13827,"length1":27,"length2":24},{"diffs":[[0,"  }\n\n   "],[-1," //"],[0,"     ret"]],"start1":13842,"start2":13842,"length1":19,"length2":16},{"diffs":[[0,"ime;\n   "],[-1," //"],[0," }\n\n    "]],"start1":13870,"start2":13870,"length1":19,"length2":16},{"diffs":[[0," block=\""],[-1,"P"],[1,"p"],[0,"rint $sh"]],"start1":13929,"start2":13929,"length1":17,"length2":17},{"diffs":[[0," $shape "],[-1,"S"],[1,"s"],[0,"ignal ||"]],"start1":13942,"start2":13942,"length1":17,"length2":17},{"diffs":[[0," == SignalShape."],[-1,"CONTROL"],[1,"ENVELOPE"],[0,") {\n            "]],"start1":14324,"start2":14324,"length1":39,"length2":40},{"diffs":[[0,"ape."],[-1,"CONTROL"],[1,"ENVELOPE"],[0,") {\n"]],"start1":15212,"start2":15212,"length1":15,"length2":16}]},{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"device_forever\" x=\"331\" y=\"-35\"><statement name=\"HANDLER\"><block type=\"controls_if\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\"><field name=\"OP\">GT</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"spikerbit_getEnvelope\"></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">25</field></shadow></value></block></value><statement name=\"DO0\"><block type=\"servoservosetangle\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractorPicker\"><field name=\"angle\">90</field></shadow></value></block></statement><statement name=\"ELSE\"><block type=\"servoservosetangle\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractorPicker\"><field name=\"angle\">180</field></shadow></value></block></statement></block></statement></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":973}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[1,"basic.forever(function () {\n    if (spikerbit.getEnvelope() > 25) {\n        servos.P0.setAngle(90)\n    } else {\n        servos.P0.setAngle(180)\n    }\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":1,"length2":153}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":578,"start2":578,"length1":17,"length2":21}]}]},{"timestamp":1728492745145,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":585,"start2":585,"length1":21,"length2":17}]}]},{"timestamp":1728494865248,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"es><"],[-1,"block type=\"spikerbit_print\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"169\" y=\"303\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.DEFAULT</field><value name=\"duration\"><shadow type=\"timePicker\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"ms\">0</field></shadow></value></block><"],[0,"/xml"]],"start1":75,"start2":75,"length1":381,"length2":8}]}]},{"timestamp":1728494869038,"editorVersion":"7.0.42","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"spikerbit_print\" disabled-reasons=\"ORPHANED_BLOCK,MANUALLY_DISABLED\" x=\"169\" y=\"303\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.DEFAULT</field><value name=\"duration\"><shadow type=\"timePicker\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"ms\">0</field></shadow></value></block><"],[0,"/xml>"]],"start1":71,"start2":71,"length1":13,"length2":386}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"\": \""],[-1,"spikerBit_extension (demo for SFN)"],[1,"Free Testing Space - Copy"],[0,"\",\n "]],"start1":11,"start2":11,"length1":42,"length2":33},{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":314,"start2":314,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1725891104299,"editorVersion":"7.0.40","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"Fke=%BI3oq47G6U{e$6P\">sample_rate</variable><variable id=\"a`Vjw}{(7r51K7*i!Ew9\">time_interval</variable><variable id=\"SaR-W{{t*DLq$zfH1kR^\">running_time</variable><variable id=\"7eSLJp2;Sg%x`wH111in\">start_time</variable><variable id=\"eR76fk0k{{Q}#-rS+-m+\">begin_time</variable><variable id=\")Pvo]W+hcM!Pg9{uYV{5\">elapsed_time</variable><variable id=\"NK$54-HQfc(iN)O6G^YZ\">num</variable><variable id=\"s!1WLt6=qii!jw3yXTh{\">bool</variable></variables><block type=\"pxt-on-start\" x=\"-159\" y=\"-1378\"><statement name=\"HANDLER\"><block type=\"basic_show_icon\"><field name=\"i\">IconNames.Heart</field><next><block type=\"basic_show_icon\"><field name=\"i\">IconNames.SmallHeart</field><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_return_size\"></block></value></block></next></block></next></block></statement></block><block type=\"variables_set\" disabled=\"true\" x=\"423\" y=\"-350\"><field name=\"VAR\" id=\"s!1WLt6=qii!jw3yXTh{\">bool</field><value name=\"VALUE\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">0</field></shadow><block type=\"logic_boolean\" disabled=\"true\"><field name=\"BOOL\">TRUE</field></block></value><next><block type=\"variables_set\" disabled=\"true\"><field name=\"VAR\" id=\"7eSLJp2;Sg%x`wH111in\">start_time</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"device_get_running_time_micros\" disabled=\"true\"></block></value></block></next></block><block type=\"basic_show_icon\" disabled=\"true\" x=\"544\" y=\"-160\"><field name=\"i\">IconNames.Heart</field><next><block type=\"basic_show_icon\" disabled=\"true\"><field name=\"i\">IconNames.SmallHeart</field></block></next></block><block type=\"variables_set\" disabled=\"true\" x=\"255\" y=\"-39\"><field name=\"VAR\" id=\"s!1WLt6=qii!jw3yXTh{\">bool</field><value name=\"VALUE\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">0</field></shadow><block type=\"logic_boolean\" disabled=\"true\"><field name=\"BOOL\">FALSE</field></block></value></block><block type=\"device_while\" disabled=\"true\" x=\"0\" y=\"0\"><value name=\"COND\"><shadow type=\"logic_boolean\" disabled=\"true\"><field name=\"BOOL\">TRUE</field></shadow></value></block><block type=\"control_running_time\" disabled=\"true\" x=\"462\" y=\"39\"></block><block type=\"continue_keyword\" disabled=\"true\" x=\"432\" y=\"87\"></block><block type=\"math_arithmetic\" disabled=\"true\" x=\"753\" y=\"192\"><field name=\"OP\">MINUS</field><value name=\"A\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">0</field></shadow><block type=\"device_get_running_time_micros\" disabled=\"true\"></block></value><value name=\"B\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\" disabled=\"true\"><field name=\"VAR\" id=\"7eSLJp2;Sg%x`wH111in\">start_time</field></block></value></block><block type=\"device_show_number\" disabled=\"true\" x=\"330\" y=\"393\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_return_size\" disabled=\"true\"></block></value></block><block type=\"basic_show_icon\" disabled=\"true\" x=\"629\" y=\"406\"><field name=\"i\">IconNames.SmallHeart</field><next><block type=\"basic_show_icon\" disabled=\"true\"><field name=\"i\">IconNames.Heart</field><next><block type=\"basic_show_icon\" disabled=\"true\"><field name=\"i\">IconNames.SmallHeart</field></block></next></block></next></block><block type=\"device_show_number\" disabled=\"true\" x=\"125\" y=\"443\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\" disabled=\"true\"><field name=\"VAR\" id=\"NK$54-HQfc(iN)O6G^YZ\">num</field></block></value><next><block type=\"device_pause\" disabled=\"true\"><value name=\"pause\"><shadow type=\"timePicker\" disabled=\"true\"><field name=\"ms\">1000</field></shadow></value></block></next></block><block type=\"device_while\" disabled=\"true\" x=\"381\" y=\"455\"><value name=\"COND\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\" disabled=\"true\"><field name=\"OP\">LT</field><value name=\"A\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\" disabled=\"true\"><field name=\"OP\">MINUS</field><value name=\"A\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">0</field></shadow><block type=\"control_running_time\" disabled=\"true\"></block></value><value name=\"B\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\" disabled=\"true\"><field name=\"VAR\" id=\"7eSLJp2;Sg%x`wH111in\">start_time</field></block></value></block></value><value name=\"B\"><shadow type=\"math_number\" disabled=\"true\"><field name=\"NUM\">1000</field></shadow></value></block></value><statement name=\"DO\"><block type=\"continue_keyword\" disabled=\"true\"></block></statement></block></xml>","main.ts":"","README.md":"","custom.ts":"//Developed by Marcio \"Max\" Amorim and Chethan Magnan\n//Filter from Stan Mircic\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    let buffer: number[] = [];\n    control.inBackground(() => {\n        while (true) {\n            buffer.push(0);\n            basic.pause(1); // Need this, otherwise overflow\n        }\n    })\n\n    //% weight=100 block=\"return buffer size\"\n    export function return_size(): number {\n        return buffer.length;\n    }\n\n    // //% weight=50 blockId=\"neurobit_EMG_Filter\" block=\"EMG Filtered\"\n    // export function renvelope(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=49 blockId=\"neurobit_ECG_Filter\" block=\"ECG Filter\"\n    // //display.off()\n    // export function reecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=48 blockId=\"neurobit_EOG\" block=\"EOG\"\n    // //display.off()\n    // export function eog(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=47 blockId=\"neurobit_EMG\" block=\"Raw EMG\"\n    // //display.off()\n    // export function emg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=32 blockId=\"neurobit_ECG\" block=\"Raw ECG\"\n    // //display.off()\n    // export function ecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% subcategory=\"Filters\"\n    // //% blockId=\"lowPassFilter\" block=\"Low Pass Filter of %signal with alpah %alpha range (0-1]\"\n    // //display.off()\n    // export function LowPassFilter(signal: number, alpha: number): number {\n    //     let filteredSignal = 0;\n    //     if (prior == 0) {\n    //         prior = signal;\n    //     }\n    //     filteredSignal = alpha * prior + (1.0 - alpha) * signal;\n    //     prior = filteredSignal;\n    //     return filteredSignal;\n    // }\n\n    // let highPassPriorInput = 0;\n    // let highPassPriorOutput = 0;\n    // let lowPassPriorOutput = 0;\n\n    // // sample rate of 1000 Hz\n    // const sampleRate = 1000;\n\n    // // High-pass filter coefficients (1 Hz cutoff frequency)\n    // const highPassAlpha = 2 * Math.PI * 1 / sampleRate;\n\n    // // Low-pass filter coefficients (100 Hz cutoff frequency)\n    // const lowPassAlpha = 2 * Math.PI * 100 / sampleRate;\n\n    // //% subcategory=\"Filters\"\n    // //% blockId=\"bandPassFilter\" block=\"Band Pass Filter of %signal\"\n    // //display.off()\n    // export function BandPassFilter(signal: number): number {\n    //     // High-pass filter\n    //     let highPassFiltered = highPassAlpha * (highPassPriorOutput + signal - highPassPriorInput);\n    //     highPassPriorInput = signal;\n    //     highPassPriorOutput = highPassFiltered;\n\n    //     // Low-pass filter\n    //     let lowPassFiltered = lowPassAlpha * highPassFiltered + (1 - lowPassAlpha) * lowPassPriorOutput;\n    //     lowPassPriorOutput = lowPassFiltered;\n\n    //     return lowPassFiltered;\n    // }\n}","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1725893896559,"editorVersion":"7.0.40","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"Fke=%BI3oq47G6U{e$6P\">sample_rate</variable><variable id=\"a`Vjw}{(7r51K7*i!Ew9\">time_interval</variable><variable id=\"SaR-W{{t*DLq$zfH1kR^\">running_time</variable><variable id=\"7eSLJp2;Sg%x`wH111in\">start_time</variable><variable id=\"eR76fk0k{{Q}#-rS+-m+\">begin_time</variable><variable id=\")Pvo]W+hcM!Pg9{uYV{5\">elapsed_time</variable><variable id=\"NK$54-HQfc(iN)O6G^YZ\">num</variable><variable id=\"s!1WLt6=qii!jw3yXTh{\">bool</variable></variables><block type=\"pxt-on-start\" x=\"-159\" y=\"-1378\"><statement name=\"HANDLER\"><block type=\"basic_show_icon\"><field name=\"i\">IconNames.Heart</field><next><block type=\"basic_show_icon\"><field name=\"i\">IconNames.SmallHeart</field><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_return_size\"></block></value></block></next></block></next></block></statement></block><block type=\"variables_set\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"423\" y=\"-350\"><field name=\"VAR\" id=\"s!1WLt6=qii!jw3yXTh{\">bool</field><value name=\"VALUE\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"logic_boolean\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"BOOL\">TRUE</field></block></value><next><block type=\"variables_set\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"VAR\" id=\"7eSLJp2;Sg%x`wH111in\">start_time</field><value name=\"VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"device_get_running_time_micros\" disabled-reasons=\"MANUALLY_DISABLED\"></block></value></block></next></block><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"544\" y=\"-160\"><field name=\"i\">IconNames.Heart</field><next><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"i\">IconNames.SmallHeart</field></block></next></block><block type=\"variables_set\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"255\" y=\"-39\"><field name=\"VAR\" id=\"s!1WLt6=qii!jw3yXTh{\">bool</field><value name=\"VALUE\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"logic_boolean\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"BOOL\">FALSE</field></block></value></block><block type=\"device_while\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"0\" y=\"0\"><value name=\"COND\"><shadow type=\"logic_boolean\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"BOOL\">TRUE</field></shadow></value></block><block type=\"control_running_time\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"462\" y=\"39\"></block><block type=\"continue_keyword\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"432\" y=\"87\"></block><block type=\"math_arithmetic\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"753\" y=\"192\"><field name=\"OP\">MINUS</field><value name=\"A\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"device_get_running_time_micros\" disabled-reasons=\"MANUALLY_DISABLED\"></block></value><value name=\"B\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"VAR\" id=\"7eSLJp2;Sg%x`wH111in\">start_time</field></block></value></block><block type=\"device_show_number\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"330\" y=\"393\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_return_size\" disabled-reasons=\"MANUALLY_DISABLED\"></block></value></block><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"629\" y=\"406\"><field name=\"i\">IconNames.SmallHeart</field><next><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"i\">IconNames.Heart</field><next><block type=\"basic_show_icon\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"i\">IconNames.SmallHeart</field></block></next></block></next></block><block type=\"device_show_number\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"125\" y=\"443\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"VAR\" id=\"NK$54-HQfc(iN)O6G^YZ\">num</field></block></value><next><block type=\"device_pause\" disabled-reasons=\"MANUALLY_DISABLED\"><value name=\"pause\"><shadow type=\"timePicker\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"ms\">1000</field></shadow></value></block></next></block><block type=\"device_while\" disabled-reasons=\"MANUALLY_DISABLED\" x=\"381\" y=\"455\"><value name=\"COND\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"OP\">LT</field><value name=\"A\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"math_arithmetic\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"OP\">MINUS</field><value name=\"A\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"control_running_time\" disabled-reasons=\"MANUALLY_DISABLED\"></block></value><value name=\"B\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">0</field></shadow><block type=\"variables_get\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"VAR\" id=\"7eSLJp2;Sg%x`wH111in\">start_time</field></block></value></block></value><value name=\"B\"><shadow type=\"math_number\" disabled-reasons=\"MANUALLY_DISABLED\"><field name=\"NUM\">1000</field></shadow></value></block></value><statement name=\"DO\"><block type=\"continue_keyword\" disabled-reasons=\"MANUALLY_DISABLED\"></block></statement></block></xml>","main.ts":"basic.showIcon(IconNames.Heart)\nbasic.showIcon(IconNames.SmallHeart)\nbasic.showNumber(neurobit.return_size())\n","README.md":"","custom.ts":"//Developed by Marcio \"Max\" Amorim and Chethan Magnan\n//Filter from Stan Mircic\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    let buffer: number[] = [];\n    control.inBackground(() => {\n        while (true) {\n            buffer.push(0);\n            // basic.pause(1); // Need this, otherwise overflow\n        }\n    })\n\n    //% weight=100 block=\"return buffer size\"\n    export function return_size(): number {\n        return buffer.length;\n    }\n\n    // //% weight=50 blockId=\"neurobit_EMG_Filter\" block=\"EMG Filtered\"\n    // export function renvelope(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=49 blockId=\"neurobit_ECG_Filter\" block=\"ECG Filter\"\n    // //display.off()\n    // export function reecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=48 blockId=\"neurobit_EOG\" block=\"EOG\"\n    // //display.off()\n    // export function eog(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=47 blockId=\"neurobit_EMG\" block=\"Raw EMG\"\n    // //display.off()\n    // export function emg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=32 blockId=\"neurobit_ECG\" block=\"Raw ECG\"\n    // //display.off()\n    // export function ecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% subcategory=\"Filters\"\n    // //% blockId=\"lowPassFilter\" block=\"Low Pass Filter of %signal with alpah %alpha range (0-1]\"\n    // //display.off()\n    // export function LowPassFilter(signal: number, alpha: number): number {\n    //     let filteredSignal = 0;\n    //     if (prior == 0) {\n    //         prior = signal;\n    //     }\n    //     filteredSignal = alpha * prior + (1.0 - alpha) * signal;\n    //     prior = filteredSignal;\n    //     return filteredSignal;\n    // }\n\n    // let highPassPriorInput = 0;\n    // let highPassPriorOutput = 0;\n    // let lowPassPriorOutput = 0;\n\n    // // sample rate of 1000 Hz\n    // const sampleRate = 1000;\n\n    // // High-pass filter coefficients (1 Hz cutoff frequency)\n    // const highPassAlpha = 2 * Math.PI * 1 / sampleRate;\n\n    // // Low-pass filter coefficients (100 Hz cutoff frequency)\n    // const lowPassAlpha = 2 * Math.PI * 100 / sampleRate;\n\n    // //% subcategory=\"Filters\"\n    // //% blockId=\"bandPassFilter\" block=\"Band Pass Filter of %signal\"\n    // //display.off()\n    // export function BandPassFilter(signal: number): number {\n    //     // High-pass filter\n    //     let highPassFiltered = highPassAlpha * (highPassPriorOutput + signal - highPassPriorInput);\n    //     highPassPriorInput = signal;\n    //     highPassPriorOutput = highPassFiltered;\n\n    //     // Low-pass filter\n    //     let lowPassFiltered = lowPassAlpha * highPassFiltered + (1 - lowPassAlpha) * lowPassPriorOutput;\n    //     lowPassPriorOutput = lowPassFiltered;\n\n    //     return lowPassFiltered;\n    // }\n}","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1726089500681,"editorVersion":"7.0.40","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><block type=\"neurobit_return_size\"></block></value></block></next></block></statement></block></xml>","main.ts":"","README.md":"","custom.ts":"//Developed by Marcio \"Max\" Amorim and Chethan Magnan\n//Filter from Stan Mircic\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    let buffer: number[] = [];\n    control.inBackground(() => {\n        while (true) {\n            buffer.push(pins.analogReadPin(AnalogPin.P0));\n            basic.pause(2); // Need this, otherwise overflow\n        }\n    })\n\n    //% weight=100 block=\"return buffer size\"\n    export function return_size(): number {\n        return buffer.length;\n    }\n\n    // //% weight=50 blockId=\"neurobit_EMG_Filter\" block=\"EMG Filtered\"\n    // export function renvelope(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=49 blockId=\"neurobit_ECG_Filter\" block=\"ECG Filter\"\n    // //display.off()\n    // export function reecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=48 blockId=\"neurobit_EOG\" block=\"EOG\"\n    // //display.off()\n    // export function eog(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=47 blockId=\"neurobit_EMG\" block=\"Raw EMG\"\n    // //display.off()\n    // export function emg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% weight=32 blockId=\"neurobit_ECG\" block=\"Raw ECG\"\n    // //display.off()\n    // export function ecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // //% subcategory=\"Filters\"\n    // //% blockId=\"lowPassFilter\" block=\"Low Pass Filter of %signal with alpah %alpha range (0-1]\"\n    // //display.off()\n    // export function LowPassFilter(signal: number, alpha: number): number {\n    //     let filteredSignal = 0;\n    //     if (prior == 0) {\n    //         prior = signal;\n    //     }\n    //     filteredSignal = alpha * prior + (1.0 - alpha) * signal;\n    //     prior = filteredSignal;\n    //     return filteredSignal;\n    // }\n\n    // let highPassPriorInput = 0;\n    // let highPassPriorOutput = 0;\n    // let lowPassPriorOutput = 0;\n\n    // // sample rate of 1000 Hz\n    // const sampleRate = 1000;\n\n    // // High-pass filter coefficients (1 Hz cutoff frequency)\n    // const highPassAlpha = 2 * Math.PI * 1 / sampleRate;\n\n    // // Low-pass filter coefficients (100 Hz cutoff frequency)\n    // const lowPassAlpha = 2 * Math.PI * 100 / sampleRate;\n\n    // //% subcategory=\"Filters\"\n    // //% blockId=\"bandPassFilter\" block=\"Band Pass Filter of %signal\"\n    // //display.off()\n    // export function BandPassFilter(signal: number): number {\n    //     // High-pass filter\n    //     let highPassFiltered = highPassAlpha * (highPassPriorOutput + signal - highPassPriorInput);\n    //     highPassPriorInput = signal;\n    //     highPassPriorOutput = highPassFiltered;\n\n    //     // Low-pass filter\n    //     let lowPassFiltered = lowPassAlpha * highPassFiltered + (1 - lowPassAlpha) * lowPassPriorOutput;\n    //     lowPassPriorOutput = lowPassFiltered;\n\n    //     return lowPassFiltered;\n    // }\n}","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1726617155046,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><block type=\"neurobit_return_size\"></block></value></block></next></block></statement></block></xml>","main.ts":"\n","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EEG,\n    EMG,\n    ECG,\n    EOG\n}\n\nenum Cue {\n    none,\n    visual,\n    audio\n}\n\nenum LookingAt {\n    none,\n    up,\n    left,\n    right,\n    down,\n    blink\n}\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    /**\n     * Background Process\n     */\n\n\n    /**\n     * Global initialization\n     */\n    let apply_envelope = false;\n    let envelope_buffer: number[] = [];\n    let envelope_sum = 0;\n    function convolution(new_signal: number) {\n        //Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        if (envelope_buffer.length < window_size) {\n            // Only push the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum += new_signal;\n\n            return 0;\n        }\n        else {\n            // Update the buffer\n            let old_signal = envelope_buffer.shift();\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Return pin to record EEG\n     */\n\n    //% group=\"Signal\"\n    //% weight=50 \n    //% block=\"EEG\"\n    export function eeg(): number {\n        return pins.analogReadPin(AnalogPin.P0);\n    }\n\n\n    /**\n     * Return pin to record EMG\n     */\n\n    //% group=\"Signal\"\n    //% weight=49 \n    //% block=\"EMG\"\n    export function emg(): number {\n        // Check switch here\n        return pins.analogReadPin(AnalogPin.P0);\n    }\n\n\n    /**\n     * Return pin to record ECG\n     */\n\n    //% group=\"Signal\"\n    //% weight=48\n    //% block=\"ECG\"\n    export function ecg(): number {\n        return pins.analogReadPin(AnalogPin.P1);\n    }\n\n    /**\n     * Return pin to record EOG\n     */\n\n    //% group=\"Signal\"\n    //% weight=47\n    //% block=\"EOG\"\n    export function eog(): number {\n        return pins.analogReadPin(AnalogPin.P0);\n    }\n\n    /**\n     * Return the maximum threshold from some time intervals(ms).\n     * As an optional argument, you can change the percentage of threshold\n     * to be returned. The defaulut is 100(%).\n     * @param ms = duration(ms) to run the get and caluculate max theshold.\n     * @param percent (optional) = number as percentage of threshold to be returned. The default is 100%.\n     */\n\n    //% group=\"EMG\"\n    //% weight=46\n    //% block=\"get threshold from $ms ms || and return with $percent percent\"\n    //% expandableArgumentMode=\"enable\"\n    //% ms.shadow=timePicker\n    //% percent.defl=100\n    export function getThreshold(ms: number, percent?: number) {\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n\n        while (control.millis() - startTimer < ms) {\n            val = emg();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n        }\n\n        return max_val * (percent / 100);\n    }\n\n\n    /**\n     * Return the number of spikes that happened during some duration(ms).\n     * You can also change the duration but the default is 3000 (i.e. 3 seconds).\n     * If you grip tight for minimum 500ms (then release), \n     * it will return as -1. \n     * @param ms = duration(ms) to run the spike recording.\n     */\n\n    //% group=\"EMG\"\n    //% weight=45\n    //% block=\"count spikes for $ms ms\"\n    //% ms.shadow=timePicker\n    //% ms.defl=3000\n    export function countSpikes(ms: number) {\n        const down_sample_fs = 200;\n        const period = 1000000 / down_sample_fs;\n        let elapsed_time = 0;\n        let elapsed_time2 = 0;\n\n        const buffer_size = 20;\n        let buffer: number[] = [];\n\n        // Smoothing function for signal\n        function movingAverage(data: number[], windowSize: number): number {\n            let sum = 0.0;\n            let smoothedData = 0;\n            //overflow -> floating point\n            for (let j = 0; j < windowSize; j++) {\n                sum += data[j];\n            }\n            smoothedData = sum / windowSize;\n            return smoothedData;\n        }\n\n        const threshold = 150;\n        const interval = 500;\n        let signal = 0;\n        let smooth_signal = 0;\n        let counter = 0;\n        let checking = false;\n        let check_time = -interval;\n        let check_grip = false;\n\n        const startTimer = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Begin Timer\n        while (control.millis() - startTimer < ms) {\n            signal = emg();\n\n            // Fill the buffer before the main process\n            if (buffer.length < buffer_size) {\n                buffer.push(signal);\n            }\n\n            // Once the buffer fills up, shift\n            if (buffer.length == buffer_size) {\n                buffer.shift();\n                buffer.push(signal);\n\n                // Smooth out the signal\n                smooth_signal = movingAverage(buffer, buffer.length);\n\n                // Check the signal above threshold\n                let sample_time2 = input.runningTimeMicros();\n                while (smooth_signal > threshold) {\n                    signal = emg();\n\n                    buffer.shift();\n                    buffer.push(signal);\n\n                    smooth_signal = movingAverage(buffer, buffer.length);\n\n                    if (!checking) {\n                        // Record the time when the spike is detected\n                        // for only once at the beggining during the rising\n                        check_time = control.millis();\n                        checking = true;\n                    }\n\n                    // Checking for grip\n                    check_grip = true;\n\n                    elapsed_time2 = input.runningTimeMicros() - sample_time2;\n\n                    if (elapsed_time2 < period) {\n                        control.waitMicros(period - elapsed_time2);\n                    }\n\n                    sample_time2 = input.runningTimeMicros();\n                }\n\n                // Once signl drops down below the threshold, allow \n                // check (for spike) to happen\n                checking = false;\n\n                // Check if the spike is within the interval window\n                // to reduce false positives\n                if (control.millis() - check_time < interval) {\n                    check_grip = false;\n                    counter++; // Increment counter for detected spikes\n                    check_time = -interval; // Reset check time\n                }\n\n                // If the signal goes over one second, assume due to\n                // the grip\n                if (check_grip) {\n                    counter = -1;\n                }\n\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();\n        }\n\n        return counter; // Return the spike count\n    }\n\n\n    /**\n     * Give the reaction time from certain cue. User have options to\n     * choose either from visual (Heart Icon) or audio (1/2 beat) cue\n     * with given threshold. \n     * @param cue (optional) = options for user to choose type of cue (visually or auditory). The default is none.\n     * @param threshold (optional) = user have option to select their desired threshold. The default is 200.\n     */\n\n    //% group=\"EMG\"\n    //% weight=44\n    //% block=\"measure reaction time ||add cue $cue add threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=200\n    //% inlineInputMode=inline\n    export function reactionTime(cue?: Cue, threshold?: number) {\n        const cue_time = 100; // [ms]\n        const ms = 1500; // Give user 1.5 seconds to make reaction\n        let signal = 0;\n        let result = ms;\n        let once = true;\n\n        //At beggining, give user a cue if needed\n        switch (cue) {\n            case Cue.none: {\n                break;\n            }\n            case Cue.visual: {\n                basic.showIcon(IconNames.Heart, cue_time);\n                basic.clearScreen();\n                break;\n            }\n            case Cue.audio: {\n                pins.setAudioPin(AnalogPin.P16);\n                music.play(music.tonePlayable(262, cue_time),\n                    music.PlaybackMode.InBackground);\n                break;\n            }\n        }\n\n        const startTime = control.millis();\n\n        // Begin measuring the reaction time\n        while (control.millis() - startTime < ms) {\n            signal = emg();\n            // (only once) if the signal go above the threshold,\n            // save the reaction time. \n            if (signal > threshold && once) {\n                result = control.millis() - startTime;\n                once = false;\n            }\n        }\n\n        // If user fails to react, return as undefined (question mark)\n        if (result == ms) {\n            return undefined;\n        }\n        else {\n            return result;\n        }\n    }\n\n\n    /**\n     * Return the average heart beat (bpm) in 5 seconds(default).\n     * You can also change the time for recording from \n     * optional argument.\n     * @param ms (optional) = duration(ms) to run the hearbeat recording. The default is 5000 (i.e. 5 seconds).\n     */\n\n    //% group=\"ECG\"\n    //% weight=43\n    //% block=\"measure heartbeat (bpm) || for $ms ms\"\n    //% ms.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% ms.defl=5000\n    export function heartBeat(ms: number) {\n        const down_sample_fs = 150 //Hz;\n        const period = 1000000 / down_sample_fs;\n        let elapsed_time = 0\n\n        const range = 300;\n        const buffer_size = 6;\n        let buffer: number[] = [];\n        // let buffer_index = 0;\n        let beat_num = 0;\n        let unit = 0;\n        let sum_unit = 0;\n        let wait = 0;\n        let last_beat = 0;\n\n\n        // Fill the buffer first\n        for (let i = 0; i < buffer_size; i++) {\n            buffer.push(ecg());\n        }\n\n        const startTime = control.millis();\n        let prev_beat = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Keep running until time runs out\n        while (control.millis() - startTime < ms) {\n            if (wait <= 0) {\n\n                // Buffer minimum, maximum calculation\n                let buffer_min = buffer[0];\n                let buffer_max = buffer[0];\n\n                for (let i = 1; i < buffer_size; i++) {\n                    if (buffer_min > buffer[i]) {\n                        buffer_min = buffer[i];\n                    }\n\n                    if (buffer_max < buffer[i]) {\n                        buffer_max = buffer[i];\n                    }\n                }\n\n                // If the range of buffer is greator than certain range,\n                // do heartbeat caluculation\n                if (buffer_max - buffer_min > range) {\n                    basic.showIcon(IconNames.Heart, 150);\n                    basic.clearScreen();\n                    last_beat = control.millis() - prev_beat;\n                    prev_beat = control.millis();\n                    let largeBox = Math.floor(last_beat / 200);\n                    let smallBox = Math.floor((last_beat - largeBox * 200) / 40);\n                    unit = 1 * largeBox + 0.2 * smallBox;\n                    sum_unit += unit;\n                    beat_num++;\n                    // Wait for buffer_size * 3. \n                    // This is possible because distance between\n                    // human heart beat is no smaller than time for\n                    // buffer_size * 3 samples\n                    wait = buffer_size * 3;\n                }\n            }\n\n\n            // May need to use shift\n            buffer.shift();\n            buffer.push(ecg());\n            // buffer[buffer_index] = val;\n            // buffer_index = (buffer_index + 1) % buffer_size;\n            wait--;\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time)\n            }\n\n            sample_time = input.runningTimeMicros()\n        }\n\n        // Check to avoid division by zero\n        return beat_num > 0 ? 300 / (sum_unit / beat_num) : undefined;\n    }\n\n\n    let currently_up = false;\n    let currently_down = false;\n    let center_UD = false;\n    let cooldown_counter = 0;\n    let blink_buffer: number[] = [];\n    let updown_buffer: number[] = [];\n\n    /**\n     * Return enums (up/down/blink) if user move their eyes in\n     * vertical direction.\n     */\n\n    //% group=\"EOG\"\n    //% weight=42\n    //% block=\"direction (VEOG)\"\n    export function gazeV(): number {\n        const time = 500; // [ms]\n\n        const down_sample_fs = 50; // [Hz]\n        const period = 1000000 / down_sample_fs; // [μs/hz]\n        let elapsed_time = 0;\n\n        let result = LookingAt.none;\n\n        const baseline = 450;\n\n        const buffer_size = 10;\n        const wait_size = Math.floor(down_sample_fs / 3); // 1/3 of second\n        let avgBuffer = 0;\n\n        let slope = 0;\n        const cooldown_period = wait_size + buffer_size;\n\n        // Function to return the averge slope of buffer\n        function calculateSlope(data: number[]): number {\n            const n = data.length;\n            let xSum = 0;\n            let ySum = 0;\n            let xySum = 0;\n            let xSquaredSum = 0;\n\n            for (let x = 0; x < n; x++) {\n                xSum += x;\n                ySum += data[x];\n                xySum += x * data[x];\n                xSquaredSum += x * x;\n            }\n\n            return (n * xySum - xSum * ySum) / (n * xSquaredSum - xSum * xSum);\n        }\n\n        const start_time = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Keep running until time runs out\n        while (control.millis() - start_time < time) {\n            let signal = eog();\n\n            // Shift the buffer so blink analysis happens eariler than\n            // up or down analysis\n            if (blink_buffer.length < wait_size) {\n                blink_buffer.push(signal);\n            } else {\n                if (updown_buffer.length < buffer_size) {\n                    updown_buffer.push(blink_buffer.shift());\n                } else {\n                    updown_buffer.shift();\n                    updown_buffer.push(blink_buffer.shift());\n                }\n\n                blink_buffer.push(signal);\n            }\n\n            if (updown_buffer.length == buffer_size) {\n                slope = calculateSlope(blink_buffer.slice(0, buffer_size));\n                avgBuffer = updown_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n                // Blinking\n                if (slope < -75) {\n                    // Begin cool down\n                    cooldown_counter = 0;\n                    result = LookingAt.blink;\n                }\n\n                // If cooldown is happening\n                if (cooldown_counter >= cooldown_period) {\n                    // Looking Up\n                    if (avgBuffer > baseline * 1.40) {\n                        if (currently_down) {\n                            center_UD = true;\n                        } else {\n                            result = LookingAt.up;\n                            center_UD = false;\n                            currently_up = true;\n                        }\n                        // Looking Down \n                    } else if (avgBuffer < baseline * 0.60) {\n                        if (currently_up) {\n                            center_UD = true;\n                        } else {\n                            result = LookingAt.down;\n                            center_UD = false;\n                            currently_down = true;\n                        }\n                    } else {\n                        if (center_UD) {\n                            currently_up = false;\n                            currently_down = false;\n                        }\n                    }\n                } else {\n                    cooldown_counter++;\n                }\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();\n        }\n\n        return result;\n\n    }\n\n\n    let currently_left = false;\n    let currently_right = false;\n    let center_LR = false;\n    let leftright_buffer: number[] = [];\n\n    /**\n     * Return enums (left/right) if user move their eyes in\n     * horizontal direction.\n     */\n\n    //% group=\"EOG\"\n    //% weight=41\n    //% block=\"direction (HEOG)\"\n    export function gazeH(): number {\n        const time = 500; // [ms]\n\n        const down_sample_fs = 50 // [Hz]\n        const period = 1000000 / down_sample_fs // [μs/hz]\n        let elapsed_time = 0;\n\n        let result = LookingAt.none;\n\n        const baseline = 450;\n\n        const buffer_size = 10;\n        let avgBuffer = 0;\n\n        const start_time = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Keep running until time runs out\n        while (control.millis() - start_time < time) {\n            let signal = eog();\n\n            // If the buffer is not full yet, keep adding\n            if (leftright_buffer.length < buffer_size) {\n                leftright_buffer.push(signal);\n            }\n\n            // If the buffer is full, begin main process\n            if (leftright_buffer.length == buffer_size) {\n                leftright_buffer.shift();\n                leftright_buffer.push(signal);\n\n                // Calculate average of buffer\n                avgBuffer = leftright_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n                // Looking Left\n                if (avgBuffer > baseline * 1.25) {\n                    if (currently_right) {\n                        center_LR = true;\n                    }\n                    else {\n                        center_LR = false;\n                        currently_left = true;\n                        result = LookingAt.left;\n                    }\n                }\n                // Looking Right\n                else if (avgBuffer < baseline * 0.75) {\n                    if (currently_left) {\n                        center_LR = true;\n                    }\n                    else {\n                        center_LR = false;\n                        currently_right = true;\n                        result = LookingAt.right;\n                    }\n                }\n                else {\n                    if (center_LR) {\n                        currently_left = false;\n                        currently_right = false;\n                    }\n                }\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();\n        }\n\n        return result;\n\n    }\n\n\n    /**\n     * Return true if user blinks within some time, false otherwise.\n     * Defining time is optional argument (the default is one second). \n     * @param ms (optional) = duration(ms) to check blink. The default is 1000 (i.e 1 seconds).\n     */\n\n    //% group=\"EOG\"\n    //% weight=40\n    //% block=\"blinked|| within $ms ms\"\n    //% ms.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% ms.defl=1000\n    export function blinks(ms?: number): boolean {\n        const down_sample_fs = 50 //[Hz]\n        const period = 1000000 / down_sample_fs //[μs/hz]\n        let elapsed_time = 0;\n\n        const buffer_size = 2;\n        let buffer = [];\n\n        const threshold = 40;\n        const blink_time = 300; //[ms]\n\n        let blink_check_timer = 0;\n        let start_val = 0;\n        let currently_checking = false;\n\n        let exit = false;\n\n        const start_time = control.millis();\n        let sample_time = input.runningTimeMicros();\n\n        // Keep calculating until \n        // 1). time runs out\n        // 2). user blinked\n        while (control.millis() - start_time < ms && !exit) {\n            let signal = eog();\n\n            // If the buffer is not full yet, keep adding\n            if (buffer.length < buffer_size) {\n                buffer.push(signal);\n            }\n\n            // If the buffer is full, begin main process\n            if (buffer.length == buffer_size) {\n                buffer.shift();\n                buffer.push(signal);\n\n                // Do the following only when first point and second point \n                // differs by more than threshold\n                if (Math.abs(buffer[0] - buffer[1]) > threshold) {\n                    if (!currently_checking && buffer[1] > buffer[0]) {\n                        blink_check_timer = control.millis();\n                        start_val = buffer[0];\n                        currently_checking = true;\n                    }\n\n                    if (control.millis() - blink_check_timer < blink_time) {\n                        if (buffer[0] < start_val) {\n                            currently_checking = false;\n                            exit = true;\n                        }\n                    }\n                    else {\n                        currently_checking = false;\n                    }\n                }\n            }\n\n            // Sampling Rate caluculation\n            elapsed_time = input.runningTimeMicros() - sample_time;\n\n            if (elapsed_time < period) {\n                control.waitMicros(period - elapsed_time);\n            }\n\n            sample_time = input.runningTimeMicros();\n        }\n\n        return exit;\n\n    }\n\n\n    /**\n     * Looking Up (use with VEOG direction)\n     */\n\n    //% group=\"EOG\"\n    //% weight=39\n    //% block=\"up\"\n    export function up(): number {\n        return LookingAt.up;\n    }\n\n\n    /**\n     * Looking Down (use with VEOG direction)\n     */\n\n    //% group=\"EOG\"\n    //% weight=38\n    //% block=\"down\"\n    export function down(): number {\n        return LookingAt.down;\n    }\n\n\n    /**\n     * Looking Left (use with HEOG direction)\n     */\n\n    //% group=\"EOG\"\n    //% weight=37\n    //% block=\"left\"\n    export function left(): number {\n        return LookingAt.left;\n    }\n\n\n    /**\n     * Looking Right (use with HEOG direction)\n     */\n\n    //% group=\"EOG\"\n    //% weight=36\n    //% block=\"right\"\n    export function right(): number {\n        return LookingAt.right;\n    }\n\n\n    /**\n     * Blink (use with VEOG direction)\n    */\n\n    //% group=\"EOG\"\n    //% weight=35\n    //% block=\"blink\"\n    export function blink(): number {\n        return LookingAt.blink;\n    }\n\n\n    /**\n     * Choose the signal to print in Serial. \n     * You can also specify the specific time to run the printing. \n     * The default loops.\n     * @param signal = choose electrophysiology\n     * @param duration (optional) = duration(ms) to output the signal. If user does not provide one, then loops\n     */\n\n    //% group=\"Other\"\n    //% weight=30\n    //% block=\"print $signal || for $duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(signal: Signal, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                switch (signal) {\n                    case Signal.EEG: {\n                        serial.writeValue(\"EEG\", eeg());\n                        break;\n                    }\n                    case Signal.EMG: {\n                        serial.writeValue(\"EMG\", emg());\n                        break;\n                    }\n                    case Signal.ECG: {\n                        serial.writeValue(\"ECG\", ecg());\n                        break;\n                    }\n                    case Signal.EOG: {\n                        serial.writeValue(\"EOG\", eog());\n                        break;\n                    }\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                switch (signal) {\n                    case Signal.EEG: {\n                        serial.writeValue(\"EEG\", eeg());\n                        break;\n                    }\n                    case Signal.EMG: {\n                        serial.writeValue(\"EMG\", emg());\n                        break;\n                    }\n                    case Signal.ECG: {\n                        serial.writeValue(\"ECG\", ecg());\n                        break;\n                    }\n                    case Signal.EOG: {\n                        serial.writeValue(\"EOG\", eog());\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Apply envelope to signal by initializing this block at the top of the code,\n     */\n\n    //% group=\"Other\"\n    //% weight=29\n    //% block=\"Apply envelope to signal\"\n    export function envelope() {\n        apply_envelope = true;\n    }\n\n\n    /**\n     * Set the angle for servo.\n     * @param angle = the angle for servo (in degree)\n     */\n\n    //% group=\"Other\"\n    //% weight=28\n    //% block=\"set servo to $angle degrees\"\n    export function servo_control(angle: number) {\n        pins.servoWritePin(AnalogPin.P8, angle);\n    }\n\n\n    // /**\n    //  * Pause the program from running until user defined time(ms) pass.\n    //  * If the user provided second argument, pause the program for\n    //  * randomized time between the first input to second input \n    //  *(both inclusinve).\n    //  * @param start = time to pause program. \n    //  * @param end (optional) = use start and end to as range to pick the random time. The default is 0.\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=27\n    // //% block=\"Wait for $start (ms) || $end (ms)\"\n    // //% start.shadow=timePicker\n    // //% end.shadow=timePicker\n    // //% wait.defl=0;\n    // export function wait(start: number, end?: number) {\n    //     let waiting_time = 0;\n\n    //     // If user provides the second argument, choose random time,\n    //     // to wait, else set the the first argument.\n    //     if (end > 0 && end > start) {\n    //         waiting_time = randint(start, end);\n    //     }\n    //     else {\n    //         waiting_time = start;\n    //     }\n\n    //     // Run while loop for some duration\n    //     const start_time = control.millis();\n    //     while (control.millis() - start_time < waiting_time) {\n    //         continue;\n    //     }\n    // }\n\n}\n","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1726697764793,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"neurobit_set_emg\"><next><block type=\"device_while\"><value name=\"COND\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow></value><statement name=\"DO\"><block type=\"serial_writevalue\"><value name=\"name\"><shadow type=\"text\"><field name=\"TEXT\">signal</field></shadow></value><value name=\"value\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_last_measurement\"></block></value></block></statement></block></next></block></statement></block></xml>","main.ts":"neurobit.set_emg()\nwhile (true) {\n    serial.writeValue(\"signal\", neurobit.last_measurement())\n}\n","README.md":"","custom.ts":"// Enums to be used in extension\n// enum Signal {\n//     EEG,\n//     EMG,\n//     ECG,\n//     EOG\n// }\n\n// enum Cue {\n//     none,\n//     visual,\n//     audio\n// }\n\n// enum LookingAt {\n//     none,\n//     up,\n//     left,\n//     right,\n//     down,\n//     blink\n// }\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    /**\n     * Global initialization\n     */\n    let neurobit_buffer: number[] = [];\n    let neurobit_buffer_index = 0;\n    let neurobit_read_index = 0;\n\n    const PIN = AnalogPin.P1;\n\n    let signal_label = \"EEG\"; //Default EEG \n\n    let apply_envelope = false;\n    let envelope_buffer: number[] = [];\n    let envelope_sum = 0;\n    \n    // function convolution(new_signal: number) {\n    //     //Initialization\n    //     const window_size = 50; // Arbitray: decided based on smoothness of signal\n    //     const kernel = 1 / window_size; // Have \"better\" kernel?\n\n    //     if (envelope_buffer.length < window_size) {\n    //         // Only push the buffer\n    //         envelope_buffer.push(new_signal);\n    //         envelope_sum += new_signal;\n\n    //         return 0;\n    //     }\n    //     else {\n    //         // Update the buffer\n    //         let old_signal = envelope_buffer.shift();\n    //         envelope_buffer.push(new_signal);\n\n    //         // Perform the convolution(dot product of buffer and \"kernel\")\n    //         envelope_sum = envelope_sum - old_signal + new_signal;\n\n    //         return envelope_sum * kernel;\n    //     }\n    // }\n\n    /**\n     * Background Process\n     */\n    control.inBackground(function () {\n        const fs = 250; //[Hz]\n        const time_range = 5; //[s]\n        const neurobit_buffer_size = (fs * time_range) - 1;\n        const time_delay = 20; //[ms] \n        const index_gap = Math.ceil(fs / (1000 / time_delay));\n        while (true) {\n            neurobit_buffer[neurobit_buffer_index] = pins.analogReadPin(PIN);\n            neurobit_buffer_index++;\n            if (neurobit_buffer_index > neurobit_buffer_size) {\n                neurobit_buffer_index = 0;\n            }\n            if (neurobit_buffer_index < index_gap) {\n                neurobit_read_index = neurobit_buffer_size\n            }\n            basic.pause(0);\n        }\n    })\n\n    /**\n     * Record EMG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=105\n    //% block=\"record EMG in background\"\n    export function set_emg() {\n        pins.digitalWritePin(DigitalPin.P8, 1);\n        pins.digitalWritePin(DigitalPin.P9, 1);\n        signal_label = \"EMG\";\n    }\n\n    /**\n     * Record EKG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=104\n    //% block=\"record EKG in background\"\n    export function set_ekg() {\n        pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 1);\n        signal_label = \"EKG\";\n    }\n\n    /**\n     * Record EEG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=103\n    //% block=\"record ECG in background\"\n    export function set_eeg() {\n        pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 0);\n        signal_label = \"EEG\";\n    }\n\n\n    /**\n     * Return last measurement\n     */\n\n    //% group=\"Signal\"\n    //% weight=102\n    //% block=\"return last measurement\"\n    export function last_measurement(): number {\n        return neurobit_buffer[neurobit_buffer_index];\n        // return neurobit_buffer_index;\n    }\n\n\n    /**\n     * Apply envelope to signal by initializing this block at the top of the code,\n     */\n\n    //% group=\"Signal\"\n    //% weight=101\n    //% block=\"apply envelope to signal\"\n    export function envelope() {\n        apply_envelope = true;\n    }\n\n\n    /**\n     * Choose the signal to print in Serial. \n     * You can also specify the specific time to run the printing. \n     * The default loops.\n     * @param signal = choose electrophysiology\n     * @param duration (optional) = duration(ms) to output the signal. If user does not provide one, then loops\n     */\n\n    //% group=\"Other\"\n    //% weight=30\n    //% block=\"print signal || for $duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                serial.writeValue(signal_label, last_measurement());\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                serial.writeValue(signal_label, last_measurement());\n            }\n        }\n    }\n\n\n\n\n    // export function eeg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function emg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function ecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P1);\n    // }\n\n    // export function eog(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // /**\n    //  * Return the maximum threshold from some time intervals(ms).\n    //  * As an optional argument, you can change the percentage of threshold\n    //  * to be returned. The defaulut is 100(%).\n    //  * @param ms = duration(ms) to run the get and caluculate max theshold.\n    //  * @param percent (optional) = number as percentage of threshold to be returned. The default is 100%.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=46\n    // //% block=\"get threshold from $ms ms || and return with $percent percent\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.shadow=timePicker\n    // //% percent.defl=100\n    // export function getThreshold(ms: number, percent?: number) {\n    //     const startTimer = control.millis();\n    //     let val = 0;\n    //     let max_val = 0;\n\n    //     while (control.millis() - startTimer < ms) {\n    //         val = emg();\n\n    //         if (max_val < val) {\n    //             max_val = val;\n    //         }\n    //     }\n\n    //     return max_val * (percent / 100);\n    // }\n\n\n    // /**\n    //  * Return the number of spikes that happened during some duration(ms).\n    //  * You can also change the duration but the default is 3000 (i.e. 3 seconds).\n    //  * If you grip tight for minimum 500ms (then release), \n    //  * it will return as -1. \n    //  * @param ms = duration(ms) to run the spike recording.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=45\n    // //% block=\"count spikes for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% ms.defl=3000\n    // export function countSpikes(ms: number) {\n    //     const down_sample_fs = 200;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0;\n    //     let elapsed_time2 = 0;\n\n    //     const buffer_size = 20;\n    //     let buffer: number[] = [];\n\n    //     // Smoothing function for signal\n    //     function movingAverage(data: number[], windowSize: number): number {\n    //         let sum = 0.0;\n    //         let smoothedData = 0;\n    //         //overflow -> floating point\n    //         for (let j = 0; j < windowSize; j++) {\n    //             sum += data[j];\n    //         }\n    //         smoothedData = sum / windowSize;\n    //         return smoothedData;\n    //     }\n\n    //     const threshold = 150;\n    //     const interval = 500;\n    //     let signal = 0;\n    //     let smooth_signal = 0;\n    //     let counter = 0;\n    //     let checking = false;\n    //     let check_time = -interval;\n    //     let check_grip = false;\n\n    //     const startTimer = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Begin Timer\n    //     while (control.millis() - startTimer < ms) {\n    //         signal = emg();\n\n    //         // Fill the buffer before the main process\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // Once the buffer fills up, shift\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Smooth out the signal\n    //             smooth_signal = movingAverage(buffer, buffer.length);\n\n    //             // Check the signal above threshold\n    //             let sample_time2 = input.runningTimeMicros();\n    //             while (smooth_signal > threshold) {\n    //                 signal = emg();\n\n    //                 buffer.shift();\n    //                 buffer.push(signal);\n\n    //                 smooth_signal = movingAverage(buffer, buffer.length);\n\n    //                 if (!checking) {\n    //                     // Record the time when the spike is detected\n    //                     // for only once at the beggining during the rising\n    //                     check_time = control.millis();\n    //                     checking = true;\n    //                 }\n\n    //                 // Checking for grip\n    //                 check_grip = true;\n\n    //                 elapsed_time2 = input.runningTimeMicros() - sample_time2;\n\n    //                 if (elapsed_time2 < period) {\n    //                     control.waitMicros(period - elapsed_time2);\n    //                 }\n\n    //                 sample_time2 = input.runningTimeMicros();\n    //             }\n\n    //             // Once signl drops down below the threshold, allow \n    //             // check (for spike) to happen\n    //             checking = false;\n\n    //             // Check if the spike is within the interval window\n    //             // to reduce false positives\n    //             if (control.millis() - check_time < interval) {\n    //                 check_grip = false;\n    //                 counter++; // Increment counter for detected spikes\n    //                 check_time = -interval; // Reset check time\n    //             }\n\n    //             // If the signal goes over one second, assume due to\n    //             // the grip\n    //             if (check_grip) {\n    //                 counter = -1;\n    //             }\n\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return counter; // Return the spike count\n    // }\n\n\n    // /**\n    //  * Give the reaction time from certain cue. User have options to\n    //  * choose either from visual (Heart Icon) or audio (1/2 beat) cue\n    //  * with given threshold. \n    //  * @param cue (optional) = options for user to choose type of cue (visually or auditory). The default is none.\n    //  * @param threshold (optional) = user have option to select their desired threshold. The default is 200.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=44\n    // //% block=\"measure reaction time ||add cue $cue add threshold $threshold\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% threshold.defl=200\n    // //% inlineInputMode=inline\n    // export function reactionTime(cue?: Cue, threshold?: number) {\n    //     const cue_time = 100; // [ms]\n    //     const ms = 1500; // Give user 1.5 seconds to make reaction\n    //     let signal = 0;\n    //     let result = ms;\n    //     let once = true;\n\n    //     //At beggining, give user a cue if needed\n    //     switch (cue) {\n    //         case Cue.none: {\n    //             break;\n    //         }\n    //         case Cue.visual: {\n    //             basic.showIcon(IconNames.Heart, cue_time);\n    //             basic.clearScreen();\n    //             break;\n    //         }\n    //         case Cue.audio: {\n    //             pins.setAudioPin(AnalogPin.P16);\n    //             music.play(music.tonePlayable(262, cue_time),\n    //                 music.PlaybackMode.InBackground);\n    //             break;\n    //         }\n    //     }\n\n    //     const startTime = control.millis();\n\n    //     // Begin measuring the reaction time\n    //     while (control.millis() - startTime < ms) {\n    //         signal = emg();\n    //         // (only once) if the signal go above the threshold,\n    //         // save the reaction time. \n    //         if (signal > threshold && once) {\n    //             result = control.millis() - startTime;\n    //             once = false;\n    //         }\n    //     }\n\n    //     // If user fails to react, return as undefined (question mark)\n    //     if (result == ms) {\n    //         return undefined;\n    //     }\n    //     else {\n    //         return result;\n    //     }\n    // }\n\n\n    // /**\n    //  * Return the average heart beat (bpm) in 5 seconds(default).\n    //  * You can also change the time for recording from \n    //  * optional argument.\n    //  * @param ms (optional) = duration(ms) to run the hearbeat recording. The default is 5000 (i.e. 5 seconds).\n    //  */\n\n    // //% group=\"ECG\"\n    // //% weight=43\n    // //% block=\"measure heartbeat (bpm) || for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=5000\n    // export function heartBeat(ms: number) {\n    //     const down_sample_fs = 150 //Hz;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0\n\n    //     const range = 300;\n    //     const buffer_size = 6;\n    //     let buffer: number[] = [];\n    //     // let buffer_index = 0;\n    //     let beat_num = 0;\n    //     let unit = 0;\n    //     let sum_unit = 0;\n    //     let wait = 0;\n    //     let last_beat = 0;\n\n\n    //     // Fill the buffer first\n    //     for (let i = 0; i < buffer_size; i++) {\n    //         buffer.push(ecg());\n    //     }\n\n    //     const startTime = control.millis();\n    //     let prev_beat = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - startTime < ms) {\n    //         if (wait <= 0) {\n\n    //             // Buffer minimum, maximum calculation\n    //             let buffer_min = buffer[0];\n    //             let buffer_max = buffer[0];\n\n    //             for (let i = 1; i < buffer_size; i++) {\n    //                 if (buffer_min > buffer[i]) {\n    //                     buffer_min = buffer[i];\n    //                 }\n\n    //                 if (buffer_max < buffer[i]) {\n    //                     buffer_max = buffer[i];\n    //                 }\n    //             }\n\n    //             // If the range of buffer is greator than certain range,\n    //             // do heartbeat caluculation\n    //             if (buffer_max - buffer_min > range) {\n    //                 basic.showIcon(IconNames.Heart, 150);\n    //                 basic.clearScreen();\n    //                 last_beat = control.millis() - prev_beat;\n    //                 prev_beat = control.millis();\n    //                 let largeBox = Math.floor(last_beat / 200);\n    //                 let smallBox = Math.floor((last_beat - largeBox * 200) / 40);\n    //                 unit = 1 * largeBox + 0.2 * smallBox;\n    //                 sum_unit += unit;\n    //                 beat_num++;\n    //                 // Wait for buffer_size * 3. \n    //                 // This is possible because distance between\n    //                 // human heart beat is no smaller than time for\n    //                 // buffer_size * 3 samples\n    //                 wait = buffer_size * 3;\n    //             }\n    //         }\n\n\n    //         // May need to use shift\n    //         buffer.shift();\n    //         buffer.push(ecg());\n    //         // buffer[buffer_index] = val;\n    //         // buffer_index = (buffer_index + 1) % buffer_size;\n    //         wait--;\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time)\n    //         }\n\n    //         sample_time = input.runningTimeMicros()\n    //     }\n\n    //     // Check to avoid division by zero\n    //     return beat_num > 0 ? 300 / (sum_unit / beat_num) : undefined;\n    // }\n\n\n    // let currently_up = false;\n    // let currently_down = false;\n    // let center_UD = false;\n    // let cooldown_counter = 0;\n    // let blink_buffer: number[] = [];\n    // let updown_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (up/down/blink) if user move their eyes in\n    //  * vertical direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=42\n    // //% block=\"direction (VEOG)\"\n    // export function gazeV(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50; // [Hz]\n    //     const period = 1000000 / down_sample_fs; // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     const wait_size = Math.floor(down_sample_fs / 3); // 1/3 of second\n    //     let avgBuffer = 0;\n\n    //     let slope = 0;\n    //     const cooldown_period = wait_size + buffer_size;\n\n    //     // Function to return the averge slope of buffer\n    //     function calculateSlope(data: number[]): number {\n    //         const n = data.length;\n    //         let xSum = 0;\n    //         let ySum = 0;\n    //         let xySum = 0;\n    //         let xSquaredSum = 0;\n\n    //         for (let x = 0; x < n; x++) {\n    //             xSum += x;\n    //             ySum += data[x];\n    //             xySum += x * data[x];\n    //             xSquaredSum += x * x;\n    //         }\n\n    //         return (n * xySum - xSum * ySum) / (n * xSquaredSum - xSum * xSum);\n    //     }\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // Shift the buffer so blink analysis happens eariler than\n    //         // up or down analysis\n    //         if (blink_buffer.length < wait_size) {\n    //             blink_buffer.push(signal);\n    //         } else {\n    //             if (updown_buffer.length < buffer_size) {\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             } else {\n    //                 updown_buffer.shift();\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             }\n\n    //             blink_buffer.push(signal);\n    //         }\n\n    //         if (updown_buffer.length == buffer_size) {\n    //             slope = calculateSlope(blink_buffer.slice(0, buffer_size));\n    //             avgBuffer = updown_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Blinking\n    //             if (slope < -75) {\n    //                 // Begin cool down\n    //                 cooldown_counter = 0;\n    //                 result = LookingAt.blink;\n    //             }\n\n    //             // If cooldown is happening\n    //             if (cooldown_counter >= cooldown_period) {\n    //                 // Looking Up\n    //                 if (avgBuffer > baseline * 1.40) {\n    //                     if (currently_down) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.up;\n    //                         center_UD = false;\n    //                         currently_up = true;\n    //                     }\n    //                     // Looking Down \n    //                 } else if (avgBuffer < baseline * 0.60) {\n    //                     if (currently_up) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.down;\n    //                         center_UD = false;\n    //                         currently_down = true;\n    //                     }\n    //                 } else {\n    //                     if (center_UD) {\n    //                         currently_up = false;\n    //                         currently_down = false;\n    //                     }\n    //                 }\n    //             } else {\n    //                 cooldown_counter++;\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return result;\n\n    // }\n\n\n    // let currently_left = false;\n    // let currently_right = false;\n    // let center_LR = false;\n    // let leftright_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (left/right) if user move their eyes in\n    //  * horizontal direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=41\n    // //% block=\"direction (HEOG)\"\n    // export function gazeH(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50 // [Hz]\n    //     const period = 1000000 / down_sample_fs // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     let avgBuffer = 0;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (leftright_buffer.length < buffer_size) {\n    //             leftright_buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (leftright_buffer.length == buffer_size) {\n    //             leftright_buffer.shift();\n    //             leftright_buffer.push(signal);\n\n    //             // Calculate average of buffer\n    //             avgBuffer = leftright_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Looking Left\n    //             if (avgBuffer > baseline * 1.25) {\n    //                 if (currently_right) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_left = true;\n    //                     result = LookingAt.left;\n    //                 }\n    //             }\n    //             // Looking Right\n    //             else if (avgBuffer < baseline * 0.75) {\n    //                 if (currently_left) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_right = true;\n    //                     result = LookingAt.right;\n    //                 }\n    //             }\n    //             else {\n    //                 if (center_LR) {\n    //                     currently_left = false;\n    //                     currently_right = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return result;\n\n    // }\n\n\n    // /**\n    //  * Return true if user blinks within some time, false otherwise.\n    //  * Defining time is optional argument (the default is one second). \n    //  * @param ms (optional) = duration(ms) to check blink. The default is 1000 (i.e 1 seconds).\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=40\n    // //% block=\"blinked|| within $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=1000\n    // export function blinks(ms?: number): boolean {\n    //     const down_sample_fs = 50 //[Hz]\n    //     const period = 1000000 / down_sample_fs //[μs/hz]\n    //     let elapsed_time = 0;\n\n    //     const buffer_size = 2;\n    //     let buffer = [];\n\n    //     const threshold = 40;\n    //     const blink_time = 300; //[ms]\n\n    //     let blink_check_timer = 0;\n    //     let start_val = 0;\n    //     let currently_checking = false;\n\n    //     let exit = false;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep calculating until \n    //     // 1). time runs out\n    //     // 2). user blinked\n    //     while (control.millis() - start_time < ms && !exit) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Do the following only when first point and second point \n    //             // differs by more than threshold\n    //             if (Math.abs(buffer[0] - buffer[1]) > threshold) {\n    //                 if (!currently_checking && buffer[1] > buffer[0]) {\n    //                     blink_check_timer = control.millis();\n    //                     start_val = buffer[0];\n    //                     currently_checking = true;\n    //                 }\n\n    //                 if (control.millis() - blink_check_timer < blink_time) {\n    //                     if (buffer[0] < start_val) {\n    //                         currently_checking = false;\n    //                         exit = true;\n    //                     }\n    //                 }\n    //                 else {\n    //                     currently_checking = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return exit;\n\n    // }\n\n\n    // /**\n    //  * Looking Up (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=39\n    // //% block=\"up\"\n    // export function up(): number {\n    //     return LookingAt.up;\n    // }\n\n\n    // /**\n    //  * Looking Down (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=38\n    // //% block=\"down\"\n    // export function down(): number {\n    //     return LookingAt.down;\n    // }\n\n\n    // /**\n    //  * Looking Left (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=37\n    // //% block=\"left\"\n    // export function left(): number {\n    //     return LookingAt.left;\n    // }\n\n\n    // /**\n    //  * Looking Right (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=36\n    // //% block=\"right\"\n    // export function right(): number {\n    //     return LookingAt.right;\n    // }\n\n\n    // /**\n    //  * Blink (use with VEOG direction)\n    // */\n\n    // //% group=\"EOG\"\n    // //% weight=35\n    // //% block=\"blink\"\n    // export function blink(): number {\n    //     return LookingAt.blink;\n    // }\n\n\n    \n\n    // /**\n    //  * Set the angle for servo.\n    //  * @param angle = the angle for servo (in degree)\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=28\n    // //% block=\"set servo to $angle degrees\"\n    // export function servo_control(angle: number) {\n    //     pins.servoWritePin(AnalogPin.P0, angle);\n    // }\n\n\n    // /**\n    //  * Pause the program from running until user defined time(ms) pass.\n    //  * If the user provided second argument, pause the program for\n    //  * randomized time between the first input to second input \n    //  *(both inclusinve).\n    //  * @param start = time to pause program. \n    //  * @param end (optional) = use start and end to as range to pick the random time. The default is 0.\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=27\n    // //% block=\"Wait for $start (ms) || $end (ms)\"\n    // //% start.shadow=timePicker\n    // //% end.shadow=timePicker\n    // //% wait.defl=0;\n    // export function wait(start: number, end?: number) {\n    //     let waiting_time = 0;\n\n    //     // If user provides the second argument, choose random time,\n    //     // to wait, else set the the first argument.\n    //     if (end > 0 && end > start) {\n    //         waiting_time = randint(start, end);\n    //     }\n    //     else {\n    //         waiting_time = start;\n    //     }\n\n    //     // Run while loop for some duration\n    //     const start_time = control.millis();\n    //     while (control.millis() - start_time < waiting_time) {\n    //         continue;\n    //     }\n    // }\n\n}\n","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1726773314528,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"neurobit_envelope\"><next><block type=\"neurobit_set_emg\"><next><block type=\"neurobit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation></block></next></block></next></block></statement></block></xml>","main.ts":"neurobit.envelope()\nneurobit.set_emg()\nneurobit.print()\n","README.md":"","custom.ts":"// Enums to be used in extension\n// enum Signal {\n//     EEG,\n//     EMG,\n//     ECG,\n//     EOG\n// }\n\n// enum Cue {\n//     none,\n//     visual,\n//     audio\n// }\n\n// enum LookingAt {\n//     none,\n//     up,\n//     left,\n//     right,\n//     down,\n//     blink\n// }\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    /**\n     * Global initialization\n     */\n    let neurobit_buffer: number[] = [];\n    let neurobit_write_index = 0;\n    let neurobit_read_index = 0;\n\n    const PIN = AnalogPin.P1;\n\n    let signal_label = \"EEG\"; //Default EEG \n\n    let apply_envelope = false;\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n    \n    export function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        //Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n        \n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return new_signal;\n        }\n        return 0;\n        // else {\n        //     // Update the buffer\n        //     let old_signal = envelope_buffer.shift() as number;\n        //     envelope_buffer.push(new_signal);\n\n        //     // Perform the convolution(dot product of buffer and \"kernel\")\n        //     envelope_sum = envelope_sum - old_signal + new_signal;\n\n        //     return envelope_sum * kernel;\n        //     // return envelope_sum;\n        // }\n    }\n\n    /**\n     * Background Process\n     */\n    control.inBackground(function () {\n        const fs = 250; //[Hz]\n        const time_range = 5; //[s]\n        const neurobit_buffer_size = (fs * time_range);\n        const time_delay = 20; //[ms] \n        const index_gap = Math.ceil(fs / (1000 / time_delay));\n        while (true) {\n            neurobit_buffer[neurobit_write_index] = pins.analogReadPin(PIN);\n            neurobit_write_index++;\n            if (neurobit_write_index >= neurobit_buffer_size) {\n                neurobit_write_index = 0;\n            }\n            \n            if (neurobit_write_index < index_gap) {\n                neurobit_read_index = neurobit_buffer_size - (index_gap - neurobit_write_index);\n            }\n            else {\n                neurobit_read_index = neurobit_write_index - index_gap;\n            }\n            basic.pause(0);\n        }\n    })\n\n    /**\n     * Record EMG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=105\n    //% block=\"record EMG in background\"\n    export function set_emg() {\n        pins.digitalWritePin(DigitalPin.P8, 1);\n        pins.digitalWritePin(DigitalPin.P9, 1);\n        signal_label = \"EMG\";\n    }\n\n    /**\n     * Record EKG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=104\n    //% block=\"record EKG in background\"\n    export function set_ekg() {\n        pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 1);\n        signal_label = \"EKG\";\n    }\n\n    /**\n     * Record EEG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=103\n    //% block=\"record ECG in background\"\n    export function set_eeg() {\n        pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 0);\n        signal_label = \"EEG\";\n    }\n\n\n    /**\n     * Return last measurement\n     */\n\n    //% group=\"Signal\"\n    //% weight=102\n    //% block=\"return last measurement\"\n    export function last_measurement(): number {\n        return neurobit_buffer[neurobit_read_index];\n        // return neurobit_read_index;\n    }\n\n\n    /**\n     * Apply envelope to signal by initializing this block at the top of the code,\n     */\n\n    //% group=\"Signal\"\n    //% weight=101\n    //% block=\"apply envelope to signal\"\n    export function envelope() {\n        apply_envelope = true;\n    }\n\n\n    /**\n     * Choose the signal to print in Serial. \n     * You can also specify the specific time to run the printing. \n     * The default loops.\n     * @param signal = choose electrophysiology\n     * @param duration (optional) = duration(ms) to output the signal. If user does not provide one, then loops\n     */\n\n    //% group=\"Other\"\n    //% weight=30\n    //% block=\"print signal || for $duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (apply_envelope) {\n                    // Obtain the signal + make baseline to be 0\n                    let signal = last_measurement() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    serial.writeValue(signal_label, last_measurement());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (apply_envelope) {\n                    serial.writeValue(signal_label, convolution(last_measurement()));\n                }\n                else {\n                    serial.writeValue(signal_label, last_measurement());\n                }\n            }\n        }\n    }\n\n\n\n\n    // export function eeg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function emg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function ecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P1);\n    // }\n\n    // export function eog(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // /**\n    //  * Return the maximum threshold from some time intervals(ms).\n    //  * As an optional argument, you can change the percentage of threshold\n    //  * to be returned. The defaulut is 100(%).\n    //  * @param ms = duration(ms) to run the get and caluculate max theshold.\n    //  * @param percent (optional) = number as percentage of threshold to be returned. The default is 100%.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=46\n    // //% block=\"get threshold from $ms ms || and return with $percent percent\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.shadow=timePicker\n    // //% percent.defl=100\n    // export function getThreshold(ms: number, percent?: number) {\n    //     const startTimer = control.millis();\n    //     let val = 0;\n    //     let max_val = 0;\n\n    //     while (control.millis() - startTimer < ms) {\n    //         val = emg();\n\n    //         if (max_val < val) {\n    //             max_val = val;\n    //         }\n    //     }\n\n    //     return max_val * (percent / 100);\n    // }\n\n\n    // /**\n    //  * Return the number of spikes that happened during some duration(ms).\n    //  * You can also change the duration but the default is 3000 (i.e. 3 seconds).\n    //  * If you grip tight for minimum 500ms (then release), \n    //  * it will return as -1. \n    //  * @param ms = duration(ms) to run the spike recording.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=45\n    // //% block=\"count spikes for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% ms.defl=3000\n    // export function countSpikes(ms: number) {\n    //     const down_sample_fs = 200;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0;\n    //     let elapsed_time2 = 0;\n\n    //     const buffer_size = 20;\n    //     let buffer: number[] = [];\n\n    //     // Smoothing function for signal\n    //     function movingAverage(data: number[], windowSize: number): number {\n    //         let sum = 0.0;\n    //         let smoothedData = 0;\n    //         //overflow -> floating point\n    //         for (let j = 0; j < windowSize; j++) {\n    //             sum += data[j];\n    //         }\n    //         smoothedData = sum / windowSize;\n    //         return smoothedData;\n    //     }\n\n    //     const threshold = 150;\n    //     const interval = 500;\n    //     let signal = 0;\n    //     let smooth_signal = 0;\n    //     let counter = 0;\n    //     let checking = false;\n    //     let check_time = -interval;\n    //     let check_grip = false;\n\n    //     const startTimer = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Begin Timer\n    //     while (control.millis() - startTimer < ms) {\n    //         signal = emg();\n\n    //         // Fill the buffer before the main process\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // Once the buffer fills up, shift\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Smooth out the signal\n    //             smooth_signal = movingAverage(buffer, buffer.length);\n\n    //             // Check the signal above threshold\n    //             let sample_time2 = input.runningTimeMicros();\n    //             while (smooth_signal > threshold) {\n    //                 signal = emg();\n\n    //                 buffer.shift();\n    //                 buffer.push(signal);\n\n    //                 smooth_signal = movingAverage(buffer, buffer.length);\n\n    //                 if (!checking) {\n    //                     // Record the time when the spike is detected\n    //                     // for only once at the beggining during the rising\n    //                     check_time = control.millis();\n    //                     checking = true;\n    //                 }\n\n    //                 // Checking for grip\n    //                 check_grip = true;\n\n    //                 elapsed_time2 = input.runningTimeMicros() - sample_time2;\n\n    //                 if (elapsed_time2 < period) {\n    //                     control.waitMicros(period - elapsed_time2);\n    //                 }\n\n    //                 sample_time2 = input.runningTimeMicros();\n    //             }\n\n    //             // Once signl drops down below the threshold, allow \n    //             // check (for spike) to happen\n    //             checking = false;\n\n    //             // Check if the spike is within the interval window\n    //             // to reduce false positives\n    //             if (control.millis() - check_time < interval) {\n    //                 check_grip = false;\n    //                 counter++; // Increment counter for detected spikes\n    //                 check_time = -interval; // Reset check time\n    //             }\n\n    //             // If the signal goes over one second, assume due to\n    //             // the grip\n    //             if (check_grip) {\n    //                 counter = -1;\n    //             }\n\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return counter; // Return the spike count\n    // }\n\n\n    // /**\n    //  * Give the reaction time from certain cue. User have options to\n    //  * choose either from visual (Heart Icon) or audio (1/2 beat) cue\n    //  * with given threshold. \n    //  * @param cue (optional) = options for user to choose type of cue (visually or auditory). The default is none.\n    //  * @param threshold (optional) = user have option to select their desired threshold. The default is 200.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=44\n    // //% block=\"measure reaction time ||add cue $cue add threshold $threshold\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% threshold.defl=200\n    // //% inlineInputMode=inline\n    // export function reactionTime(cue?: Cue, threshold?: number) {\n    //     const cue_time = 100; // [ms]\n    //     const ms = 1500; // Give user 1.5 seconds to make reaction\n    //     let signal = 0;\n    //     let result = ms;\n    //     let once = true;\n\n    //     //At beggining, give user a cue if needed\n    //     switch (cue) {\n    //         case Cue.none: {\n    //             break;\n    //         }\n    //         case Cue.visual: {\n    //             basic.showIcon(IconNames.Heart, cue_time);\n    //             basic.clearScreen();\n    //             break;\n    //         }\n    //         case Cue.audio: {\n    //             pins.setAudioPin(AnalogPin.P16);\n    //             music.play(music.tonePlayable(262, cue_time),\n    //                 music.PlaybackMode.InBackground);\n    //             break;\n    //         }\n    //     }\n\n    //     const startTime = control.millis();\n\n    //     // Begin measuring the reaction time\n    //     while (control.millis() - startTime < ms) {\n    //         signal = emg();\n    //         // (only once) if the signal go above the threshold,\n    //         // save the reaction time. \n    //         if (signal > threshold && once) {\n    //             result = control.millis() - startTime;\n    //             once = false;\n    //         }\n    //     }\n\n    //     // If user fails to react, return as undefined (question mark)\n    //     if (result == ms) {\n    //         return undefined;\n    //     }\n    //     else {\n    //         return result;\n    //     }\n    // }\n\n\n    // /**\n    //  * Return the average heart beat (bpm) in 5 seconds(default).\n    //  * You can also change the time for recording from \n    //  * optional argument.\n    //  * @param ms (optional) = duration(ms) to run the hearbeat recording. The default is 5000 (i.e. 5 seconds).\n    //  */\n\n    // //% group=\"ECG\"\n    // //% weight=43\n    // //% block=\"measure heartbeat (bpm) || for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=5000\n    // export function heartBeat(ms: number) {\n    //     const down_sample_fs = 150 //Hz;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0\n\n    //     const range = 300;\n    //     const buffer_size = 6;\n    //     let buffer: number[] = [];\n    //     // let buffer_index = 0;\n    //     let beat_num = 0;\n    //     let unit = 0;\n    //     let sum_unit = 0;\n    //     let wait = 0;\n    //     let last_beat = 0;\n\n\n    //     // Fill the buffer first\n    //     for (let i = 0; i < buffer_size; i++) {\n    //         buffer.push(ecg());\n    //     }\n\n    //     const startTime = control.millis();\n    //     let prev_beat = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - startTime < ms) {\n    //         if (wait <= 0) {\n\n    //             // Buffer minimum, maximum calculation\n    //             let buffer_min = buffer[0];\n    //             let buffer_max = buffer[0];\n\n    //             for (let i = 1; i < buffer_size; i++) {\n    //                 if (buffer_min > buffer[i]) {\n    //                     buffer_min = buffer[i];\n    //                 }\n\n    //                 if (buffer_max < buffer[i]) {\n    //                     buffer_max = buffer[i];\n    //                 }\n    //             }\n\n    //             // If the range of buffer is greator than certain range,\n    //             // do heartbeat caluculation\n    //             if (buffer_max - buffer_min > range) {\n    //                 basic.showIcon(IconNames.Heart, 150);\n    //                 basic.clearScreen();\n    //                 last_beat = control.millis() - prev_beat;\n    //                 prev_beat = control.millis();\n    //                 let largeBox = Math.floor(last_beat / 200);\n    //                 let smallBox = Math.floor((last_beat - largeBox * 200) / 40);\n    //                 unit = 1 * largeBox + 0.2 * smallBox;\n    //                 sum_unit += unit;\n    //                 beat_num++;\n    //                 // Wait for buffer_size * 3. \n    //                 // This is possible because distance between\n    //                 // human heart beat is no smaller than time for\n    //                 // buffer_size * 3 samples\n    //                 wait = buffer_size * 3;\n    //             }\n    //         }\n\n\n    //         // May need to use shift\n    //         buffer.shift();\n    //         buffer.push(ecg());\n    //         // buffer[buffer_index] = val;\n    //         // buffer_index = (buffer_index + 1) % buffer_size;\n    //         wait--;\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time)\n    //         }\n\n    //         sample_time = input.runningTimeMicros()\n    //     }\n\n    //     // Check to avoid division by zero\n    //     return beat_num > 0 ? 300 / (sum_unit / beat_num) : undefined;\n    // }\n\n\n    // let currently_up = false;\n    // let currently_down = false;\n    // let center_UD = false;\n    // let cooldown_counter = 0;\n    // let blink_buffer: number[] = [];\n    // let updown_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (up/down/blink) if user move their eyes in\n    //  * vertical direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=42\n    // //% block=\"direction (VEOG)\"\n    // export function gazeV(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50; // [Hz]\n    //     const period = 1000000 / down_sample_fs; // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     const wait_size = Math.floor(down_sample_fs / 3); // 1/3 of second\n    //     let avgBuffer = 0;\n\n    //     let slope = 0;\n    //     const cooldown_period = wait_size + buffer_size;\n\n    //     // Function to return the averge slope of buffer\n    //     function calculateSlope(data: number[]): number {\n    //         const n = data.length;\n    //         let xSum = 0;\n    //         let ySum = 0;\n    //         let xySum = 0;\n    //         let xSquaredSum = 0;\n\n    //         for (let x = 0; x < n; x++) {\n    //             xSum += x;\n    //             ySum += data[x];\n    //             xySum += x * data[x];\n    //             xSquaredSum += x * x;\n    //         }\n\n    //         return (n * xySum - xSum * ySum) / (n * xSquaredSum - xSum * xSum);\n    //     }\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // Shift the buffer so blink analysis happens eariler than\n    //         // up or down analysis\n    //         if (blink_buffer.length < wait_size) {\n    //             blink_buffer.push(signal);\n    //         } else {\n    //             if (updown_buffer.length < buffer_size) {\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             } else {\n    //                 updown_buffer.shift();\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             }\n\n    //             blink_buffer.push(signal);\n    //         }\n\n    //         if (updown_buffer.length == buffer_size) {\n    //             slope = calculateSlope(blink_buffer.slice(0, buffer_size));\n    //             avgBuffer = updown_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Blinking\n    //             if (slope < -75) {\n    //                 // Begin cool down\n    //                 cooldown_counter = 0;\n    //                 result = LookingAt.blink;\n    //             }\n\n    //             // If cooldown is happening\n    //             if (cooldown_counter >= cooldown_period) {\n    //                 // Looking Up\n    //                 if (avgBuffer > baseline * 1.40) {\n    //                     if (currently_down) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.up;\n    //                         center_UD = false;\n    //                         currently_up = true;\n    //                     }\n    //                     // Looking Down \n    //                 } else if (avgBuffer < baseline * 0.60) {\n    //                     if (currently_up) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.down;\n    //                         center_UD = false;\n    //                         currently_down = true;\n    //                     }\n    //                 } else {\n    //                     if (center_UD) {\n    //                         currently_up = false;\n    //                         currently_down = false;\n    //                     }\n    //                 }\n    //             } else {\n    //                 cooldown_counter++;\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return result;\n\n    // }\n\n\n    // let currently_left = false;\n    // let currently_right = false;\n    // let center_LR = false;\n    // let leftright_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (left/right) if user move their eyes in\n    //  * horizontal direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=41\n    // //% block=\"direction (HEOG)\"\n    // export function gazeH(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50 // [Hz]\n    //     const period = 1000000 / down_sample_fs // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     let avgBuffer = 0;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (leftright_buffer.length < buffer_size) {\n    //             leftright_buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (leftright_buffer.length == buffer_size) {\n    //             leftright_buffer.shift();\n    //             leftright_buffer.push(signal);\n\n    //             // Calculate average of buffer\n    //             avgBuffer = leftright_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Looking Left\n    //             if (avgBuffer > baseline * 1.25) {\n    //                 if (currently_right) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_left = true;\n    //                     result = LookingAt.left;\n    //                 }\n    //             }\n    //             // Looking Right\n    //             else if (avgBuffer < baseline * 0.75) {\n    //                 if (currently_left) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_right = true;\n    //                     result = LookingAt.right;\n    //                 }\n    //             }\n    //             else {\n    //                 if (center_LR) {\n    //                     currently_left = false;\n    //                     currently_right = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return result;\n\n    // }\n\n\n    // /**\n    //  * Return true if user blinks within some time, false otherwise.\n    //  * Defining time is optional argument (the default is one second). \n    //  * @param ms (optional) = duration(ms) to check blink. The default is 1000 (i.e 1 seconds).\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=40\n    // //% block=\"blinked|| within $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=1000\n    // export function blinks(ms?: number): boolean {\n    //     const down_sample_fs = 50 //[Hz]\n    //     const period = 1000000 / down_sample_fs //[μs/hz]\n    //     let elapsed_time = 0;\n\n    //     const buffer_size = 2;\n    //     let buffer = [];\n\n    //     const threshold = 40;\n    //     const blink_time = 300; //[ms]\n\n    //     let blink_check_timer = 0;\n    //     let start_val = 0;\n    //     let currently_checking = false;\n\n    //     let exit = false;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep calculating until \n    //     // 1). time runs out\n    //     // 2). user blinked\n    //     while (control.millis() - start_time < ms && !exit) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Do the following only when first point and second point \n    //             // differs by more than threshold\n    //             if (Math.abs(buffer[0] - buffer[1]) > threshold) {\n    //                 if (!currently_checking && buffer[1] > buffer[0]) {\n    //                     blink_check_timer = control.millis();\n    //                     start_val = buffer[0];\n    //                     currently_checking = true;\n    //                 }\n\n    //                 if (control.millis() - blink_check_timer < blink_time) {\n    //                     if (buffer[0] < start_val) {\n    //                         currently_checking = false;\n    //                         exit = true;\n    //                     }\n    //                 }\n    //                 else {\n    //                     currently_checking = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return exit;\n\n    // }\n\n\n    // /**\n    //  * Looking Up (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=39\n    // //% block=\"up\"\n    // export function up(): number {\n    //     return LookingAt.up;\n    // }\n\n\n    // /**\n    //  * Looking Down (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=38\n    // //% block=\"down\"\n    // export function down(): number {\n    //     return LookingAt.down;\n    // }\n\n\n    // /**\n    //  * Looking Left (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=37\n    // //% block=\"left\"\n    // export function left(): number {\n    //     return LookingAt.left;\n    // }\n\n\n    // /**\n    //  * Looking Right (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=36\n    // //% block=\"right\"\n    // export function right(): number {\n    //     return LookingAt.right;\n    // }\n\n\n    // /**\n    //  * Blink (use with VEOG direction)\n    // */\n\n    // //% group=\"EOG\"\n    // //% weight=35\n    // //% block=\"blink\"\n    // export function blink(): number {\n    //     return LookingAt.blink;\n    // }\n\n\n    \n\n    // /**\n    //  * Set the angle for servo.\n    //  * @param angle = the angle for servo (in degree)\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=28\n    // //% block=\"set servo to $angle degrees\"\n    // export function servo_control(angle: number) {\n    //     pins.servoWritePin(AnalogPin.P0, angle);\n    // }\n\n\n    // /**\n    //  * Pause the program from running until user defined time(ms) pass.\n    //  * If the user provided second argument, pause the program for\n    //  * randomized time between the first input to second input \n    //  *(both inclusinve).\n    //  * @param start = time to pause program. \n    //  * @param end (optional) = use start and end to as range to pick the random time. The default is 0.\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=27\n    // //% block=\"Wait for $start (ms) || $end (ms)\"\n    // //% start.shadow=timePicker\n    // //% end.shadow=timePicker\n    // //% wait.defl=0;\n    // export function wait(start: number, end?: number) {\n    //     let waiting_time = 0;\n\n    //     // If user provides the second argument, choose random time,\n    //     // to wait, else set the the first argument.\n    //     if (end > 0 && end > start) {\n    //         waiting_time = randint(start, end);\n    //     }\n    //     else {\n    //         waiting_time = start;\n    //     }\n\n    //     // Run while loop for some duration\n    //     const start_time = control.millis();\n    //     while (control.millis() - start_time < waiting_time) {\n    //         continue;\n    //     }\n    // }\n\n}\n","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1726850596266,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"neurobit_envelope\"><next><block type=\"neurobit_set_emg\"><next><block type=\"neurobit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">5000</field></shadow></value></block></next></block></next></block></statement></block></xml>","main.ts":"neurobit.envelope()\nneurobit.set_emg()\nneurobit.print()\n","README.md":"","custom.ts":"// Enums to be used in extension\n// enum Signal {\n//     EEG,\n//     EMG,\n//     ECG,\n//     EOG\n// }\n\n// enum Cue {\n//     none,\n//     visual,\n//     audio\n// }\n\n// enum LookingAt {\n//     none,\n//     up,\n//     left,\n//     right,\n//     down,\n//     blink\n// }\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    /**\n     * Global initialization\n     */\n    const fs = 250; //[Hz]\n    const time_range = 5000; //[ms]\n    const neurobit_buffer_size = (fs * (time_range / 1000));\n    let neurobit_buffer: number[] = [];\n    let neurobit_write_index = 0;\n    let neurobit_read_index = 0;\n\n    const PIN = AnalogPin.P1;\n\n    let signal_label = \"EEG\"; //Default EEG \n\n    let apply_envelope = false;\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n    \n    export function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        //Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n        \n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Background Process\n     */\n    control.inBackground(function () {\n        const time_delay = 20; //[ms] \n        const index_gap = Math.ceil(fs / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < neurobit_buffer_size; i++) {\n            neurobit_buffer[i] = 0;\n        }\n\n        // \"Actual\" background processing\n        while (true) {\n            neurobit_buffer[neurobit_write_index] = pins.analogReadPin(PIN);\n            neurobit_write_index++;\n\n            // Loop back write_index after reach to end\n            if (neurobit_write_index >= neurobit_buffer_size) {\n                neurobit_write_index = 0;\n            }\n            \n            // Caluclation for correct read_index\n            if (neurobit_write_index < index_gap) {\n                neurobit_read_index = neurobit_buffer_size - (index_gap - neurobit_write_index);\n            }\n            else {\n                neurobit_read_index = neurobit_write_index - index_gap;\n            }\n\n            // Pause (tick = 4ms)\n            basic.pause(0);\n        }\n    })\n\n    /**\n     * Record EMG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=105\n    //% block=\"record EMG in background\"\n    export function set_emg() {\n        pins.digitalWritePin(DigitalPin.P8, 1);\n        pins.digitalWritePin(DigitalPin.P9, 1);\n        signal_label = \"EMG\";\n    }\n\n    /**\n     * Record EKG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=104\n    //% block=\"record EKG in background\"\n    export function set_ekg() {\n        pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 1);\n        signal_label = \"EKG\";\n    }\n\n    /**\n     * Record EEG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=103\n    //% block=\"record ECG in background\"\n    export function set_eeg() {\n        pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 0);\n        signal_label = \"EEG\";\n    }\n\n\n    /**\n     * Return last measurement\n     */\n\n    //% group=\"Signal\"\n    //% weight=102\n    //% block=\"return last measurement\"\n    export function last_measurement(): number {\n        return neurobit_buffer[neurobit_read_index];\n    }\n\n    //% group=\"Signal\"\n    //% weight=101\n    //% block=\"return buffer from last $duration ms\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    export function last_buffer(duration: number): number[] {\n        let copy_size = Math.floor(neurobit_buffer_size / (time_range / duration))\n        let copy = neurobit_buffer;\n        return copy;\n    }\n\n\n    /**\n     * Apply envelope to signal by initializing this block at the top of the code,\n     */\n\n    //% group=\"Signal\"\n    //% weight=100\n    //% block=\"apply envelope to signal\"\n    export function envelope() {\n        apply_envelope = true;\n    }\n\n\n    /**\n     * Choose the signal to print in Serial. \n     * You can also specify the specific time to run the printing. \n     * The default loops.\n     * @param signal = choose electrophysiology\n     * @param duration (optional) = duration(ms) to output the signal. If user does not provide one, then loops\n     */\n\n    //% group=\"Other\"\n    //% weight=30\n    //% block=\"print signal || for $duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (apply_envelope) {\n                    // Obtain the signal + make baseline to be 0\n                    let signal = last_measurement() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n                    \n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, last_measurement());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (apply_envelope) {\n                    // Obtain the signal + make baseline to be 0\n                    let signal = last_measurement() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, last_measurement());\n                }\n            }\n        }\n    }\n\n\n\n\n    // export function eeg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function emg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function ecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P1);\n    // }\n\n    // export function eog(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // /**\n    //  * Return the maximum threshold from some time intervals(ms).\n    //  * As an optional argument, you can change the percentage of threshold\n    //  * to be returned. The defaulut is 100(%).\n    //  * @param ms = duration(ms) to run the get and caluculate max theshold.\n    //  * @param percent (optional) = number as percentage of threshold to be returned. The default is 100%.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=46\n    // //% block=\"get threshold from $ms ms || and return with $percent percent\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.shadow=timePicker\n    // //% percent.defl=100\n    // export function getThreshold(ms: number, percent?: number) {\n    //     const startTimer = control.millis();\n    //     let val = 0;\n    //     let max_val = 0;\n\n    //     while (control.millis() - startTimer < ms) {\n    //         val = emg();\n\n    //         if (max_val < val) {\n    //             max_val = val;\n    //         }\n    //     }\n\n    //     return max_val * (percent / 100);\n    // }\n\n\n    // /**\n    //  * Return the number of spikes that happened during some duration(ms).\n    //  * You can also change the duration but the default is 3000 (i.e. 3 seconds).\n    //  * If you grip tight for minimum 500ms (then release), \n    //  * it will return as -1. \n    //  * @param ms = duration(ms) to run the spike recording.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=45\n    // //% block=\"count spikes for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% ms.defl=3000\n    // export function countSpikes(ms: number) {\n    //     const down_sample_fs = 200;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0;\n    //     let elapsed_time2 = 0;\n\n    //     const buffer_size = 20;\n    //     let buffer: number[] = [];\n\n    //     // Smoothing function for signal\n    //     function movingAverage(data: number[], windowSize: number): number {\n    //         let sum = 0.0;\n    //         let smoothedData = 0;\n    //         //overflow -> floating point\n    //         for (let j = 0; j < windowSize; j++) {\n    //             sum += data[j];\n    //         }\n    //         smoothedData = sum / windowSize;\n    //         return smoothedData;\n    //     }\n\n    //     const threshold = 150;\n    //     const interval = 500;\n    //     let signal = 0;\n    //     let smooth_signal = 0;\n    //     let counter = 0;\n    //     let checking = false;\n    //     let check_time = -interval;\n    //     let check_grip = false;\n\n    //     const startTimer = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Begin Timer\n    //     while (control.millis() - startTimer < ms) {\n    //         signal = emg();\n\n    //         // Fill the buffer before the main process\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // Once the buffer fills up, shift\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Smooth out the signal\n    //             smooth_signal = movingAverage(buffer, buffer.length);\n\n    //             // Check the signal above threshold\n    //             let sample_time2 = input.runningTimeMicros();\n    //             while (smooth_signal > threshold) {\n    //                 signal = emg();\n\n    //                 buffer.shift();\n    //                 buffer.push(signal);\n\n    //                 smooth_signal = movingAverage(buffer, buffer.length);\n\n    //                 if (!checking) {\n    //                     // Record the time when the spike is detected\n    //                     // for only once at the beggining during the rising\n    //                     check_time = control.millis();\n    //                     checking = true;\n    //                 }\n\n    //                 // Checking for grip\n    //                 check_grip = true;\n\n    //                 elapsed_time2 = input.runningTimeMicros() - sample_time2;\n\n    //                 if (elapsed_time2 < period) {\n    //                     control.waitMicros(period - elapsed_time2);\n    //                 }\n\n    //                 sample_time2 = input.runningTimeMicros();\n    //             }\n\n    //             // Once signl drops down below the threshold, allow \n    //             // check (for spike) to happen\n    //             checking = false;\n\n    //             // Check if the spike is within the interval window\n    //             // to reduce false positives\n    //             if (control.millis() - check_time < interval) {\n    //                 check_grip = false;\n    //                 counter++; // Increment counter for detected spikes\n    //                 check_time = -interval; // Reset check time\n    //             }\n\n    //             // If the signal goes over one second, assume due to\n    //             // the grip\n    //             if (check_grip) {\n    //                 counter = -1;\n    //             }\n\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return counter; // Return the spike count\n    // }\n\n\n    // /**\n    //  * Give the reaction time from certain cue. User have options to\n    //  * choose either from visual (Heart Icon) or audio (1/2 beat) cue\n    //  * with given threshold. \n    //  * @param cue (optional) = options for user to choose type of cue (visually or auditory). The default is none.\n    //  * @param threshold (optional) = user have option to select their desired threshold. The default is 200.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=44\n    // //% block=\"measure reaction time ||add cue $cue add threshold $threshold\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% threshold.defl=200\n    // //% inlineInputMode=inline\n    // export function reactionTime(cue?: Cue, threshold?: number) {\n    //     const cue_time = 100; // [ms]\n    //     const ms = 1500; // Give user 1.5 seconds to make reaction\n    //     let signal = 0;\n    //     let result = ms;\n    //     let once = true;\n\n    //     //At beggining, give user a cue if needed\n    //     switch (cue) {\n    //         case Cue.none: {\n    //             break;\n    //         }\n    //         case Cue.visual: {\n    //             basic.showIcon(IconNames.Heart, cue_time);\n    //             basic.clearScreen();\n    //             break;\n    //         }\n    //         case Cue.audio: {\n    //             pins.setAudioPin(AnalogPin.P16);\n    //             music.play(music.tonePlayable(262, cue_time),\n    //                 music.PlaybackMode.InBackground);\n    //             break;\n    //         }\n    //     }\n\n    //     const startTime = control.millis();\n\n    //     // Begin measuring the reaction time\n    //     while (control.millis() - startTime < ms) {\n    //         signal = emg();\n    //         // (only once) if the signal go above the threshold,\n    //         // save the reaction time. \n    //         if (signal > threshold && once) {\n    //             result = control.millis() - startTime;\n    //             once = false;\n    //         }\n    //     }\n\n    //     // If user fails to react, return as undefined (question mark)\n    //     if (result == ms) {\n    //         return undefined;\n    //     }\n    //     else {\n    //         return result;\n    //     }\n    // }\n\n\n    // /**\n    //  * Return the average heart beat (bpm) in 5 seconds(default).\n    //  * You can also change the time for recording from \n    //  * optional argument.\n    //  * @param ms (optional) = duration(ms) to run the hearbeat recording. The default is 5000 (i.e. 5 seconds).\n    //  */\n\n    // //% group=\"ECG\"\n    // //% weight=43\n    // //% block=\"measure heartbeat (bpm) || for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=5000\n    // export function heartBeat(ms: number) {\n    //     const down_sample_fs = 150 //Hz;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0\n\n    //     const range = 300;\n    //     const buffer_size = 6;\n    //     let buffer: number[] = [];\n    //     // let buffer_index = 0;\n    //     let beat_num = 0;\n    //     let unit = 0;\n    //     let sum_unit = 0;\n    //     let wait = 0;\n    //     let last_beat = 0;\n\n\n    //     // Fill the buffer first\n    //     for (let i = 0; i < buffer_size; i++) {\n    //         buffer.push(ecg());\n    //     }\n\n    //     const startTime = control.millis();\n    //     let prev_beat = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - startTime < ms) {\n    //         if (wait <= 0) {\n\n    //             // Buffer minimum, maximum calculation\n    //             let buffer_min = buffer[0];\n    //             let buffer_max = buffer[0];\n\n    //             for (let i = 1; i < buffer_size; i++) {\n    //                 if (buffer_min > buffer[i]) {\n    //                     buffer_min = buffer[i];\n    //                 }\n\n    //                 if (buffer_max < buffer[i]) {\n    //                     buffer_max = buffer[i];\n    //                 }\n    //             }\n\n    //             // If the range of buffer is greator than certain range,\n    //             // do heartbeat caluculation\n    //             if (buffer_max - buffer_min > range) {\n    //                 basic.showIcon(IconNames.Heart, 150);\n    //                 basic.clearScreen();\n    //                 last_beat = control.millis() - prev_beat;\n    //                 prev_beat = control.millis();\n    //                 let largeBox = Math.floor(last_beat / 200);\n    //                 let smallBox = Math.floor((last_beat - largeBox * 200) / 40);\n    //                 unit = 1 * largeBox + 0.2 * smallBox;\n    //                 sum_unit += unit;\n    //                 beat_num++;\n    //                 // Wait for buffer_size * 3. \n    //                 // This is possible because distance between\n    //                 // human heart beat is no smaller than time for\n    //                 // buffer_size * 3 samples\n    //                 wait = buffer_size * 3;\n    //             }\n    //         }\n\n\n    //         // May need to use shift\n    //         buffer.shift();\n    //         buffer.push(ecg());\n    //         // buffer[buffer_index] = val;\n    //         // buffer_index = (buffer_index + 1) % buffer_size;\n    //         wait--;\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time)\n    //         }\n\n    //         sample_time = input.runningTimeMicros()\n    //     }\n\n    //     // Check to avoid division by zero\n    //     return beat_num > 0 ? 300 / (sum_unit / beat_num) : undefined;\n    // }\n\n\n    // let currently_up = false;\n    // let currently_down = false;\n    // let center_UD = false;\n    // let cooldown_counter = 0;\n    // let blink_buffer: number[] = [];\n    // let updown_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (up/down/blink) if user move their eyes in\n    //  * vertical direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=42\n    // //% block=\"direction (VEOG)\"\n    // export function gazeV(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50; // [Hz]\n    //     const period = 1000000 / down_sample_fs; // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     const wait_size = Math.floor(down_sample_fs / 3); // 1/3 of second\n    //     let avgBuffer = 0;\n\n    //     let slope = 0;\n    //     const cooldown_period = wait_size + buffer_size;\n\n    //     // Function to return the averge slope of buffer\n    //     function calculateSlope(data: number[]): number {\n    //         const n = data.length;\n    //         let xSum = 0;\n    //         let ySum = 0;\n    //         let xySum = 0;\n    //         let xSquaredSum = 0;\n\n    //         for (let x = 0; x < n; x++) {\n    //             xSum += x;\n    //             ySum += data[x];\n    //             xySum += x * data[x];\n    //             xSquaredSum += x * x;\n    //         }\n\n    //         return (n * xySum - xSum * ySum) / (n * xSquaredSum - xSum * xSum);\n    //     }\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // Shift the buffer so blink analysis happens eariler than\n    //         // up or down analysis\n    //         if (blink_buffer.length < wait_size) {\n    //             blink_buffer.push(signal);\n    //         } else {\n    //             if (updown_buffer.length < buffer_size) {\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             } else {\n    //                 updown_buffer.shift();\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             }\n\n    //             blink_buffer.push(signal);\n    //         }\n\n    //         if (updown_buffer.length == buffer_size) {\n    //             slope = calculateSlope(blink_buffer.slice(0, buffer_size));\n    //             avgBuffer = updown_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Blinking\n    //             if (slope < -75) {\n    //                 // Begin cool down\n    //                 cooldown_counter = 0;\n    //                 result = LookingAt.blink;\n    //             }\n\n    //             // If cooldown is happening\n    //             if (cooldown_counter >= cooldown_period) {\n    //                 // Looking Up\n    //                 if (avgBuffer > baseline * 1.40) {\n    //                     if (currently_down) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.up;\n    //                         center_UD = false;\n    //                         currently_up = true;\n    //                     }\n    //                     // Looking Down \n    //                 } else if (avgBuffer < baseline * 0.60) {\n    //                     if (currently_up) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.down;\n    //                         center_UD = false;\n    //                         currently_down = true;\n    //                     }\n    //                 } else {\n    //                     if (center_UD) {\n    //                         currently_up = false;\n    //                         currently_down = false;\n    //                     }\n    //                 }\n    //             } else {\n    //                 cooldown_counter++;\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return result;\n\n    // }\n\n\n    // let currently_left = false;\n    // let currently_right = false;\n    // let center_LR = false;\n    // let leftright_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (left/right) if user move their eyes in\n    //  * horizontal direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=41\n    // //% block=\"direction (HEOG)\"\n    // export function gazeH(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50 // [Hz]\n    //     const period = 1000000 / down_sample_fs // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     let avgBuffer = 0;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (leftright_buffer.length < buffer_size) {\n    //             leftright_buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (leftright_buffer.length == buffer_size) {\n    //             leftright_buffer.shift();\n    //             leftright_buffer.push(signal);\n\n    //             // Calculate average of buffer\n    //             avgBuffer = leftright_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Looking Left\n    //             if (avgBuffer > baseline * 1.25) {\n    //                 if (currently_right) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_left = true;\n    //                     result = LookingAt.left;\n    //                 }\n    //             }\n    //             // Looking Right\n    //             else if (avgBuffer < baseline * 0.75) {\n    //                 if (currently_left) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_right = true;\n    //                     result = LookingAt.right;\n    //                 }\n    //             }\n    //             else {\n    //                 if (center_LR) {\n    //                     currently_left = false;\n    //                     currently_right = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return result;\n\n    // }\n\n\n    // /**\n    //  * Return true if user blinks within some time, false otherwise.\n    //  * Defining time is optional argument (the default is one second). \n    //  * @param ms (optional) = duration(ms) to check blink. The default is 1000 (i.e 1 seconds).\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=40\n    // //% block=\"blinked|| within $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=1000\n    // export function blinks(ms?: number): boolean {\n    //     const down_sample_fs = 50 //[Hz]\n    //     const period = 1000000 / down_sample_fs //[μs/hz]\n    //     let elapsed_time = 0;\n\n    //     const buffer_size = 2;\n    //     let buffer = [];\n\n    //     const threshold = 40;\n    //     const blink_time = 300; //[ms]\n\n    //     let blink_check_timer = 0;\n    //     let start_val = 0;\n    //     let currently_checking = false;\n\n    //     let exit = false;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep calculating until \n    //     // 1). time runs out\n    //     // 2). user blinked\n    //     while (control.millis() - start_time < ms && !exit) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Do the following only when first point and second point \n    //             // differs by more than threshold\n    //             if (Math.abs(buffer[0] - buffer[1]) > threshold) {\n    //                 if (!currently_checking && buffer[1] > buffer[0]) {\n    //                     blink_check_timer = control.millis();\n    //                     start_val = buffer[0];\n    //                     currently_checking = true;\n    //                 }\n\n    //                 if (control.millis() - blink_check_timer < blink_time) {\n    //                     if (buffer[0] < start_val) {\n    //                         currently_checking = false;\n    //                         exit = true;\n    //                     }\n    //                 }\n    //                 else {\n    //                     currently_checking = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return exit;\n\n    // }\n\n\n    // /**\n    //  * Looking Up (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=39\n    // //% block=\"up\"\n    // export function up(): number {\n    //     return LookingAt.up;\n    // }\n\n\n    // /**\n    //  * Looking Down (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=38\n    // //% block=\"down\"\n    // export function down(): number {\n    //     return LookingAt.down;\n    // }\n\n\n    // /**\n    //  * Looking Left (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=37\n    // //% block=\"left\"\n    // export function left(): number {\n    //     return LookingAt.left;\n    // }\n\n\n    // /**\n    //  * Looking Right (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=36\n    // //% block=\"right\"\n    // export function right(): number {\n    //     return LookingAt.right;\n    // }\n\n\n    // /**\n    //  * Blink (use with VEOG direction)\n    // */\n\n    // //% group=\"EOG\"\n    // //% weight=35\n    // //% block=\"blink\"\n    // export function blink(): number {\n    //     return LookingAt.blink;\n    // }\n\n\n    \n\n    // /**\n    //  * Set the angle for servo.\n    //  * @param angle = the angle for servo (in degree)\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=28\n    // //% block=\"set servo to $angle degrees\"\n    // export function servo_control(angle: number) {\n    //     pins.servoWritePin(AnalogPin.P0, angle);\n    // }\n\n\n    // /**\n    //  * Pause the program from running until user defined time(ms) pass.\n    //  * If the user provided second argument, pause the program for\n    //  * randomized time between the first input to second input \n    //  *(both inclusinve).\n    //  * @param start = time to pause program. \n    //  * @param end (optional) = use start and end to as range to pick the random time. The default is 0.\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=27\n    // //% block=\"Wait for $start (ms) || $end (ms)\"\n    // //% start.shadow=timePicker\n    // //% end.shadow=timePicker\n    // //% wait.defl=0;\n    // export function wait(start: number, end?: number) {\n    //     let waiting_time = 0;\n\n    //     // If user provides the second argument, choose random time,\n    //     // to wait, else set the the first argument.\n    //     if (end > 0 && end > start) {\n    //         waiting_time = randint(start, end);\n    //     }\n    //     else {\n    //         waiting_time = start;\n    //     }\n\n    //     // Run while loop for some duration\n    //     const start_time = control.millis();\n    //     while (control.millis() - start_time < waiting_time) {\n    //         continue;\n    //     }\n    // }\n\n}\n","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1727123564865,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"neurobit_envelope\"><next><block type=\"neurobit_set_emg\"><next><block type=\"neurobit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation></block></next></block></next></block></statement></block></xml>","main.ts":"neurobit.envelope()\nneurobit.set_emg()\nneurobit.print()\n","README.md":"","custom.ts":"// Enums to be used in extension\n// enum Signal {\n//     EEG,\n//     EMG,\n//     ECG,\n//     EOG\n// }\n\n// enum Cue {\n//     none,\n//     visual,\n//     audio\n// }\n\n// enum LookingAt {\n//     none,\n//     up,\n//     left,\n//     right,\n//     down,\n//     blink\n// }\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    /**\n     * Global initialization\n     */\n    const fs = 250; //[Hz]\n    const time_range = 5000; //[ms]\n    const neurobit_buffer_size = (fs * (time_range / 1000));\n    let neurobit_buffer: number[] = [];\n    let neurobit_write_index = 0;\n    let neurobit_read_index = 0;\n\n    const PIN = AnalogPin.P1;\n\n    let signal_label = \"EEG\"; //Default EEG \n\n    let apply_envelope = false;\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n    \n    export function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        //Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n        \n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Background Process\n     */\n    control.inBackground(function () {\n        const time_delay = 20; //[ms] \n        const index_gap = Math.ceil(fs / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < neurobit_buffer_size; i++) {\n            neurobit_buffer[i] = 0;\n        }\n\n        // \"Actual\" background processing\n        while (true) {\n            neurobit_buffer[neurobit_write_index] = pins.analogReadPin(PIN);\n            neurobit_write_index++;\n\n            // Loop back write_index after reach to end\n            if (neurobit_write_index >= neurobit_buffer_size) {\n                neurobit_write_index = 0;\n            }\n            \n            // Caluclation for correct read_index\n            if (neurobit_write_index < index_gap) {\n                neurobit_read_index = neurobit_buffer_size - (index_gap - neurobit_write_index);\n            }\n            else {\n                neurobit_read_index = neurobit_write_index - index_gap;\n            }\n\n            // Pause (tick = 4ms)\n            basic.pause(0);\n        }\n    })\n\n    /**\n     * Record EMG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=105\n    //% block=\"record EMG in background\"\n    export function set_emg() {\n        pins.digitalWritePin(DigitalPin.P8, 1);\n        pins.digitalWritePin(DigitalPin.P9, 1);\n        signal_label = \"EMG\";\n    }\n\n    /**\n     * Record EKG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=104\n    //% block=\"record EKG in background\"\n    export function set_ekg() {\n        pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 1);\n        signal_label = \"EKG\";\n    }\n\n    /**\n     * Record EEG in background\n     */\n\n    //% group=\"Signal\"\n    //% weight=103\n    //% block=\"record ECG in background\"\n    export function set_eeg() {\n        pins.digitalWritePin(DigitalPin.P8, 0);\n        pins.digitalWritePin(DigitalPin.P9, 0);\n        signal_label = \"EEG\";\n    }\n\n\n    /**\n     * Return last measurement\n     */\n\n    //% group=\"Signal\"\n    //% weight=102\n    //% block=\"return last measurement\"\n    export function last_measurement(): number {\n        return neurobit_buffer[neurobit_read_index];\n    }\n\n    //% group=\"Signal\"\n    //% weight=101\n    //% block=\"return buffer from last $duration ms\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    export function last_buffer(duration: number): number[] {\n        let copy_size = Math.floor(neurobit_buffer_size / (time_range / duration))\n        let copy = neurobit_buffer;\n        return copy;\n    }\n\n\n    /**\n     * Apply envelope to signal by initializing this block at the top of the code,\n     */\n\n    //% group=\"Signal\"\n    //% weight=100\n    //% block=\"apply envelope to signal\"\n    export function envelope() {\n        apply_envelope = true;\n    }\n\n\n    /**\n     * Choose the signal to print in Serial. \n     * You can also specify the specific time to run the printing. \n     * The default loops.\n     * @param signal = choose electrophysiology\n     * @param duration (optional) = duration(ms) to output the signal. If user does not provide one, then loops\n     */\n\n    //% group=\"Other\"\n    //% weight=30\n    //% block=\"print signal || for $duration ms\"\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (apply_envelope) {\n                    // Obtain the signal + make baseline to be 0\n                    let signal = last_measurement() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n                    \n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, last_measurement());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (apply_envelope) {\n                    // Obtain the signal + make baseline to be 0\n                    let signal = last_measurement() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, last_measurement());\n                }\n            }\n        }\n    }\n\n\n\n\n    // export function eeg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function emg(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // export function ecg(): number {\n    //     return pins.analogReadPin(AnalogPin.P1);\n    // }\n\n    // export function eog(): number {\n    //     return pins.analogReadPin(AnalogPin.P0);\n    // }\n\n    // /**\n    //  * Return the maximum threshold from some time intervals(ms).\n    //  * As an optional argument, you can change the percentage of threshold\n    //  * to be returned. The defaulut is 100(%).\n    //  * @param ms = duration(ms) to run the get and caluculate max theshold.\n    //  * @param percent (optional) = number as percentage of threshold to be returned. The default is 100%.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=46\n    // //% block=\"get threshold from $ms ms || and return with $percent percent\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.shadow=timePicker\n    // //% percent.defl=100\n    // export function getThreshold(ms: number, percent?: number) {\n    //     const startTimer = control.millis();\n    //     let val = 0;\n    //     let max_val = 0;\n\n    //     while (control.millis() - startTimer < ms) {\n    //         val = emg();\n\n    //         if (max_val < val) {\n    //             max_val = val;\n    //         }\n    //     }\n\n    //     return max_val * (percent / 100);\n    // }\n\n\n    // /**\n    //  * Return the number of spikes that happened during some duration(ms).\n    //  * You can also change the duration but the default is 3000 (i.e. 3 seconds).\n    //  * If you grip tight for minimum 500ms (then release), \n    //  * it will return as -1. \n    //  * @param ms = duration(ms) to run the spike recording.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=45\n    // //% block=\"count spikes for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% ms.defl=3000\n    // export function countSpikes(ms: number) {\n    //     const down_sample_fs = 200;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0;\n    //     let elapsed_time2 = 0;\n\n    //     const buffer_size = 20;\n    //     let buffer: number[] = [];\n\n    //     // Smoothing function for signal\n    //     function movingAverage(data: number[], windowSize: number): number {\n    //         let sum = 0.0;\n    //         let smoothedData = 0;\n    //         //overflow -> floating point\n    //         for (let j = 0; j < windowSize; j++) {\n    //             sum += data[j];\n    //         }\n    //         smoothedData = sum / windowSize;\n    //         return smoothedData;\n    //     }\n\n    //     const threshold = 150;\n    //     const interval = 500;\n    //     let signal = 0;\n    //     let smooth_signal = 0;\n    //     let counter = 0;\n    //     let checking = false;\n    //     let check_time = -interval;\n    //     let check_grip = false;\n\n    //     const startTimer = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Begin Timer\n    //     while (control.millis() - startTimer < ms) {\n    //         signal = emg();\n\n    //         // Fill the buffer before the main process\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // Once the buffer fills up, shift\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Smooth out the signal\n    //             smooth_signal = movingAverage(buffer, buffer.length);\n\n    //             // Check the signal above threshold\n    //             let sample_time2 = input.runningTimeMicros();\n    //             while (smooth_signal > threshold) {\n    //                 signal = emg();\n\n    //                 buffer.shift();\n    //                 buffer.push(signal);\n\n    //                 smooth_signal = movingAverage(buffer, buffer.length);\n\n    //                 if (!checking) {\n    //                     // Record the time when the spike is detected\n    //                     // for only once at the beggining during the rising\n    //                     check_time = control.millis();\n    //                     checking = true;\n    //                 }\n\n    //                 // Checking for grip\n    //                 check_grip = true;\n\n    //                 elapsed_time2 = input.runningTimeMicros() - sample_time2;\n\n    //                 if (elapsed_time2 < period) {\n    //                     control.waitMicros(period - elapsed_time2);\n    //                 }\n\n    //                 sample_time2 = input.runningTimeMicros();\n    //             }\n\n    //             // Once signl drops down below the threshold, allow \n    //             // check (for spike) to happen\n    //             checking = false;\n\n    //             // Check if the spike is within the interval window\n    //             // to reduce false positives\n    //             if (control.millis() - check_time < interval) {\n    //                 check_grip = false;\n    //                 counter++; // Increment counter for detected spikes\n    //                 check_time = -interval; // Reset check time\n    //             }\n\n    //             // If the signal goes over one second, assume due to\n    //             // the grip\n    //             if (check_grip) {\n    //                 counter = -1;\n    //             }\n\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return counter; // Return the spike count\n    // }\n\n\n    // /**\n    //  * Give the reaction time from certain cue. User have options to\n    //  * choose either from visual (Heart Icon) or audio (1/2 beat) cue\n    //  * with given threshold. \n    //  * @param cue (optional) = options for user to choose type of cue (visually or auditory). The default is none.\n    //  * @param threshold (optional) = user have option to select their desired threshold. The default is 200.\n    //  */\n\n    // //% group=\"EMG\"\n    // //% weight=44\n    // //% block=\"measure reaction time ||add cue $cue add threshold $threshold\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% threshold.defl=200\n    // //% inlineInputMode=inline\n    // export function reactionTime(cue?: Cue, threshold?: number) {\n    //     const cue_time = 100; // [ms]\n    //     const ms = 1500; // Give user 1.5 seconds to make reaction\n    //     let signal = 0;\n    //     let result = ms;\n    //     let once = true;\n\n    //     //At beggining, give user a cue if needed\n    //     switch (cue) {\n    //         case Cue.none: {\n    //             break;\n    //         }\n    //         case Cue.visual: {\n    //             basic.showIcon(IconNames.Heart, cue_time);\n    //             basic.clearScreen();\n    //             break;\n    //         }\n    //         case Cue.audio: {\n    //             pins.setAudioPin(AnalogPin.P16);\n    //             music.play(music.tonePlayable(262, cue_time),\n    //                 music.PlaybackMode.InBackground);\n    //             break;\n    //         }\n    //     }\n\n    //     const startTime = control.millis();\n\n    //     // Begin measuring the reaction time\n    //     while (control.millis() - startTime < ms) {\n    //         signal = emg();\n    //         // (only once) if the signal go above the threshold,\n    //         // save the reaction time. \n    //         if (signal > threshold && once) {\n    //             result = control.millis() - startTime;\n    //             once = false;\n    //         }\n    //     }\n\n    //     // If user fails to react, return as undefined (question mark)\n    //     if (result == ms) {\n    //         return undefined;\n    //     }\n    //     else {\n    //         return result;\n    //     }\n    // }\n\n\n    // /**\n    //  * Return the average heart beat (bpm) in 5 seconds(default).\n    //  * You can also change the time for recording from \n    //  * optional argument.\n    //  * @param ms (optional) = duration(ms) to run the hearbeat recording. The default is 5000 (i.e. 5 seconds).\n    //  */\n\n    // //% group=\"ECG\"\n    // //% weight=43\n    // //% block=\"measure heartbeat (bpm) || for $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=5000\n    // export function heartBeat(ms: number) {\n    //     const down_sample_fs = 150 //Hz;\n    //     const period = 1000000 / down_sample_fs;\n    //     let elapsed_time = 0\n\n    //     const range = 300;\n    //     const buffer_size = 6;\n    //     let buffer: number[] = [];\n    //     // let buffer_index = 0;\n    //     let beat_num = 0;\n    //     let unit = 0;\n    //     let sum_unit = 0;\n    //     let wait = 0;\n    //     let last_beat = 0;\n\n\n    //     // Fill the buffer first\n    //     for (let i = 0; i < buffer_size; i++) {\n    //         buffer.push(ecg());\n    //     }\n\n    //     const startTime = control.millis();\n    //     let prev_beat = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - startTime < ms) {\n    //         if (wait <= 0) {\n\n    //             // Buffer minimum, maximum calculation\n    //             let buffer_min = buffer[0];\n    //             let buffer_max = buffer[0];\n\n    //             for (let i = 1; i < buffer_size; i++) {\n    //                 if (buffer_min > buffer[i]) {\n    //                     buffer_min = buffer[i];\n    //                 }\n\n    //                 if (buffer_max < buffer[i]) {\n    //                     buffer_max = buffer[i];\n    //                 }\n    //             }\n\n    //             // If the range of buffer is greator than certain range,\n    //             // do heartbeat caluculation\n    //             if (buffer_max - buffer_min > range) {\n    //                 basic.showIcon(IconNames.Heart, 150);\n    //                 basic.clearScreen();\n    //                 last_beat = control.millis() - prev_beat;\n    //                 prev_beat = control.millis();\n    //                 let largeBox = Math.floor(last_beat / 200);\n    //                 let smallBox = Math.floor((last_beat - largeBox * 200) / 40);\n    //                 unit = 1 * largeBox + 0.2 * smallBox;\n    //                 sum_unit += unit;\n    //                 beat_num++;\n    //                 // Wait for buffer_size * 3. \n    //                 // This is possible because distance between\n    //                 // human heart beat is no smaller than time for\n    //                 // buffer_size * 3 samples\n    //                 wait = buffer_size * 3;\n    //             }\n    //         }\n\n\n    //         // May need to use shift\n    //         buffer.shift();\n    //         buffer.push(ecg());\n    //         // buffer[buffer_index] = val;\n    //         // buffer_index = (buffer_index + 1) % buffer_size;\n    //         wait--;\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time)\n    //         }\n\n    //         sample_time = input.runningTimeMicros()\n    //     }\n\n    //     // Check to avoid division by zero\n    //     return beat_num > 0 ? 300 / (sum_unit / beat_num) : undefined;\n    // }\n\n\n    // let currently_up = false;\n    // let currently_down = false;\n    // let center_UD = false;\n    // let cooldown_counter = 0;\n    // let blink_buffer: number[] = [];\n    // let updown_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (up/down/blink) if user move their eyes in\n    //  * vertical direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=42\n    // //% block=\"direction (VEOG)\"\n    // export function gazeV(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50; // [Hz]\n    //     const period = 1000000 / down_sample_fs; // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     const wait_size = Math.floor(down_sample_fs / 3); // 1/3 of second\n    //     let avgBuffer = 0;\n\n    //     let slope = 0;\n    //     const cooldown_period = wait_size + buffer_size;\n\n    //     // Function to return the averge slope of buffer\n    //     function calculateSlope(data: number[]): number {\n    //         const n = data.length;\n    //         let xSum = 0;\n    //         let ySum = 0;\n    //         let xySum = 0;\n    //         let xSquaredSum = 0;\n\n    //         for (let x = 0; x < n; x++) {\n    //             xSum += x;\n    //             ySum += data[x];\n    //             xySum += x * data[x];\n    //             xSquaredSum += x * x;\n    //         }\n\n    //         return (n * xySum - xSum * ySum) / (n * xSquaredSum - xSum * xSum);\n    //     }\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // Shift the buffer so blink analysis happens eariler than\n    //         // up or down analysis\n    //         if (blink_buffer.length < wait_size) {\n    //             blink_buffer.push(signal);\n    //         } else {\n    //             if (updown_buffer.length < buffer_size) {\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             } else {\n    //                 updown_buffer.shift();\n    //                 updown_buffer.push(blink_buffer.shift());\n    //             }\n\n    //             blink_buffer.push(signal);\n    //         }\n\n    //         if (updown_buffer.length == buffer_size) {\n    //             slope = calculateSlope(blink_buffer.slice(0, buffer_size));\n    //             avgBuffer = updown_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Blinking\n    //             if (slope < -75) {\n    //                 // Begin cool down\n    //                 cooldown_counter = 0;\n    //                 result = LookingAt.blink;\n    //             }\n\n    //             // If cooldown is happening\n    //             if (cooldown_counter >= cooldown_period) {\n    //                 // Looking Up\n    //                 if (avgBuffer > baseline * 1.40) {\n    //                     if (currently_down) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.up;\n    //                         center_UD = false;\n    //                         currently_up = true;\n    //                     }\n    //                     // Looking Down \n    //                 } else if (avgBuffer < baseline * 0.60) {\n    //                     if (currently_up) {\n    //                         center_UD = true;\n    //                     } else {\n    //                         result = LookingAt.down;\n    //                         center_UD = false;\n    //                         currently_down = true;\n    //                     }\n    //                 } else {\n    //                     if (center_UD) {\n    //                         currently_up = false;\n    //                         currently_down = false;\n    //                     }\n    //                 }\n    //             } else {\n    //                 cooldown_counter++;\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return result;\n\n    // }\n\n\n    // let currently_left = false;\n    // let currently_right = false;\n    // let center_LR = false;\n    // let leftright_buffer: number[] = [];\n\n    // /**\n    //  * Return enums (left/right) if user move their eyes in\n    //  * horizontal direction.\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=41\n    // //% block=\"direction (HEOG)\"\n    // export function gazeH(): number {\n    //     const time = 500; // [ms]\n\n    //     const down_sample_fs = 50 // [Hz]\n    //     const period = 1000000 / down_sample_fs // [μs/hz]\n    //     let elapsed_time = 0;\n\n    //     let result = LookingAt.none;\n\n    //     const baseline = 450;\n\n    //     const buffer_size = 10;\n    //     let avgBuffer = 0;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep running until time runs out\n    //     while (control.millis() - start_time < time) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (leftright_buffer.length < buffer_size) {\n    //             leftright_buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (leftright_buffer.length == buffer_size) {\n    //             leftright_buffer.shift();\n    //             leftright_buffer.push(signal);\n\n    //             // Calculate average of buffer\n    //             avgBuffer = leftright_buffer.reduce((a, b) => a + b, 0) / buffer_size;\n\n    //             // Looking Left\n    //             if (avgBuffer > baseline * 1.25) {\n    //                 if (currently_right) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_left = true;\n    //                     result = LookingAt.left;\n    //                 }\n    //             }\n    //             // Looking Right\n    //             else if (avgBuffer < baseline * 0.75) {\n    //                 if (currently_left) {\n    //                     center_LR = true;\n    //                 }\n    //                 else {\n    //                     center_LR = false;\n    //                     currently_right = true;\n    //                     result = LookingAt.right;\n    //                 }\n    //             }\n    //             else {\n    //                 if (center_LR) {\n    //                     currently_left = false;\n    //                     currently_right = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return result;\n\n    // }\n\n\n    // /**\n    //  * Return true if user blinks within some time, false otherwise.\n    //  * Defining time is optional argument (the default is one second). \n    //  * @param ms (optional) = duration(ms) to check blink. The default is 1000 (i.e 1 seconds).\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=40\n    // //% block=\"blinked|| within $ms ms\"\n    // //% ms.shadow=timePicker\n    // //% expandableArgumentMode=\"enable\"\n    // //% ms.defl=1000\n    // export function blinks(ms?: number): boolean {\n    //     const down_sample_fs = 50 //[Hz]\n    //     const period = 1000000 / down_sample_fs //[μs/hz]\n    //     let elapsed_time = 0;\n\n    //     const buffer_size = 2;\n    //     let buffer = [];\n\n    //     const threshold = 40;\n    //     const blink_time = 300; //[ms]\n\n    //     let blink_check_timer = 0;\n    //     let start_val = 0;\n    //     let currently_checking = false;\n\n    //     let exit = false;\n\n    //     const start_time = control.millis();\n    //     let sample_time = input.runningTimeMicros();\n\n    //     // Keep calculating until \n    //     // 1). time runs out\n    //     // 2). user blinked\n    //     while (control.millis() - start_time < ms && !exit) {\n    //         let signal = eog();\n\n    //         // If the buffer is not full yet, keep adding\n    //         if (buffer.length < buffer_size) {\n    //             buffer.push(signal);\n    //         }\n\n    //         // If the buffer is full, begin main process\n    //         if (buffer.length == buffer_size) {\n    //             buffer.shift();\n    //             buffer.push(signal);\n\n    //             // Do the following only when first point and second point \n    //             // differs by more than threshold\n    //             if (Math.abs(buffer[0] - buffer[1]) > threshold) {\n    //                 if (!currently_checking && buffer[1] > buffer[0]) {\n    //                     blink_check_timer = control.millis();\n    //                     start_val = buffer[0];\n    //                     currently_checking = true;\n    //                 }\n\n    //                 if (control.millis() - blink_check_timer < blink_time) {\n    //                     if (buffer[0] < start_val) {\n    //                         currently_checking = false;\n    //                         exit = true;\n    //                     }\n    //                 }\n    //                 else {\n    //                     currently_checking = false;\n    //                 }\n    //             }\n    //         }\n\n    //         // Sampling Rate caluculation\n    //         elapsed_time = input.runningTimeMicros() - sample_time;\n\n    //         if (elapsed_time < period) {\n    //             control.waitMicros(period - elapsed_time);\n    //         }\n\n    //         sample_time = input.runningTimeMicros();\n    //     }\n\n    //     return exit;\n\n    // }\n\n\n    // /**\n    //  * Looking Up (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=39\n    // //% block=\"up\"\n    // export function up(): number {\n    //     return LookingAt.up;\n    // }\n\n\n    // /**\n    //  * Looking Down (use with VEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=38\n    // //% block=\"down\"\n    // export function down(): number {\n    //     return LookingAt.down;\n    // }\n\n\n    // /**\n    //  * Looking Left (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=37\n    // //% block=\"left\"\n    // export function left(): number {\n    //     return LookingAt.left;\n    // }\n\n\n    // /**\n    //  * Looking Right (use with HEOG direction)\n    //  */\n\n    // //% group=\"EOG\"\n    // //% weight=36\n    // //% block=\"right\"\n    // export function right(): number {\n    //     return LookingAt.right;\n    // }\n\n\n    // /**\n    //  * Blink (use with VEOG direction)\n    // */\n\n    // //% group=\"EOG\"\n    // //% weight=35\n    // //% block=\"blink\"\n    // export function blink(): number {\n    //     return LookingAt.blink;\n    // }\n\n\n    \n\n    // /**\n    //  * Set the angle for servo.\n    //  * @param angle = the angle for servo (in degree)\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=28\n    // //% block=\"set servo to $angle degrees\"\n    // export function servo_control(angle: number) {\n    //     pins.servoWritePin(AnalogPin.P0, angle);\n    // }\n\n\n    // /**\n    //  * Pause the program from running until user defined time(ms) pass.\n    //  * If the user provided second argument, pause the program for\n    //  * randomized time between the first input to second input \n    //  *(both inclusinve).\n    //  * @param start = time to pause program. \n    //  * @param end (optional) = use start and end to as range to pick the random time. The default is 0.\n    //  */\n\n    // //% group=\"Other\"\n    // //% weight=27\n    // //% block=\"Wait for $start (ms) || $end (ms)\"\n    // //% start.shadow=timePicker\n    // //% end.shadow=timePicker\n    // //% wait.defl=0;\n    // export function wait(start: number, end?: number) {\n    //     let waiting_time = 0;\n\n    //     // If user provides the second argument, choose random time,\n    //     // to wait, else set the the first argument.\n    //     if (end > 0 && end > start) {\n    //         waiting_time = randint(start, end);\n    //     }\n    //     else {\n    //         waiting_time = start;\n    //     }\n\n    //     // Run while loop for some duration\n    //     const start_time = control.millis();\n    //     while (control.millis() - start_time < waiting_time) {\n    //         continue;\n    //     }\n    // }\n\n}\n","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1727221691387,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"33\" y=\"50\"><statement name=\"HANDLER\"><block type=\"neurobit_startRecordingEMG\"><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_getSpikes\"><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">3000</field></shadow></value></block></value></block></next></block></statement></block></xml>","main.ts":"neurobit.startRecordingEMG()\nbasic.showNumber(neurobit.getSpikes(3000))\n","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    RAW,\n    ENVELOPE\n}\n\n\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let ecgTimestamps: number[] = [];\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n    let envelopeValue: number = 0\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    const ECG_JUMP = 40\n    const DEBOUNCE_PERIOD_ECG = 300\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"StartRecordingEMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"StartRecordingECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"StartRecordingEEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"getSignal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"getBuffer || of last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [-1];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"getEnvelope\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n        }\n        else {\n            return -1;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return 0;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=30\n    //% block=\"get max singal from $duration (ms) || * $constant\"\n    //% expandableArgumentMode=\"enable\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    //% constant.defl=1\n    export function getMaxSignal(duration: number, constant?: number): number {\n        if (duration < 0 || constant < 0) {\n            return -1;\n        }\n\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n        \n        while (control.millis() - startTimer < duration) {\n            val = getEnvelope();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return max_val * constant;\n    }\n\n    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"get spikes from $duration (ms)\"\n    //% duration.shadow=timePicker\n    //% duration.defl=3000\n    export function getSpikes(duration: number): number {\n        if (duration < 0) {\n            return -1;\n        }\n\n        const THRESHOLD = 50;\n\n        let signal = 0;\n        let counter = 0;\n        let check_once = false;\n\n        const startTimer = control.millis();\n        while (control.millis() - startTimer < duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return counter; // Return the spike count\n    }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"Print $shape signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1727302518394,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"neurobit_startRecordingEMG\"><next><block type=\"neurobit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">5000</field></shadow></value></block></next></block></statement></block></xml>","main.ts":"neurobit.startRecordingEMG()\nneurobit.print(SignalShape.ENVELOPE)\n","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    RAW,\n    ENVELOPE\n}\n\n\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let ecgTimestamps: number[] = [];\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n    let envelopeValue: number = 0\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    const ECG_JUMP = 40\n    const DEBOUNCE_PERIOD_ECG = 300\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"StartRecordingEMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"StartRecordingECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"StartRecordingEEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"getSignal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"getBuffer || of last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [-1];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"getEnvelope\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n        }\n        else {\n            return -1;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return 0;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=30\n    //% block=\"get max singal from $duration (ms) || * $constant\"\n    //% expandableArgumentMode=\"enable\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    //% constant.defl=1\n    export function getMaxSignal(duration: number, constant?: number): number {\n        if (duration < 0 || constant < 0) {\n            return -1;\n        }\n\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n        \n        while (control.millis() - startTimer < duration) {\n            val = getEnvelope();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return max_val * constant;\n    }\n\n    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"get spikes from $duration (ms)\"\n    //% duration.shadow=timePicker\n    //% duration.defl=3000\n    export function getSpikes(duration: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (duration < 0) {\n            return -1;\n        }\n        \n        const THRESHOLD = 50;\n\n        let signal = 0;\n        let counter = 0;\n        let check_once = false;\n\n        const startTimer = control.millis();\n        while (control.millis() - startTimer < duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return counter;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=28\n    //% block=\"get reaction time ||with threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=50\n    export function reactionTime(threshold?: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (threshold < 0) {\n            return -1;\n        }\n\n        const time_limit = 10000; // Maximum 10 seconds to make reaction\n        let signal = 0;\n        let result_time = 0;\n\n        const startTime = control.millis();\n\n        signal = getEnvelope();\n        while (signal < threshold) {\n            signal = getEnvelope();\n            result_time = control.millis() - startTime;\n            if (result_time > time_limit) return -1;\n            serial.writeLine(\"\");\n        }\n\n        return result_time;\n    }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"Print $shape signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1727378616857,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"neurobit_startRecordingEMG\"><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value><next><block type=\"music_playable_play\"><field name=\"playbackMode\">music.PlaybackMode.UntilDone</field><value name=\"toPlay\"><shadow type=\"music_tone_playable\"><value name=\"note\"><shadow type=\"device_note\"><field name=\"name\">262</field></shadow></value><value name=\"duration\"><shadow type=\"device_beat\"><field name=\"fraction\">BeatFraction.Half</field></shadow></value></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_getReactionTime\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"threshold\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value></block></value></block></next></block></next></block></next></block></statement></block></xml>","main.ts":"neurobit.startRecordingEMG()\nbasic.pause(2000)\nmusic.play(music.tonePlayable(262, music.beat(BeatFraction.Half)), music.PlaybackMode.UntilDone)\nbasic.showNumber(neurobit.getReactionTime())\n","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    RAW,\n    ENVELOPE\n}\n\n\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let ecgTimestamps: number[] = [];\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n    let envelopeValue: number = 0\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    const ECG_JUMP = 40\n    const DEBOUNCE_PERIOD_ECG = 300\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"StartRecordingEMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"StartRecordingECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"StartRecordingEEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"getSignal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"getBuffer || of last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [-1];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"getEnvelope\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n        }\n        else {\n            return -1;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return 0;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=30\n    //% block=\"get max singal from $duration (ms) || * $constant\"\n    //% expandableArgumentMode=\"enable\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    //% constant.defl=1\n    export function getMaxSignal(duration: number, constant?: number): number {\n        if (duration < 0 || constant < 0) {\n            return -1;\n        }\n\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n        \n        while (control.millis() - startTimer < duration) {\n            val = getEnvelope();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return max_val * constant;\n    }\n\n    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"get spikes from $duration (ms)\"\n    //% duration.shadow=timePicker\n    //% duration.defl=3000\n    export function getSpikes(duration: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (duration < 0) {\n            return -1;\n        }\n        \n        const THRESHOLD = 50;\n\n        let signal = 0;\n        let counter = 0;\n        let check_once = false;\n\n        const startTimer = control.millis();\n        while (control.millis() - startTimer < duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return counter;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=28\n    //% block=\"get reaction time|| with threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=50\n    export function getReactionTime(threshold?: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (threshold < 0) {\n            return -1;\n        }\n\n        const time_limit = 10000; // Maximum 10 seconds to make reaction\n        let signal = 0;\n        let result_time = 0;\n\n        const startTime = control.millis();\n\n        signal = getEnvelope();\n        while (signal < threshold) {\n            signal = getEnvelope();\n            result_time = control.millis() - startTime;\n            if (result_time > time_limit) return -1;\n            serial.writeLine(\"\");\n        }\n\n        return result_time;\n    }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"Print $shape signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free testing space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1727450021421,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"neurobit_startRecordingEMG\"><next><block type=\"device_pause\"><value name=\"pause\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value><next><block type=\"music_playable_play\"><field name=\"playbackMode\">music.PlaybackMode.UntilDone</field><value name=\"toPlay\"><shadow type=\"music_tone_playable\"><value name=\"note\"><shadow type=\"device_note\"><field name=\"name\">262</field></shadow></value><value name=\"duration\"><shadow type=\"device_beat\"><field name=\"fraction\">BeatFraction.Half</field></shadow></value></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"neurobit_getReactionTime\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><value name=\"threshold\"><shadow type=\"math_number\"><field name=\"NUM\">50</field></shadow></value></block></value></block></next></block></next></block></next></block></statement></block></xml>","main.ts":"neurobit.startRecordingEMG()\nbasic.pause(2000)\nmusic.play(music.tonePlayable(262, music.beat(BeatFraction.Half)), music.PlaybackMode.UntilDone)\nbasic.showNumber(neurobit.getReactionTime())\n","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    RAW,\n    ENVELOPE\n}\n\n\n\n//% color=\"#E69138\" icon=\"\\uf188\" weight=90\nnamespace neurobit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    \n    let envelopeValue: number = 0;\n\n    const ECG_JUMP = 40;\n    const DEBOUNCE_PERIOD_ECG = 300;\n\n    let ecgTimestamps: number[] = [];\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n\n    const SAMPLING_RATE: number = 250; // Hz\n    const ALPHA_WAVE_FREQUENCY: number = 10; // Hz (Notch frequency)\n    const Q: number = 1; // Quality factor\n    const BASELINE_ALPHA: number = 20;\n\n    let gInputKeepBuffer: number[] = [0, 0];\n    let gOutputKeepBuffer: number[] = [0, 0];\n\n    let tempCalculationValue: number = 0\n    let coefficients: number[] = [0, 0, 0, 0, 0];\n    let eegSignalPower: number = 0;\n    let eegNotchedSignalPower: number = 0;\n    let filteredValue: number = 0;\n    let eegAlphaPower: number = 0;\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Calculate intermediate variables and set filter coefficients\n     */\n    function calculateNotchCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = 1 / a0;\n        const b1 = (-2 * omegaC) / a0;\n        const b2 = 1 / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n        // Set the coefficients array\n        coefficients[0] = b0;\n        coefficients[1] = b1;\n        coefficients[2] = b2;\n        coefficients[3] = a1;\n        coefficients[4] = a2;\n    }\n    \n    function filterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (coefficients[0] * inputValue) +\n            (coefficients[1] * gInputKeepBuffer[0]) +\n            (coefficients[2] * gInputKeepBuffer[1]) -\n            (coefficients[3] * gOutputKeepBuffer[0]) -\n            (coefficients[4] * gOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        gInputKeepBuffer[1] = gInputKeepBuffer[0]; // x[n-2] = x[n-1]\n        gInputKeepBuffer[0] = inputValue;           // x[n-1] = x[n]\n\n        // Update the output buffer (shift the samples)\n        gOutputKeepBuffer[1] = gOutputKeepBuffer[0]; // y[n-2] = y[n-1]\n        gOutputKeepBuffer[0] = y;                     // y[n-1] = y[n]\n\n        return y | 0;\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n                eegSignalPower = eegSignalPower * 0.99 + 0.01 * (Math.abs(tempCalculationValue - 512))\n                filteredValue = filterSingleSample(tempCalculationValue)\n                eegNotchedSignalPower = eegNotchedSignalPower * 0.99 + 0.01 * (Math.abs(filteredValue - 512))\n                eegAlphaPower = (eegSignalPower - eegNotchedSignalPower) - BASELINE_ALPHA;\n                if (eegAlphaPower < 0) {\n                    eegAlphaPower = 0;\n                }\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"StartRecordingEMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"StartRecordingECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"StartRecordingEEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"getSignal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"getBuffer || of last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [0];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"getEnvelope\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return eegAlphaPower;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=30\n    //% block=\"get max singal from $duration (ms) || * $constant\"\n    //% expandableArgumentMode=\"enable\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    //% constant.defl=1\n    export function getMaxSignal(duration: number, constant?: number): number {\n        if (duration < 0 || constant < 0) {\n            return undefined;\n        }\n\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n        \n        while (control.millis() - startTimer < duration) {\n            val = getEnvelope();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return max_val * constant;\n    }\n\n    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"get spikes from $duration (ms)\"\n    //% duration.shadow=timePicker\n    //% duration.defl=3000\n    export function getSpikes(duration: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (duration < 0) {\n            return undefined;\n        }\n        \n        const THRESHOLD = 50;\n\n        let signal = 0;\n        let counter = 0;\n        let check_once = false;\n\n        const startTimer = control.millis();\n        while (control.millis() - startTimer < duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return counter;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=28\n    //% block=\"get reaction time|| with threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=50\n    export function getReactionTime(threshold?: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (threshold < 0) {\n            return undefined;\n        }\n\n        const time_limit = 10000; // Maximum 10 seconds to make reaction\n        let signal = 0;\n        let result_time = 0;\n\n        const startTime = control.millis();\n\n        signal = getEnvelope();\n        while (signal < threshold) {\n            signal = getEnvelope();\n            result_time = control.millis() - startTime;\n            if (result_time > time_limit) return time_limit;\n            serial.writeLine(\"\");\n        }\n\n        return result_time;\n    }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"Print $shape signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free Testing Space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1727736006461,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables></xml>","main.ts":"\n","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    RAW,\n    ENVELOPE\n}\n\n\n\n//% color=\"#FF805E\" icon=\"\\uf188\" weight=90\nnamespace spikerbit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    \n    let envelopeValue: number = 0;\n\n    const ECG_JUMP = 40;\n    const DEBOUNCE_PERIOD_ECG = 300;\n\n    let ecgTimestamps: number[] = [];\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n\n    const SAMPLING_RATE: number = 250; // Hz\n    const ALPHA_WAVE_FREQUENCY: number = 10; // Hz (Notch frequency)\n    const Q: number = 1; // Quality factor\n    const BASELINE_ALPHA: number = 20;\n\n    let gInputKeepBuffer: number[] = [0, 0];\n    let gOutputKeepBuffer: number[] = [0, 0];\n\n    let tempCalculationValue: number = 0\n    let coefficients: number[] = [0, 0, 0, 0, 0];\n    let eegSignalPower: number = 0;\n    let eegNotchedSignalPower: number = 0;\n    let filteredValue: number = 0;\n    let eegAlphaPower: number = 0;\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Calculate intermediate variables and set filter coefficients\n     */\n    function calculateNotchCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = 1 / a0;\n        const b1 = (-2 * omegaC) / a0;\n        const b2 = 1 / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n        // Set the coefficients array\n        coefficients[0] = b0;\n        coefficients[1] = b1;\n        coefficients[2] = b2;\n        coefficients[3] = a1;\n        coefficients[4] = a2;\n    }\n    \n    function filterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (coefficients[0] * inputValue) +\n            (coefficients[1] * gInputKeepBuffer[0]) +\n            (coefficients[2] * gInputKeepBuffer[1]) -\n            (coefficients[3] * gOutputKeepBuffer[0]) -\n            (coefficients[4] * gOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        gInputKeepBuffer[1] = gInputKeepBuffer[0]; // x[n-2] = x[n-1]\n        gInputKeepBuffer[0] = inputValue;           // x[n-1] = x[n]\n\n        // Update the output buffer (shift the samples)\n        gOutputKeepBuffer[1] = gOutputKeepBuffer[0]; // y[n-2] = y[n-1]\n        gOutputKeepBuffer[0] = y;                     // y[n-1] = y[n]\n\n        return y | 0;\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n                eegSignalPower = eegSignalPower * 0.99 + 0.01 * (Math.abs(tempCalculationValue - 512))\n                filteredValue = filterSingleSample(tempCalculationValue)\n                eegNotchedSignalPower = eegNotchedSignalPower * 0.99 + 0.01 * (Math.abs(filteredValue - 512))\n                eegAlphaPower = (eegSignalPower - eegNotchedSignalPower) - BASELINE_ALPHA;\n                if (eegAlphaPower < 0) {\n                    eegAlphaPower = 0;\n                }\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"StartRecordingEMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"StartRecordingECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"StartRecordingEEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"getSignal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"getBuffer || of last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [0];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"getEnvelope\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return eegAlphaPower;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=30\n    //% block=\"get max singal from $duration (ms) || * $constant\"\n    //% expandableArgumentMode=\"enable\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    //% constant.defl=1\n    export function getMaxSignal(duration: number, constant?: number): number {\n        if (duration < 0 || constant < 0) {\n            return undefined;\n        }\n\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n        \n        while (control.millis() - startTimer < duration) {\n            val = getEnvelope();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return max_val * constant;\n    }\n\n    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"get spikes from $duration (ms)\"\n    //% duration.shadow=timePicker\n    //% duration.defl=3000\n    export function getSpikes(duration: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (duration < 0) {\n            return undefined;\n        }\n        \n        const THRESHOLD = 50;\n\n        let signal = 0;\n        let counter = 0;\n        let check_once = false;\n\n        const startTimer = control.millis();\n        while (control.millis() - startTimer < duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return counter;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=28\n    //% block=\"get reaction time|| with threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=50\n    export function getReactionTime(threshold?: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (threshold < 0) {\n            return undefined;\n        }\n\n        const time_limit = 10000; // Maximum 10 seconds to make reaction\n        let signal = 0;\n        let result_time = 0;\n\n        const startTime = control.millis();\n\n        signal = getEnvelope();\n        while (signal < threshold) {\n            signal = getEnvelope();\n            result_time = control.millis() - startTime;\n            if (result_time > time_limit) return time_limit;\n            serial.writeLine(\"\");\n        }\n\n        return result_time;\n    }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"Print $shape signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free Testing Space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1727806764611,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"38\" y=\"17\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"><next><block type=\"music_playable_play\"><field name=\"playbackMode\">music.PlaybackMode.UntilDone</field><value name=\"toPlay\"><shadow type=\"music_tone_playable\"><value name=\"note\"><shadow type=\"device_note\"><field name=\"name\">262</field></shadow></value><value name=\"duration\"><shadow type=\"device_beat\"><field name=\"fraction\">BeatFraction.Half</field></shadow></value></shadow></value><next><block type=\"device_show_number\"><value name=\"number\"><block type=\"spikerbit_getSpikes\"><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">2000</field></shadow></value></block></value></block></next></block></next></block></statement></block></xml>","main.ts":"","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    RAW,\n    ENVELOPE\n}\n\n\n\n//% color=\"#FF805E\" icon=\"\\uf188\" weight=90\nnamespace spikerbit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    \n    let envelopeValue: number = 0;\n\n    const ECG_JUMP = 40;\n    const DEBOUNCE_PERIOD_ECG = 300;\n\n    let ecgTimestamps: number[] = [];\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n\n    const SAMPLING_RATE: number = 250; // Hz\n    const ALPHA_WAVE_FREQUENCY: number = 10; // Hz (Notch frequency)\n    const Q: number = 1; // Quality factor\n    const BASELINE_ALPHA: number = 20;\n\n    let gInputKeepBuffer: number[] = [0, 0];\n    let gOutputKeepBuffer: number[] = [0, 0];\n\n    let tempCalculationValue: number = 0\n    let coefficients: number[] = [0, 0, 0, 0, 0];\n    let eegSignalPower: number = 0;\n    let eegNotchedSignalPower: number = 0;\n    let filteredValue: number = 0;\n    let eegAlphaPower: number = 0;\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 50; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Calculate intermediate variables and set filter coefficients\n     */\n    function calculateNotchCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = 1 / a0;\n        const b1 = (-2 * omegaC) / a0;\n        const b2 = 1 / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n        // Set the coefficients array\n        coefficients[0] = b0;\n        coefficients[1] = b1;\n        coefficients[2] = b2;\n        coefficients[3] = a1;\n        coefficients[4] = a2;\n    }\n    \n    function filterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (coefficients[0] * inputValue) +\n            (coefficients[1] * gInputKeepBuffer[0]) +\n            (coefficients[2] * gInputKeepBuffer[1]) -\n            (coefficients[3] * gOutputKeepBuffer[0]) -\n            (coefficients[4] * gOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        gInputKeepBuffer[1] = gInputKeepBuffer[0]; // x[n-2] = x[n-1]\n        gInputKeepBuffer[0] = inputValue;           // x[n-1] = x[n]\n\n        // Update the output buffer (shift the samples)\n        gOutputKeepBuffer[1] = gOutputKeepBuffer[0]; // y[n-2] = y[n-1]\n        gOutputKeepBuffer[0] = y;                     // y[n-1] = y[n]\n\n        return y | 0;\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n                eegSignalPower = eegSignalPower * 0.99 + 0.01 * (Math.abs(tempCalculationValue - 512))\n                filteredValue = filterSingleSample(tempCalculationValue)\n                eegNotchedSignalPower = eegNotchedSignalPower * 0.99 + 0.01 * (Math.abs(filteredValue - 512))\n                eegAlphaPower = (eegSignalPower - eegNotchedSignalPower) - BASELINE_ALPHA;\n                if (eegAlphaPower < 0) {\n                    eegAlphaPower = 0;\n                }\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"StartRecordingEMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"StartRecordingECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"StartRecordingEEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"getSignal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"getBuffer || of last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [0];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"getEnvelope\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return eegAlphaPower;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=30\n    //% block=\"get max singal from $duration (ms) || * $constant\"\n    //% expandableArgumentMode=\"enable\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    //% constant.defl=1\n    export function getMaxSignal(duration: number, constant?: number): number {\n        if (duration < 0 || constant < 0) {\n            return undefined;\n        }\n\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n        \n        while (control.millis() - startTimer < duration) {\n            val = getEnvelope();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return max_val * constant;\n    }\n\n    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"get spikes from $duration (ms)\"\n    //% duration.shadow=timePicker\n    //% duration.defl=3000\n    export function getSpikes(duration: number): number {\n        basic.pause(50); //To avoid weird spike happen when turning on\n\n        if (duration < 0) {\n            return undefined;\n        }\n        \n        const THRESHOLD = 25;\n\n        let signal = 0;\n        let counter = 0;\n        let check_once = false;\n\n        const startTimer = control.millis();\n        while (control.millis() - startTimer < duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                if (control.millis() - startTimer > duration) {\n                    return -1;\n                }\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return counter;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=28\n    //% block=\"get reaction time|| with threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=50\n    export function getReactionTime(threshold?: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (threshold < 0) {\n            return undefined;\n        }\n\n        const time_limit = 10000; // Maximum 10 seconds to make reaction\n        let signal = 0;\n        let result_time = 0;\n\n        const startTime = control.millis();\n\n        signal = getEnvelope();\n        while (signal < threshold) {\n            signal = getEnvelope();\n            result_time = control.millis() - startTime;\n            if (result_time > time_limit) return time_limit;\n            serial.writeLine(\"\");\n        }\n\n        return result_time;\n    }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"Print $shape signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free Testing Space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1727912972935,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"><next><block type=\"spikerbit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field></block></next></block></statement></block><block type=\"device_forever\" x=\"348\" y=\"20\"></block></xml>","main.ts":"","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    RAW,\n    ENVELOPE\n}\n\n\n\n//% color=\"#FF805E\" icon=\"\\uf188\" weight=90\nnamespace spikerbit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    \n    let envelopeValue: number = 0;\n\n    const ECG_JUMP = 40;\n    const DEBOUNCE_PERIOD_ECG = 300;\n\n    let ecgTimestamps: number[] = [];\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n\n    const SAMPLING_RATE: number = 250; // Hz\n    const ALPHA_WAVE_FREQUENCY: number = 10; // Hz (Notch frequency)\n    const Q: number = 1; // Quality factor\n    const BASELINE_ALPHA: number = 20;\n\n    let gInputKeepBuffer: number[] = [0, 0];\n    let gOutputKeepBuffer: number[] = [0, 0];\n\n    let tempCalculationValue: number = 0\n    let coefficients: number[] = [0, 0, 0, 0, 0];\n    let eegSignalPower: number = 0;\n    let eegNotchedSignalPower: number = 0;\n    let filteredValue: number = 0;\n    let eegAlphaPower: number = 0;\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 30; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Calculate intermediate variables and set filter coefficients\n     */\n    function calculateNotchCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = 1 / a0;\n        const b1 = (-2 * omegaC) / a0;\n        const b2 = 1 / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n        // Set the coefficients array\n        coefficients[0] = b0;\n        coefficients[1] = b1;\n        coefficients[2] = b2;\n        coefficients[3] = a1;\n        coefficients[4] = a2;\n    }\n    \n    function filterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (coefficients[0] * inputValue) +\n            (coefficients[1] * gInputKeepBuffer[0]) +\n            (coefficients[2] * gInputKeepBuffer[1]) -\n            (coefficients[3] * gOutputKeepBuffer[0]) -\n            (coefficients[4] * gOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        gInputKeepBuffer[1] = gInputKeepBuffer[0]; // x[n-2] = x[n-1]\n        gInputKeepBuffer[0] = inputValue;           // x[n-1] = x[n]\n\n        // Update the output buffer (shift the samples)\n        gOutputKeepBuffer[1] = gOutputKeepBuffer[0]; // y[n-2] = y[n-1]\n        gOutputKeepBuffer[0] = y;                     // y[n-1] = y[n]\n\n        return y | 0;\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n                eegSignalPower = eegSignalPower * 0.99 + 0.01 * (Math.abs(tempCalculationValue - 512))\n                filteredValue = filterSingleSample(tempCalculationValue)\n                eegNotchedSignalPower = eegNotchedSignalPower * 0.99 + 0.01 * (Math.abs(filteredValue - 512))\n                eegAlphaPower = (eegSignalPower - eegNotchedSignalPower) - BASELINE_ALPHA;\n                if (eegAlphaPower < 0) {\n                    eegAlphaPower = 0;\n                }\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"StartRecordingEMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"StartRecordingECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"StartRecordingEEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"getSignal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"getBuffer || of last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [0];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"getEnvelope\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // // Obtain the signal + set baseline to 0\n            // let signal = getSignal() - 512;\n            // // Rectify the signal\n            // let rectified_signal = Math.abs(signal);\n\n            // // Serial Out the signal\n            // return convolution(rectified_signal);\n            \n            return envelopeValue;\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return eegAlphaPower;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=30\n    //% block=\"get max singal from $duration (ms) || * $constant\"\n    //% expandableArgumentMode=\"enable\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    //% constant.defl=1\n    export function getMaxSignal(duration: number, constant?: number): number {\n        if (duration < 0 || constant < 0) {\n            return undefined;\n        }\n\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n        \n        while (control.millis() - startTimer < duration) {\n            val = getEnvelope();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return max_val * constant;\n    }\n\n    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"get spikes from $duration (ms)\"\n    //% duration.shadow=timePicker\n    //% duration.defl=3000\n    export function getSpikes(duration: number): number {\n        basic.pause(50); //To avoid weird spike happen when turning on\n\n        if (duration < 0) {\n            return undefined;\n        }\n        \n        const THRESHOLD = 50;\n\n        let signal = 0;\n        let counter = 0;\n        let check_once = false;\n\n        const startTimer = control.millis();\n        while (control.millis() - startTimer < duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                if (control.millis() - startTimer > duration) {\n                    return -1;\n                }\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return counter;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=28\n    //% block=\"get reaction time|| with threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=50\n    export function getReactionTime(threshold?: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (threshold < 0) {\n            return undefined;\n        }\n\n        const time_limit = 10000; // Maximum 10 seconds to make reaction\n        let signal = 0;\n        let result_time = 0;\n\n        const startTime = control.millis();\n\n        signal = getEnvelope();\n        while (signal < threshold) {\n            signal = getEnvelope();\n            result_time = control.millis() - startTime;\n            if (result_time > time_limit) return time_limit;\n            serial.writeLine(\"\");\n        }\n\n        return result_time;\n    }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"Print $shape signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    // serial.writeValue(signal_label, convolution(rectified_signal));\n                    serial.writeValue(signal_label, getEnvelope());\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free Testing Space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1728058151362,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"265\" y=\"-5\"><statement name=\"HANDLER\"><block type=\"controls_if\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\"><field name=\"OP\">GT</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"spikerbit_getEnvelope\"></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">25</field></shadow></value></block></value><statement name=\"DO0\"><block type=\"servoservosetangle\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractorPicker\"><field name=\"angle\">90</field></shadow></value></block></statement><statement name=\"ELSE\"><block type=\"servoservosetangle\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractorPicker\"><field name=\"angle\">180</field></shadow></value></block></statement></block></statement></block><block type=\"pxt-on-start\" x=\"33\" y=\"50\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"><next><block type=\"spikerbit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">0</field></shadow></value></block></next></block></statement></block></xml>","main.ts":"","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    RAW,\n    ENVELOPE\n}\n\n\n\n//% color=\"#FF805E\" icon=\"\\uf188\" weight=90\nnamespace spikerbit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    \n    let envelopeValue: number = 0;\n\n    const ECG_JUMP = 40;\n    const DEBOUNCE_PERIOD_ECG = 300;\n\n    let ecgTimestamps: number[] = [];\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n\n    const SAMPLING_RATE: number = 250; // Hz\n    const ALPHA_WAVE_FREQUENCY: number = 10; // Hz (Notch frequency)\n    const Q: number = 1; // Quality factor\n    const BASELINE_ALPHA: number = 20;\n\n    let gInputKeepBuffer: number[] = [0, 0];\n    let gOutputKeepBuffer: number[] = [0, 0];\n\n    let tempCalculationValue: number = 0\n    let coefficients: number[] = [0, 0, 0, 0, 0];\n    let eegSignalPower: number = 0;\n    let eegNotchedSignalPower: number = 0;\n    let filteredValue: number = 0;\n    let eegAlphaPower: number = 0;\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 20; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Calculate intermediate variables and set filter coefficients\n     */\n    function calculateNotchCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = 1 / a0;\n        const b1 = (-2 * omegaC) / a0;\n        const b2 = 1 / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n        // Set the coefficients array\n        coefficients[0] = b0;\n        coefficients[1] = b1;\n        coefficients[2] = b2;\n        coefficients[3] = a1;\n        coefficients[4] = a2;\n    }\n    \n    function filterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (coefficients[0] * inputValue) +\n            (coefficients[1] * gInputKeepBuffer[0]) +\n            (coefficients[2] * gInputKeepBuffer[1]) -\n            (coefficients[3] * gOutputKeepBuffer[0]) -\n            (coefficients[4] * gOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        gInputKeepBuffer[1] = gInputKeepBuffer[0]; // x[n-2] = x[n-1]\n        gInputKeepBuffer[0] = inputValue;           // x[n-1] = x[n]\n\n        // Update the output buffer (shift the samples)\n        gOutputKeepBuffer[1] = gOutputKeepBuffer[0]; // y[n-2] = y[n-1]\n        gOutputKeepBuffer[0] = y;                     // y[n-1] = y[n]\n\n        return y | 0;\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n                eegSignalPower = eegSignalPower * 0.99 + 0.01 * (Math.abs(tempCalculationValue - 512))\n                filteredValue = filterSingleSample(tempCalculationValue)\n                eegNotchedSignalPower = eegNotchedSignalPower * 0.99 + 0.01 * (Math.abs(filteredValue - 512))\n                eegAlphaPower = (eegSignalPower - eegNotchedSignalPower) - BASELINE_ALPHA;\n                if (eegAlphaPower < 0) {\n                    eegAlphaPower = 0;\n                }\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"StartRecordingEMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"StartRecordingECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"StartRecordingEEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"getSignal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"getBuffer || of last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [0];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"getEnvelope\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n            \n            // return envelopeValue;\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return eegAlphaPower;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=30\n    //% block=\"get max singal from $duration (ms) || * $constant\"\n    //% expandableArgumentMode=\"enable\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    //% constant.defl=1\n    export function getMaxSignal(duration: number, constant?: number): number {\n        if (duration < 0 || constant < 0) {\n            return undefined;\n        }\n\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n        \n        while (control.millis() - startTimer < duration) {\n            val = getEnvelope();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return max_val * constant;\n    }\n\n    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"get spikes from $duration (ms)\"\n    //% duration.shadow=timePicker\n    //% duration.defl=3000\n    export function getSpikes(duration: number): number {\n        basic.pause(50); //To avoid weird spike happen when turning on\n\n        if (duration < 0) {\n            return undefined;\n        }\n        \n        const THRESHOLD = 50;\n\n        let signal = 0;\n        let counter = 0;\n        let check_once = false;\n\n        const startTimer = control.millis();\n        while (control.millis() - startTimer < duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                if (control.millis() - startTimer > duration) {\n                    return -1;\n                }\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return counter;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=28\n    //% block=\"get reaction time|| with threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=50\n    export function getReactionTime(threshold?: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (threshold < 0) {\n            return undefined;\n        }\n\n        const time_limit = 10000; // Maximum 10 seconds to make reaction\n        let signal = 0;\n        let result_time = 0;\n\n        const startTime = control.millis();\n\n        signal = getEnvelope();\n        while (signal < threshold) {\n            signal = getEnvelope();\n            result_time = control.millis() - startTime;\n            if (result_time > time_limit) return time_limit;\n            serial.writeLine(\"\");\n        }\n\n        return result_time;\n    }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"Print $shape signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                    // serial.writeValue(signal_label, getEnvelope());\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                    // serial.writeValue(signal_label, getEnvelope());\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free Testing Space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1728492310435,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"device_forever\" x=\"331\" y=\"-35\"><statement name=\"HANDLER\"><block type=\"controls_if\"><mutation else=\"1\"></mutation><value name=\"IF0\"><shadow type=\"logic_boolean\"><field name=\"BOOL\">TRUE</field></shadow><block type=\"logic_compare\"><field name=\"OP\">GT</field><value name=\"A\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"spikerbit_getEnvelope\"></block></value><value name=\"B\"><shadow type=\"math_number\"><field name=\"NUM\">25</field></shadow></value></block></value><statement name=\"DO0\"><block type=\"servoservosetangle\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractorPicker\"><field name=\"angle\">90</field></shadow></value></block></statement><statement name=\"ELSE\"><block type=\"servoservosetangle\"><field name=\"servo\">servos.P0</field><value name=\"degrees\"><shadow type=\"protractorPicker\"><field name=\"angle\">180</field></shadow></value></block></statement></block></statement></block><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"spikerbit_startRecordingEMG\"><next><block type=\"spikerbit_print\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" _expanded=\"0\" _input_init=\"true\"></mutation><field name=\"shape\">SignalShape.ENVELOPE</field><value name=\"duration\"><shadow type=\"timePicker\"><field name=\"ms\">0</field></shadow></value></block></next></block></statement></block></xml>","main.ts":"","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    RAW,\n    ENVELOPE\n}\n\n\n\n//% color=\"#FF805E\" icon=\"\\uf188\" weight=90\nnamespace spikerbit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    \n    let envelopeValue: number = 0;\n\n    const ECG_JUMP = 40;\n    const DEBOUNCE_PERIOD_ECG = 300;\n\n    let ecgTimestamps: number[] = [];\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n\n    const SAMPLING_RATE: number = 250; // Hz\n    const ALPHA_WAVE_FREQUENCY: number = 10; // Hz (Notch frequency)\n    const Q: number = 1; // Quality factor\n    const BASELINE_ALPHA: number = 20;\n\n    let gInputKeepBuffer: number[] = [0, 0];\n    let gOutputKeepBuffer: number[] = [0, 0];\n\n    let tempCalculationValue: number = 0\n    let coefficients: number[] = [0, 0, 0, 0, 0];\n    let eegSignalPower: number = 0;\n    let eegNotchedSignalPower: number = 0;\n    let filteredValue: number = 0;\n    let eegAlphaPower: number = 0;\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 20; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Calculate intermediate variables and set filter coefficients\n     */\n    function calculateNotchCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = 1 / a0;\n        const b1 = (-2 * omegaC) / a0;\n        const b2 = 1 / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n        // Set the coefficients array\n        coefficients[0] = b0;\n        coefficients[1] = b1;\n        coefficients[2] = b2;\n        coefficients[3] = a1;\n        coefficients[4] = a2;\n    }\n    \n    function filterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (coefficients[0] * inputValue) +\n            (coefficients[1] * gInputKeepBuffer[0]) +\n            (coefficients[2] * gInputKeepBuffer[1]) -\n            (coefficients[3] * gOutputKeepBuffer[0]) -\n            (coefficients[4] * gOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        gInputKeepBuffer[1] = gInputKeepBuffer[0]; // x[n-2] = x[n-1]\n        gInputKeepBuffer[0] = inputValue;           // x[n-1] = x[n]\n\n        // Update the output buffer (shift the samples)\n        gOutputKeepBuffer[1] = gOutputKeepBuffer[0]; // y[n-2] = y[n-1]\n        gOutputKeepBuffer[0] = y;                     // y[n-1] = y[n]\n\n        return y | 0;\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n                eegSignalPower = eegSignalPower * 0.99 + 0.01 * (Math.abs(tempCalculationValue - 512))\n                filteredValue = filterSingleSample(tempCalculationValue)\n                eegNotchedSignalPower = eegNotchedSignalPower * 0.99 + 0.01 * (Math.abs(filteredValue - 512))\n                eegAlphaPower = (eegSignalPower - eegNotchedSignalPower) - BASELINE_ALPHA;\n                if (eegAlphaPower < 0) {\n                    eegAlphaPower = 0;\n                }\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"start recording EMG\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"start recording ECG\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"start recording EEG\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"get signal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"get buffer || of last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [0];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"get envelope\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n            \n            // return envelopeValue;\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"get heart rate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"get alpha waves\"\n    export function getAlphaWaves(): number {\n        return eegAlphaPower;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=30\n    //% block=\"get max singal from $duration (ms) || * $constant\"\n    //% expandableArgumentMode=\"enable\"\n    //% duration.shadow=timePicker\n    //% duration.defl=1000\n    //% constant.defl=1\n    export function getMaxSignal(duration: number, constant?: number): number {\n        if (duration < 0 || constant < 0) {\n            return undefined;\n        }\n\n        const startTimer = control.millis();\n        let val = 0;\n        let max_val = 0;\n        \n        while (control.millis() - startTimer < duration) {\n            val = getEnvelope();\n\n            if (max_val < val) {\n                max_val = val;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return max_val * constant;\n    }\n\n    //% group=\"Experiments helper\"\n    //% weight=29\n    //% block=\"get spikes from $duration (ms)\"\n    //% duration.shadow=timePicker\n    //% duration.defl=3000\n    export function getSpikes(duration: number): number {\n        basic.pause(50); //To avoid weird spike happen when turning on\n\n        if (duration < 0) {\n            return undefined;\n        }\n        \n        const THRESHOLD = 50;\n\n        let signal = 0;\n        let counter = 0;\n        let check_once = false;\n\n        const startTimer = control.millis();\n        while (control.millis() - startTimer < duration) {\n            signal = getEnvelope();\n\n            while (signal > THRESHOLD) {\n                if (control.millis() - startTimer > duration) {\n                    return -1;\n                }\n                signal = getEnvelope();\n                check_once = true;\n                serial.writeLine(\"\");\n            }\n\n            if (check_once) {\n                counter++;\n                check_once = false;\n            }\n\n            serial.writeLine(\"\");\n        }\n\n        return counter;\n    }\n\n\n    //% group=\"Experiments helper\"\n    //% weight=28\n    //% block=\"get reaction time|| with threshold $threshold\"\n    //% expandableArgumentMode=\"enable\"\n    //% threshold.defl=50\n    export function getReactionTime(threshold?: number): number {\n        basic.pause(10); //To avoid weird spike happen when turning on\n\n        if (threshold < 0) {\n            return undefined;\n        }\n\n        const time_limit = 10000; // Maximum 10 seconds to make reaction\n        let signal = 0;\n        let result_time = 0;\n\n        const startTime = control.millis();\n\n        signal = getEnvelope();\n        while (signal < threshold) {\n            signal = getEnvelope();\n            result_time = control.millis() - startTime;\n            if (result_time > time_limit) return time_limit;\n            serial.writeLine(\"\");\n        }\n\n        return result_time;\n    }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"print $shape signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                    // serial.writeValue(signal_label, getEnvelope());\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.ENVELOPE) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                    // serial.writeValue(signal_label, getEnvelope());\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free Testing Space\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1728494865248,"editorVersion":"7.0.42","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables></xml>","main.ts":"\n","README.md":"","custom.ts":"// Enums to be used in extension\nenum Signal {\n    EMG,\n    EEG,\n    ECG\n}\n\nenum SignalShape {\n    DEFAULT,\n    CONTROL\n}\n\n\n\n//% color=\"#FF805E\" icon=\"\\uf188\" weight=90\nnamespace spikerbit {\n    const FS = 250; //[Hz]\n    const TIME_RANGE = 5000; //[ms]\n    const MAX_BUFFER_SIZE = (FS * (TIME_RANGE / 1000));\n    const PIN = AnalogPin.P1;\n\n    let buffer: number[] = [];\n    let write_index = 0;\n    let read_index = 0;\n    let signal_label = \"EEG\"; //Default EEG (right now)\n\n    let envelope_sum: number = 0;\n    let envelope_buffer: number[] = [];\n\n    let signalType: Signal = Signal.EMG\n    let notInitialized = 1\n\n    const NOISE_FLOOR = 580;\n    const ENVELOPE_DECAY = 2;\n    \n    let envelopeValue: number = 0;\n\n    const ECG_JUMP = 40;\n    const DEBOUNCE_PERIOD_ECG = 300;\n\n    let ecgTimestamps: number[] = [];\n    let tempCaluclationValue: number = 0\n    let lastSample = 0\n    let bpmECG: number = 0\n\n    const SAMPLING_RATE: number = 250; // Hz\n    const ALPHA_WAVE_FREQUENCY: number = 10; // Hz (Notch frequency)\n    const Q: number = 1; // Quality factor\n    const BASELINE_ALPHA: number = 20;\n\n    let gInputKeepBuffer: number[] = [0, 0];\n    let gOutputKeepBuffer: number[] = [0, 0];\n\n    let tempCalculationValue: number = 0\n    let coefficients: number[] = [0, 0, 0, 0, 0];\n    let eegSignalPower: number = 0;\n    let eegNotchedSignalPower: number = 0;\n    let filteredValue: number = 0;\n    let eegAlphaPower: number = 0;\n\n    function convolution(new_signal: number) {\n        /* \n            Currently, \n            time complexity O(window_size)\n            memory space O(window_size) \n\n        */\n\n        // Initialization\n        const window_size = 20; // Arbitray: decided based on smoothness of signal\n        const kernel = 1 / window_size; // Have \"better\" kernel?\n\n        // Just to be safe\n        if (isNaN(new_signal)) {\n            return 0;\n        }\n\n        // If buffer length is less than the window size\n        if (envelope_buffer.length < window_size) {\n            // Only push to the buffer\n            envelope_buffer.push(new_signal);\n            envelope_sum = envelope_sum + new_signal;\n\n            return 0;\n        }\n        // Update the buffer\n        else {\n            let old_signal = envelope_buffer.shift() as number;\n            envelope_buffer.push(new_signal);\n\n            // Perform the convolution(dot product of buffer and \"kernel\")\n            envelope_sum = envelope_sum - old_signal + new_signal;\n\n            return envelope_sum * kernel;\n        }\n    }\n\n    /**\n     * Calculate intermediate variables and set filter coefficients\n     */\n    function calculateNotchCoefficients(Fc: number, Q: number, Fs: number): void {\n        const omega = (2 * Math.PI * Fc) / Fs;\n        const omegaS = Math.sin(omega);\n        const omegaC = Math.cos(omega);\n        const alpha = omegaS / (2 * Q);\n\n        const a0 = 1 + alpha;\n        const b0 = 1 / a0;\n        const b1 = (-2 * omegaC) / a0;\n        const b2 = 1 / a0;\n        const a1 = (-2 * omegaC) / a0;\n        const a2 = (1 - alpha) / a0;\n\n        // Set the coefficients array\n        coefficients[0] = b0;\n        coefficients[1] = b1;\n        coefficients[2] = b2;\n        coefficients[3] = a1;\n        coefficients[4] = a2;\n    }\n    \n    function filterSingleSample(inputValue: number): number {\n        // Compute the filtered output using the difference equation:\n        // y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]\n        const y = (coefficients[0] * inputValue) +\n            (coefficients[1] * gInputKeepBuffer[0]) +\n            (coefficients[2] * gInputKeepBuffer[1]) -\n            (coefficients[3] * gOutputKeepBuffer[0]) -\n            (coefficients[4] * gOutputKeepBuffer[1]);\n\n        // Update the input buffer (shift the samples)\n        gInputKeepBuffer[1] = gInputKeepBuffer[0]; // x[n-2] = x[n-1]\n        gInputKeepBuffer[0] = inputValue;           // x[n-1] = x[n]\n\n        // Update the output buffer (shift the samples)\n        gOutputKeepBuffer[1] = gOutputKeepBuffer[0]; // y[n-2] = y[n-1]\n        gOutputKeepBuffer[0] = y;                     // y[n-1] = y[n]\n\n        return y | 0;\n    }\n\n\n    // Define your background function\n    function backgroundTask(): void {\n        pins.digitalWritePin(DigitalPin.P2, 1)\n        const time_delay = 20; //[ms] (delay from write to read)\n        const index_delay = Math.ceil(FS / (1000 / time_delay));\n\n        // Initialize all element inside buffer with 0 to avoid NaN reading\n        for (let i = 0; i < MAX_BUFFER_SIZE; i++) {\n            buffer[i] = 0;\n        }\n\n        // background processing\n        while (true) {\n            lastSample = tempCaluclationValue;\n\n            buffer[write_index] = pins.analogReadPin(PIN);\n            tempCaluclationValue = buffer[write_index];\n\n            write_index++;\n\n            // Loop back write_index after reach to end\n            if (write_index >= MAX_BUFFER_SIZE) {\n                write_index = 0;\n            }\n\n            // Caluclation for correct read_index\n            if (write_index < index_delay) {\n                read_index = MAX_BUFFER_SIZE - (index_delay - write_index);\n            }\n            else {\n                read_index = write_index - index_delay;\n            }\n\n\n\n            if (signalType == Signal.ECG) {\n                if ((tempCaluclationValue - lastSample) > ECG_JUMP) {\n                    let currentMillis = control.millis()\n                    if (ecgTimestamps.length > 0) {\n                        if ((currentMillis - ecgTimestamps[ecgTimestamps.length - 1]) > DEBOUNCE_PERIOD_ECG) {\n                            ecgTimestamps.push(currentMillis)\n                        }\n                    }\n                    else {\n                        ecgTimestamps.push(currentMillis)\n                    }\n\n                    if (ecgTimestamps.length > 3) {\n                        ecgTimestamps.removeAt(0)\n                        bpmECG = (120000 / (ecgTimestamps[2] - ecgTimestamps[1] + ecgTimestamps[1] - ecgTimestamps[0])) | 0\n                    }\n\n                }\n            }\n            else if (signalType == Signal.EMG) {\n                tempCaluclationValue = tempCaluclationValue - NOISE_FLOOR;\n                if (tempCaluclationValue > 0) {\n                    if (tempCaluclationValue > envelopeValue) {\n                        envelopeValue = tempCaluclationValue;\n                    }\n                }\n\n                envelopeValue = envelopeValue - ENVELOPE_DECAY;\n\n                if (envelopeValue < 0) {\n                    envelopeValue = 0;\n                }\n            }\n            else if (signalType = Signal.EEG) {\n                eegSignalPower = eegSignalPower * 0.99 + 0.01 * (Math.abs(tempCalculationValue - 512))\n                filteredValue = filterSingleSample(tempCalculationValue)\n                eegNotchedSignalPower = eegNotchedSignalPower * 0.99 + 0.01 * (Math.abs(filteredValue - 512))\n                eegAlphaPower = (eegSignalPower - eegNotchedSignalPower) - BASELINE_ALPHA;\n                if (eegAlphaPower < 0) {\n                    eegAlphaPower = 0;\n                }\n            }\n\n            pins.digitalWritePin(DigitalPin.P2, 0);\n\n            basic.pause(0);\n        }\n    }\n\n\n\n    /**\n     * Start recording EMG signal \n     */\n\n    //% group=\"Initialization\"\n    //% weight=45 \n    //% block=\"StartMuscleRecording\"\n    export function startRecordingEMG(): void {\n        signal_label = \"EMG\";\n        signalType = Signal.EMG;\n        pins.digitalWritePin(DigitalPin.P8, 1)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n\n    /**\n     * Start recording ECG signal\n     */\n\n    //% group=\"Initialization\"\n    //% weight=44 \n    //% block=\"StartHeartRecording\"\n    export function startRecordingECG(): void {\n        signal_label = \"ECG\";\n        signalType = Signal.ECG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 1)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n * Start recording EEG signal\n */\n\n    //% group=\"Initialization\"\n    //% weight=43 \n    //% block=\"StartBrainRecording\"\n    export function startRecordingEEG(): void {\n        signal_label = \"EEG\";\n        signalType = Signal.EEG;\n        pins.digitalWritePin(DigitalPin.P8, 0)\n        pins.digitalWritePin(DigitalPin.P9, 0)\n        if (notInitialized) {\n            control.inBackground(() => {\n                backgroundTask()\n            })\n        }\n    }\n\n    /**\n     * Return last measured value of the signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=42\n    //% block=\"getSignal\"\n    export function getSignal(): number {\n        if (buffer.length > 0) {\n            return buffer[read_index];\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return user defined seconds of recorded signal\n     */\n\n    //% group=\"Raw data\"\n    //% weight=41 \n    //% block=\"getSignalBlock || from last $ms (ms)\"\n    //% ms.shadow=timePicker\n    //% ms.defl = 5000\n    export function getBuffer(ms: number): number[] {\n        if (ms == TIME_RANGE) {\n            return buffer;\n        }\n        else if (ms < 0 || ms > TIME_RANGE) {\n            return [0];\n        }\n        else {\n            let required_size = Math.ceil((FS * (ms / 1000.0)));;\n\n            let start_idx = (read_index - (required_size - 1) + MAX_BUFFER_SIZE) % MAX_BUFFER_SIZE; // Start index (wrapped)\n            let end_idx = (read_index + 1) % MAX_BUFFER_SIZE; // End index is always read_idx + 1 (assuming read_index is newest)\n\n            if (start_idx < end_idx) {\n                // If the range fits without wrapping around\n                return buffer.slice(start_idx, end_idx);\n            } else {\n                // If the range wraps around, slice in two parts then concatinate\n                return buffer.slice(start_idx, MAX_BUFFER_SIZE).concat(buffer.slice(0, end_idx));\n            }\n        }\n    }\n\n    /**\n         * Return last envelope value\n         */\n\n    //% group=\"Processed data\"\n    //% weight=40\n    //% block=\"getControlSignal\"\n    export function getEnvelope(): number {\n        if (buffer.length > 0) {\n            // Obtain the signal + set baseline to 0\n            let signal = getSignal() - 512;\n            // Rectify the signal\n            let rectified_signal = Math.abs(signal);\n\n            // Serial Out the signal\n            return convolution(rectified_signal);\n            \n            // return envelopeValue;\n        }\n        else {\n            return 0;\n        }\n    }\n\n    /**\n         * Return heart rate\n         */\n\n    //% group=\"Processed data\"\n    //% weight=39\n    //% block=\"getHeartRate\"\n    export function getHeartRate(): number {\n        return bpmECG;\n    }\n\n    /**\n         * Return alpha waves power\n         */\n\n    //% group=\"Processed data\"\n    //% weight=38\n    //% block=\"getAlphaWaves\"\n    export function getAlphaWaves(): number {\n        return eegAlphaPower;\n    }\n\n\n    // //% group=\"Experiments helper\"\n    // //% weight=30\n    // //% block=\"get max singal from $duration (ms) || * $constant\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% duration.shadow=timePicker\n    // //% duration.defl=1000\n    // //% constant.defl=1\n    // export function getMaxSignal(duration: number, constant?: number): number {\n    //     if (duration < 0 || constant < 0) {\n    //         return undefined;\n    //     }\n\n    //     const startTimer = control.millis();\n    //     let val = 0;\n    //     let max_val = 0;\n        \n    //     while (control.millis() - startTimer < duration) {\n    //         val = getEnvelope();\n\n    //         if (max_val < val) {\n    //             max_val = val;\n    //         }\n\n    //         serial.writeLine(\"\");\n    //     }\n\n    //     return max_val * constant;\n    // }\n\n    // //% group=\"Experiments helper\"\n    // //% weight=29\n    // //% block=\"get spikes from $duration (ms)\"\n    // //% duration.shadow=timePicker\n    // //% duration.defl=3000\n    // export function getSpikes(duration: number): number {\n    //     basic.pause(50); //To avoid weird spike happen when turning on\n\n    //     if (duration < 0) {\n    //         return undefined;\n    //     }\n        \n    //     const THRESHOLD = 50;\n\n    //     let signal = 0;\n    //     let counter = 0;\n    //     let check_once = false;\n\n    //     const startTimer = control.millis();\n    //     while (control.millis() - startTimer < duration) {\n    //         signal = getEnvelope();\n\n    //         while (signal > THRESHOLD) {\n    //             if (control.millis() - startTimer > duration) {\n    //                 return -1;\n    //             }\n    //             signal = getEnvelope();\n    //             check_once = true;\n    //             serial.writeLine(\"\");\n    //         }\n\n    //         if (check_once) {\n    //             counter++;\n    //             check_once = false;\n    //         }\n\n    //         serial.writeLine(\"\");\n    //     }\n\n    //     return counter;\n    // }\n\n\n    // //% group=\"Experiments helper\"\n    // //% weight=28\n    // //% block=\"get reaction time|| with threshold $threshold\"\n    // //% expandableArgumentMode=\"enable\"\n    // //% threshold.defl=50\n    // export function getReactionTime(threshold?: number): number {\n    //     basic.pause(10); //To avoid weird spike happen when turning on\n\n    //     if (threshold < 0) {\n    //         return undefined;\n    //     }\n\n    //     const time_limit = 10000; // Maximum 10 seconds to make reaction\n    //     let signal = 0;\n    //     let result_time = 0;\n\n    //     const startTime = control.millis();\n\n    //     signal = getEnvelope();\n    //     while (signal < threshold) {\n    //         signal = getEnvelope();\n    //         result_time = control.millis() - startTime;\n    //         if (result_time > time_limit) return time_limit;\n    //         serial.writeLine(\"\");\n    //     }\n\n    //     return result_time;\n    // }\n\n    //% group=\"Other\"\n    //% weight=20\n    //% block=\"Print $shape Signal ||for $duration (ms)\"\n    //% shape.defl = 0\n    //% duration.shadow=timePicker\n    //% expandableArgumentMode=\"enable\"\n    //% duration.defl=0\n    export function print(shape: SignalShape, duration?: number) {\n        let startTime = 0;\n\n        // Default: show serial output forever\n        if (duration == 0) {\n            while (true) {\n                if (shape == SignalShape.CONTROL) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                    // serial.writeValue(signal_label, getEnvelope());\n                }\n                else {\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n        }\n        // Optional: show serial output as long as duration\n        else {\n            let debug_count = 0;\n            startTime = control.millis();\n            while (control.millis() - startTime < duration) {\n                if (shape == SignalShape.CONTROL) {\n                    // Obtain the signal + set baseline to 0\n                    let signal = getSignal() - 512;\n                    // Rectify the signal\n                    let rectified_signal = Math.abs(signal);\n\n                    // Serial Out the signal\n                    serial.writeValue(signal_label, convolution(rectified_signal));\n                    // serial.writeValue(signal_label, getEnvelope());\n                }\n                else {\n                    // Serial Out the signal\n                    debug_count++;\n                    serial.writeValue(signal_label, getSignal());\n                }\n            }\n            basic.showNumber(debug_count);\n        }\n    }\n\n\n}","pxt.json":"{\n    \"name\": \"Free Testing Space - Copy\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v6.0.28\",\n        \"tag\": \"v6.0.28\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9d308fa3c282191768670a6558e4df8af2d715cf\",\n        \"target\": \"6.0.28\",\n        \"pxt\": \"9.0.19\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1728494941931}